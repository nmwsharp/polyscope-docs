{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Polyscope is a C++/Python viewer and user interface for 3D data such as meshes and point clouds. It allows you to register your data and quickly generate informative and beautiful visualizations, either programmatically or via a dynamic GUI. Polyscope is designed to be lightweight\u2014it does not \u201ctake ownership\u201d over your entire program, and it is easy to integrate with existing codebases and popular libraries. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code.</p> <p>Polyscope uses a paradigm of structures and quantities. A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field.</p> <p>When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling visibility, color-mapping data and adjusting maps, \u201cpicking\u201d to click in the scene and query numerical quantities, etc.</p> <p>Note: There are two variants of this documentation, for C++ and Python. Use the buttons on the top bar to change language.</p> <p>A simple workflow for visualizing data in Polyscope looks like:</p> C++Python <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\n// Initialize polyscope\npolyscope::init();\n\n// Register a point cloud\n// `points` is a Nx3 array-like container of points\npolyscope::registerPointCloud(\"my points\", points)\n\n// Register a surface mesh structure\n// `meshVerts` is a Vx3 array-like container of vertex positions\n// `meshFaces` is a Fx3 array-like container of face indices  \npolyscope::registerSurfaceMesh(\"my mesh\", meshVerts, meshFaces);\n\n// Add a scalar and a vector function defined on the mesh\n// `scalarQuantity` is a length V array-like container of values\n// `vectorQuantity` is an Fx3 array-like container of vectors per face\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addVertexScalarQuantity(\"my_scalar\", scalarQuantity);\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addFaceVectorQuantity(\"my_vector\", vectorQuantity);\n\n// View the point cloud and mesh we just registered in the 3D UI\npolyscope::show();\n</code></pre> <pre><code>import polyscope as ps\n\n# Initialize polyscope\nps.init()\n\n### Register a point cloud\n# `my_points` is a Nx3 numpy array\nps.register_point_cloud(\"my points\", my_points)\n\n### Register a mesh\n# `verts` is a Nx3 numpy array of vertex positions\n# `faces` is a Fx3 array of indices, or a nested list\nps.register_surface_mesh(\"my mesh\", verts, faces, smooth_shade=True)\n\n# Add a scalar function and a vector function defined on the mesh\n# vertex_scalar is a length V numpy array of values\n# face_vectors is an Fx3 array of vectors per face\nps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"my_scalar\", \n        vertex_scalar, defined_on='vertices', cmap='blues')\nps.get_surface_mesh(\"my mesh\").add_vector_quantity(\"my_vector\", \n        face_vectors, defined_on='faces', color=(0.2, 0.5, 0.5))\n\n# View the point cloud and mesh we just registered in the 3D UI\nps.show()\n</code></pre> <p>Polyscope is designed to make your life easier. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing. In C++, some template magic means Polyscope can probably accept the data types you\u2019re already using!</p> <p>Author: Nicholas Sharp</p> <p>If Polyscope contributes to an academic publication, cite it as: <pre><code>@misc{polyscope,\ntitle = {Polyscope},\nauthor = {Nicholas Sharp and others},\nnote = {www.polyscope.run},\nyear = {2019}\n}\n</code></pre></p> <p>Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.</p>"},{"location":"#_1","title":"Home","text":""},{"location":"data_adaptors/","title":"Data Adaptors","text":"<p>Polyscope is designed as a lightweight general-purpose 3D visualization library. But there\u2019s a problem, because different codebases uses different C++ types to store their data: is an array of scalars a <code>std::vector&lt;double&gt;</code> or an <code>Eigen::VectorXf</code> or some other internal type? Codebases for 3D geometry are particularly guilty of this: there are probably several hundred distinct 3D vector x-y-z classes floating around github.</p> <p>Rather than forcing the user to manually convert their data types to some Polyscope types, we implement a series of templated adaptor functions, which attempt to read from the user types via a common set of strategies. These adaptors are applied to the inputs to nearly all Polyscope functions, allowing them to automatically accept user-defined types as inputs.</p> <p>You don\u2019t need to do anything special to use these adaptors! They are applied internally to the arguments of nearly every Polyscope function, like the <code>vertices</code> and <code>faces</code> arguments of <code>registerSurfaceMesh(\"name\", vertices, faces)</code>. This section outlines how the adaptors will try to read from your data, and how to extend them for unusual datatypes which are not automatically handled.</p> <p>These functions live in <code>#include \"polyscope/standardize_data_array.h\"</code>. It\u2019s fairly well-commented\u2014check it out to see how all this works under the hood!</p>"},{"location":"data_adaptors/#fixed-size-vector-types","title":"Fixed size vector types","text":"<p>These are 2D or 3D vectors whose size are known at compile time, commonly used to represent things like positions (3D), or UV coordinates (2D).</p> <p>Examples of 3D vector types that Polyscope can read from out of the box include <code>glm::vec3</code>, <code>Eigen::Vector3d</code>, and <code>std::array&lt;double, 3&gt;</code> (likewise for 2D).</p>"},{"location":"data_adaptors/#hierarchy","title":"Hierarchy","text":"<p>Polyscope will attempt to access an input 2D vector in the following ways, in order of decreasing precedence:</p> <ul> <li>any user-defined function (see below)</li> <li>bracketed indices (like <code>vec[0]</code> and <code>vec[1]</code>)</li> <li>members <code>x</code>,<code>y</code> (like <code>vec.x</code> and <code>vec.y</code>)</li> <li>members <code>u</code>,<code>v</code> (like <code>vec.u</code> and <code>vec.v</code>)</li> <li>members functions <code>real()</code>/<code>imag()</code> (like <code>vec.real()</code> and <code>vec.imag()</code>)</li> </ul> <p>Polyscope will attempt to access an input 3D vector in the following ways, in order of decreasing precedence:</p> <ul> <li>any user-defined function (see below)</li> <li>bracketed indices (like <code>vec[0]</code>, <code>vec[1]</code>, and <code>vec[2]</code>)</li> <li>members <code>x</code>,<code>y</code>,<code>z</code> (like <code>vec.x</code>, <code>vec.y</code>, and <code>vec.z</code>)</li> </ul> using Eigen fixed-size vectorizable types <p>If you are using fixed-sized, vectorizable Eigen types like <code>Eigen::Vector2f</code> and <code>Eigen::Vector4f</code> as your 2D/3D vector types, there are special, tricky alignment rules imposed by Eigen which must be respected.  For instance, a <code>std::vector&lt;Eigen::Vector2f&gt;</code> is not a valid type; using it will lead to tricky-to-debug segfaults.</p> <p>Polyscope makes a best effort to avoid problems when the caller\u2019s fixed vector type has alignment constraints, but beware\u2014these are dangerous waters.</p> <p>See Eigen\u2019s documentation here and here for more information.</p> extending vector access"},{"location":"data_adaptors/#extending","title":"Extending","text":"<p>Suppose you have an in-house vector type which cannot be accessed by any strategy in the hierarchy above. You can define a custom function that accesses the elements of your type: <pre><code>YOUR_TYPES_SCALAR adaptorF_custom_accessVector2Value(const YOUR_TYPE&amp; v, unsigned int ind);\n</code></pre> The array adaptors will pick up this function and use it to access your type.</p> <p>Example: <pre><code>// A vector2 type with unusual access\nstruct UserVector2Custom {\ndouble foo;\ndouble bar;\n};\n\n// Define an accessor to teach Polyscope to read from your type\ndouble adaptorF_custom_accessVector2Value(const UserVector2Custom&amp; v, unsigned int ind) {\nif (ind == 0) return v.foo;\nif (ind == 1) return v.bar;\nthrow std::logic_error(\"bad access\");\nreturn -1.;\n}\n\n// Now Polyscope functions can take this type as input!\n</code></pre></p> <p>The same principle applies for 3D vectors, where the relevant function is named <pre><code>YOUR_TYPES_SCALAR adaptorF_custom_accessVector3Value(const YOUR_TYPE&amp; v, unsigned int ind);\n</code></pre></p>"},{"location":"data_adaptors/#array-size","title":"Array size","text":"<p>The three array adaptor variants below (scalar array, vector array, and nested array) all assume the ability to read the size of an input array. </p>"},{"location":"data_adaptors/#hierarchy_1","title":"Hierarchy","text":"<p>Polyscope will attempt to read the length of an input array in the following ways, in decreasing order of precedence:</p> <ul> <li>any user-defined function (see below)</li> <li>a <code>.rows()</code> member function (like <code>inputData.rows()</code>)</li> <li>a <code>.size()</code> member function (like <code>inputData.size()</code>)</li> <li>for tuple <code>{ptr,size}</code> entries, try checking the second tuple entry</li> </ul> extending array size"},{"location":"data_adaptors/#extending_1","title":"Extending","text":"<p>Suppose you have an in-house array type whose length cannot be read by any strategy in the hierarchy above. You can define a custom function that reads the length like: <pre><code>size_t adaptorF_custom_size(const YOUR_ARRAY_TYPE&amp; c);\n</code></pre> The array adaptors will pick up this function and use it to access your type.</p> <p>Example: <pre><code>// Array with custom length function called \"bigness()\"\nstruct UserArray {\nstd::vector&lt;double&gt; myData;\nsize_t bigness() const { return myData.size(); }\n};\n\n// Size function for custom array\nsize_t adaptorF_custom_size(const UserArray&amp; c) { return c.bigness(); }\n</code></pre></p>"},{"location":"data_adaptors/#scalar-arrays","title":"Scalar arrays","text":"<p>A scalar array is a long list of values, like a <code>float</code> at each point in a point cloud, or an <code>int</code> at each vertex of a mesh. We will use the type <code>S</code> to refer to the inner scalar type of an array, like <code>float</code> in <code>std::vector&lt;float&gt;</code>.</p> <p>Examples of scalar arrays that Polyscope can read from out of the box include <code>std::vector&lt;float&gt;</code>, <code>Eigen::VectorXd</code>, and <code>std::list&lt;int&gt;</code>.</p>"},{"location":"data_adaptors/#hierarchy_2","title":"Hierarchy","text":"<p>Polyscope will attempt to access an input scalar array in the following ways, in order of decreasing precedence:</p> <ul> <li>any user-defined function (see below)</li> <li>bracketed index access (like <code>array[i]</code>)</li> <li>parenthesis index access (like <code>array(i)</code>)</li> <li>for-each iteration (like <code>array.begin()</code>, <code>array.end()</code>)</li> <li>reading from a tuple of {data pointer (e.g. float*), size (int)}, where ptr points to a flat buffer of data (like <code>std::make_tuple(&amp;data[0], data_size)</code>)</li> </ul> extending scalar array access"},{"location":"data_adaptors/#extending_2","title":"Extending","text":"<p>Suppose you have an in-house array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a <code>std::vector&lt;S&gt;</code> like <pre><code>std::vector&lt;YOUR_SCALAR_TYPE&gt; adaptorF_custom_convertToStdVector(const YOUR_ARRAY_TYPE&amp; c) {\n</code></pre> The array adaptors will pick up this function and use it to access your type.</p> <p>Example: <pre><code>// User array with unusual access\nstruct UserArrayFuncAccess {\nstd::vector&lt;double&gt; myData;\nsize_t size() const { return myData.size(); }\n};\n\nstd::vector&lt;double&gt; adaptorF_custom_convertToStdVector(const UserArrayFuncAccess&amp; c) {\nstd::vector&lt;double&gt; out;\nfor (auto x : c.myData) {\nout.push_back(x);\n}\nreturn out;\n}\n</code></pre></p>"},{"location":"data_adaptors/#arrays-of-vectors","title":"Arrays of vectors","text":"<p>These are arrays of values where each element of the array is itself a fixed-size vector type, like the 3D position of each point in a point cloud, or a list of edges in a graph. Note that these arrays must have an inner dimension which is fixed and known at compile time.</p> <p>Examples of vector arrays that Polyscope can read from out of the box include <code>std::vector&lt;glm::vec3&gt;</code>, <code>Eigen::Matrx&lt;N,3&gt;</code>, and <code>std::list&lt;std::array&lt;int,2&gt;&gt;</code>.</p>"},{"location":"data_adaptors/#hierarchy_3","title":"Hierarchy","text":"<p>Polyscope will attempt to access an input array of vectors in the following ways, in order of decreasing precedence:</p> <ul> <li>any user-defined function (see below)</li> <li>dense parenthesis access (like <code>array(i,j)</code>)</li> <li>double bracket access (like <code>array[i][j]</code>)</li> <li>outer type bracket-accessible, inner type anything convertible to Vector2/3 (like <code>array[i].x</code>)</li> <li>outer type iterable, inner type anything convertible to Vector2/3 (like <code>for(auto vec : array)</code> and <code>vec.u</code>).</li> <li>outer type iterable, inner type bracket-accessible (like <code>for(auto vec : array)</code> and <code>vec[7]</code>)</li> <li>reading from a tuple of {data pointer (e.g. float*), size (int)}, where ptr points to a flat buffer of data (like <code>std::make_tuple(&amp;data[0], data_size)</code>). The buffer should have length <code>size*D</code>, laid out as <code>[x0 y0 z0 x1 y1 z1 ...]</code>.</li> </ul> <p>Notice that two these options make use of the fixed-sized vector adaptors. Once Polyscope can read the elements of <code>SOME_VEC3_TYPE</code>, it can also read from <code>std::vector&lt;SOME_VEC3_TYPE&gt;</code>, etc.</p> <p>The sizes of the inner vector type are generally not checked by Polyscope, so be sure you\u2019re passing in something with the right dimensions! If a function expects an array of 3D vectors, don\u2019t give it an array of 2D vectors.</p> extending array-of-vectors access"},{"location":"data_adaptors/#extending_3","title":"Extending","text":"<p>Suppose you have an in-house array-of-vectors type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a <code>std::vector&lt;S&gt;</code> like <pre><code>std::vector&lt;std::array&lt;SCALAR_T,N&gt;&gt; adaptorF_custom_convertArrayOfVectorToStdVector(const YOUR_ARRAY_TYPE&amp; c) </code></pre> The array adaptors will pick up this function and use it to access your type. Really, the return type of this method can anything that supports <code>.size()</code> and bracket access; <code>std::vector&lt;std::vector&lt;&gt;&gt;</code> would also work.  The size of the inner vector is not checked, so be sure it\u2019s right!</p> <p>Example: <pre><code>// An array of vectors with an unusual access scheme\nstruct UserArrayVectorCustom {\nstd::list&lt;SOME_TYPE&gt; vals;\nsize_t size() const { return vals.size(); }\n};\n\n// Define a custom access function\nstd::vector&lt;std::array&lt;double, 3&gt;&gt;\nadaptorF_custom_convertArrayOfVectorToStdVector(const UserArrayVectorCustom&amp; inputData) {\nstd::vector&lt;std::array&lt;double, 3&gt;&gt; out;\nfor (auto v : inputData.vals) {\nout.push_back({v.x(), v.y(), v.z()});\n}\nreturn out;\n}\n</code></pre></p>"},{"location":"data_adaptors/#nested-arrays","title":"Nested arrays","text":"<p>These are arrays-of-arrays, like the list of vertex indices for each face in a polygon mesh. Unlike the arrays-of-vectors above, the dimensions of the inner arrays need not be known at compile time, and can vary (though arrays with fixed-sized inner dimension are also valid input).</p> <p>Examples of vector arrays that Polyscope can read from out of the box include <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>, <code>Eigen::Matrix&lt;double,N,3&gt;</code>, and <code>std::vector&lt;std::list&lt;size_t&gt;&gt;</code>.</p>"},{"location":"data_adaptors/#hierarchy_4","title":"Hierarchy","text":"<p>Polyscope will attempt to access a nested array in the following ways, in order of decreasing precedence:</p> <ul> <li>any user defined function</li> <li>dense callable (parenthesis) access on a type that supports <code>array.rows()</code> and <code>array.cols()</code> (like <code>array(i,j)</code>).</li> <li>outer type bracket-accessible, inner type anything that can be accessed as a scalar array (like <code>array[i][j]</code>)</li> <li>outer type parenthesis-accessible, inner type anything that can be accessed as a scalar array (like <code>array(j)[i]</code>)</li> <li>outer type iterable, inner type anything that can be accessed as a scalar array (like <code>for(auto inner : array)</code> and <code>inner[7]</code>).</li> </ul> <p>Notice that several of these options make use of the scalar array adaptors. Once Polyscope can read from <code>YOUR_ARRAY&lt;S&gt;</code>, it can also read from <code>std::vector&lt;YOUR_ARRAY&lt;S&gt;&gt;</code>, etc.</p> extending nested array access"},{"location":"data_adaptors/#extending_4","title":"Extending","text":"<p>Suppose you have an in-house nested array type whose elements cannot be accessed by any strategy in the hierarchy above. You can define a custom function that converts your arrays to a <code>std::vector&lt;std::vector&lt;S&gt;&gt;</code> like <pre><code>std::vector&lt;std::vector&lt;S&gt;&gt; adaptorF_custom_convertNestedArrayToStdVector(const YOUR_NESTED_ARRAY&amp; inputData) {\n</code></pre> The array adaptors will pick up this function and use it to access your type. </p> <p>Example: <pre><code>// A nested list type with unusual access\nstruct UserNestedListCustom {\nstd::list&lt;std::vector&lt;int&gt;&gt; vals;\nsize_t size() const { return vals.size(); }\n};\nstd::vector&lt;std::vector&lt;int&gt;&gt; adaptorF_custom_convertNestedArrayToStdVector(const UserNestedListCustom&amp; inputData) {\nstd::vector&lt;std::vector&lt;int&gt;&gt; out;\nfor (auto v : inputData.vals) {\nstd::vector&lt;int&gt; inner;\nfor (auto x : v) {\ninner.push_back(x);\n}\nout.push_back(inner);\n}\nreturn out;\n}\n</code></pre></p>"},{"location":"data_adaptors/#debugging","title":"Debugging","text":"<p>One downside to our \u201cclever\u201d use of templates is that compiler error messages can be borderline incomprehensible. Generally, the best debugging strategy is to carefully read the documentation and ensure you are passing in data that makes sense. In most cases, the problem is something simple, like passing a 3D vector where a 2D vector is needed, or mixing up the order of arguments.</p> <p>However, if you are deep in the weeds trying to debug why your type isn\u2019t matching against the template hierarchy (or why a custom function isn\u2019t being used), consider adding the define <pre><code>#define POLYSCOPE_NO_STANDARDIZE_FALLTHROUGH\n</code></pre> anywhere before the Polyscope includes. This will cause most compilers to print the long scary list of all template substitutions which were considered and rejected, which you can slowly parse to aid you on your quest.</p>"},{"location":"FAQ/","title":"FAQ, Tips, and Tricks","text":"<ul> <li> <p>Interface</p> <ul> <li>Saving and restoring camera poses</li> <li>How do I take a screenshot / save an image?</li> <li>Positioning objects in the scene and reading back results</li> <li>Managing large numbers of structures and quantities</li> <li>How do I set up mouse click interactions and callbacks</li> </ul> </li> <li> <p>Appearance</p> <ul> <li>Visualizing colors as exact RGB values, without any shading or tonemapping</li> <li>Rendering figures for papers and presentations</li> </ul> </li> <li> <p>System</p> <ul> <li>How do I run Polyscope on a remote or headless server?</li> </ul> </li> </ul>"},{"location":"FAQ/#saving-and-restoring-camera-poses","title":"Saving and restoring camera poses","text":"<p>Use <code>lookAt()</code> and other functions to manually specify the viewing camera pose. </p> <p>Or, you can interactively position the camera in the scene, copy it to your clipboard as a json string with <code>ctrl-c</code>, then restore it from the clipboard with <code>ctrl-v</code>. These strings can also be saved and restored programmatically.</p>"},{"location":"FAQ/#how-do-i-take-a-screenshot-save-an-image","title":"How do I take a screenshot / save an image?","text":"<p>See Screenshots. Call <code>polyscope::screenshot()</code>, or click the <code>[screenshot]</code> button in the upper-left corner of the UI.</p>"},{"location":"FAQ/#positioning-objects-in-the-scene-and-reading-back-results","title":"Positioning objects in the scene and reading back results","text":"<p>See Transforms for various options and to set and get per-structure transformations. In the GUI, you can use the <code>[Options] --&gt; [Transform]</code> menu to enable a widget to interactively transform each object within the scene.</p>"},{"location":"FAQ/#managing-large-numbers-of-structures-and-quantities","title":"Managing large numbers of structures and quantities","text":"<p>Polyscope generally scales just fine with 100s or even 1000s of distinctly named structures in the scene. However, with this many structures, it may become difficult to select what you want in the UI. Polyscope has a few features which can help:</p> <p>Every structure has controls in its options UI menu under <code>Options --&gt; Structure Selection</code> and <code>Options --&gt; Quantity Selection</code> which can be used to enable/disable all structures and quantities, or isolate to viewing a single structure.</p> <p>Use Groups to group your structures in to categories which can be enabled/disabled all together. Notice the <code>hide descendants</code> and <code>show details</code> options on groups, which can totally hide structures from the UI while still offering some control via the group.</p> <p>You can always use the Custom UIs to create your own interface buttons and selectors which programmatically enable or disable registered objects or adjust their settings.</p>"},{"location":"FAQ/#how-do-i-set-up-mouse-click-interactions-and-callbacks","title":"How do I set up mouse click interactions and callbacks","text":"<p>See Mouse Interactions. There are no special callbacks for creating mouse events. Instead, you can implement almost any behavior you want via ImGui\u2019s built-in functions. There are also a few polyscope-specific functions to get information about scene at the location you clicked, such as constructing rays and querying depth.</p>"},{"location":"FAQ/#rendering-figures-for-papers-and-presentations","title":"Rendering figures for papers and presentations","text":"<p>Several settings can be customized to give a more polished appearance. Consider:</p> <ul> <li>Adjusting the ground plane to shadow-only for ground shadows </li> <li>Increasing antialiasing rate</li> <li>Saving screenshots with transparency for compositing</li> </ul>"},{"location":"FAQ/#visualizing-colors-as-exact-rgb-values-without-any-shading-or-tonemapping","title":"Visualizing colors as exact RGB values, without any shading or tonemapping","text":"<p>Normally, colors are shaded and tone-mapped for rendering, which means the colors and colormapped-values you specify are not exactly the colors Polyscope renders to the screen. Use the flat material to circumvent these effects, and ensure that colors are flat-shaded to the screen with exactly the RGB values specified.</p>"},{"location":"FAQ/#how-do-i-run-polyscope-on-a-remote-or-headless-server","title":"How do I run Polyscope on a remote or headless server?","text":"<p>It may not not be possible to use Polyscope on a remote headless machine which does not have a physical monitor. </p> <p>If the machine does have a display attached, there should be no problem. You can run and initialize Polyscope, and even if you are working remotely via script or SSH you can programmatically capture screenshots of the rendered scene. </p> <p>However, Polyscope will only work if it can create an operating system-level display window, which generally means having a physical monitor attached. Various virtual windowing systems and X-servers exist as a hypothetical workaround, however users have reported limited success with these tools, usually because they use software openGL renderers which do not support the openGL features required by Polyscope.</p> <p>In implementation terms, this limitation comes from needing to initialize an OpenGL 3.3 core-profile context using GLFW. Currently, GLFW can only create an openGL context when a display is present. If you find a good workaround for Polyscope on headless machines, please share! One day, we hope to implement an alternate EGL backend, which would support headless machines.</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Polyscope is an open-source project, and you are encouraged to contribute! The core library is lives in this repository, with documentation here and Python bindings here.</p> <p>All contributions will be released under Polyscope\u2019s MIT license.</p> <p>How to make a great pull request:</p> <p> Implement a feature or fix a bug</p> <p> Write a new unit test and run tests</p> <p> Submit a PR and ensure automated tests pass</p> <p> Update the documentation </p> <p> Create any new Python bindings</p> <p>Of course, contributions that only do some of the above are still welcome and appreciated! But doing all of these steps means your pull request is most likely to be merged right away.</p> <p>The sections below go in to more detail on each of these steps.</p>"},{"location":"about/contributing/#c-implementation","title":"C++ implementation","text":"<p>C++ vs. Python contributions</p> <p>Polyscope is implemented as a C++ library, with a thin binding layer to Python.</p> <p>All functionality is implemented on the C++ side\u2014pull requests which implement new features solely on the Python side or using external Python dependencies generally will not be accepted. Please file an issue asking first if you are unsure! Of course, bugfixes and additions to the Python binding layer itself are an exception.</p> <p>Conversely, any new C++ features are strongly encouraged to add corresponding Python bindings! See below.</p> <p>A few general pointers:</p> <ul> <li> <p>The UI (menus, dialogs, buttons, etc) is managed using Dear ImGUI, which is very well-documented and has many resources available online.</p> </li> <li> <p>Core rendering logic and shaders are implemented in the <code>/render</code> subdirectory, particularly <code>engine.h</code>. The engine is written to abstract over rendering backends, but at the moment only openGL is supported. There is also a \u201cmock\u201d backend for testing; new rendering features should be mirrored in both <code>gl_engine.cpp</code> and <code>mock_gl_engine.cpp</code>.</p> </li> <li> <p>Polyscope shaders use a custom in-house shader builder, which performs string manipulation with a simple substitution language to build shaders at runtime which support optional features like slice planes, transparency, different quantity visualization policies, etc. The shaders themselves also explicitly track some metadata like what attributes and uniforms they require. Examples of base shaders can be found e.g. here, and substitution rules here. For any shader or rule to be available in Polyscope, it must be registered in <code>GLEngine::populateDefaultShadersAndRules()</code>, and also in the corresponding function of the mock engine for testing.</p> </li> <li> <p>If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See here for an example. Generally, this means functions which take user data should be templated, and the input then passed through <code>standardizeArray&lt;&gt;()</code> or <code>standardizeVectorArray&lt;&gt;()</code>, etc.</p> </li> <li> <p>If adding new options or parameters to a structure/quantity. Be sure to follow proper encapsulation principles (create getters &amp; setters), and use a persistent values. Check out <code>PointCloud::pointColor</code> for a good basic example.  Also, all length-valued quantities should use scaled values (as in <code>PointCloud::pointRadius</code>).</p> </li> </ul>"},{"location":"about/contributing/#unit-testing","title":"Unit testing","text":"<p>Whenever possible, add a unit test that somehow exercises any new functionality or verifies that the bug has been fixed.  Polyscope uses the googletest testing framework. See documentation there for test macros, executable options, etc.</p> <p>In a perfect world, we would actually test that the rendered output from Polyscope is pixel-perfect. However, this is hard for a lot of reasons, so instead most of our tests are just \u201csmoke tests\u201d that call functions with some dummy data and ensure no errors are thrown.</p> <p>In fact, these tests are often run on headless servers, where we cannot even initialize an openGL environment. For this reason, in addition to the usual <code>openGL</code> backend, we also have an <code>openGL_mock</code> backend (implemented here) for testing on headless servers. This backend cannot actually render anything, but still performs many rendering-related sanity checks.  If making changes to the rendering engine &amp; shaders, you may find that changes need to be mirrored in <code>mock_gl_engine.cpp</code>.</p> <p>To run unit tests locally on your own machine (here, via unix terminal commands), use</p> <pre><code>cd test\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake -j4 \n./bin/polyscope-test backend=openGL3_glfw\n</code></pre> <p>which should create a window onscreen and run tests for a few seconds.</p> <p>Additionally, run the tests again like</p> <pre><code>./bin/polyscope-test </code></pre> <p>which will use the <code>openGL_mock</code> backend (you will not see anything onscreen). This is how testing will be performed on the headless CI servers. If both sets of tests pass without errors, you are good to go.</p>"},{"location":"about/contributing/#prs-automated-tests","title":"PRs &amp; automated tests","text":"<p>Once your feature seems ready and unit tests are passing, submit a pull request to the main repository. This will trigger continuous integration (CI) tests via Github Actions to automatically compile the code on a collection of windows/mac/linux machines with various compilers, and verify that tests pass. If there are any issues, a failed \u201ccheck\u201d will show on the pull request page which you can click to learn more.</p> <p>If this is your first contribution to Polyscope, a maintainer will need to manually approve the CI run (this is a github restriction).</p> <p>You are welcome to reach out in the PR chat to sort out any problems. We may request changes! If a PR ever goes more than a few days without a response feel free to ping @nmwsharp.</p>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is hosted in its own separate repository. Polyscope docs use the mkdocs documentation engine, with the mkdocs-material theme (this theme is quite large and adds significant functionality beyond base mkdocs). The documentation is written in a large collection of markdown files; it is not automatically scraped from the code, or code comments, etc, so we must manually keep it up to date.</p> <p>There are two duplicate copies of all the docs for C++ and Python, stored in parallel directories <code>/cpp</code> and <code>/py</code>. A few shared files and assets are stored in the <code>/shared</code> directory, or symlinked from the <code>/py</code> subdirectory to point to a file the <code>/cpp</code> directory. We try to keep these two parallel versions in sync as much as possible, only differing where necessary between C++ and Python.</p> <p>To preview the documentation while editing, first install the necessary packages with <code>pip install mkdocs mkdocs-material==6.2.8 mkdocs-macros-plugin pygments</code>. Then run <code>python3 -m mkdocs serve</code> (run this command from the <code>/cpp</code> directory to view C++ docs, and likewise for <code>/py</code>). A local address will be printed to your terminal, which you can navigate to in-browser to see the docs.</p> <p>Hopefully editing the docs markdown files should be self-evident, you can mainly copy existing content &amp; formatting. Any new files need to be added the manifests in <code>mkdocs.yml</code>.  Don\u2019t forget to add a blurb to the release notes! </p> <p>If you are not able to build the docs for any reason, it is fine to just edit the markdown files and submit a docs PR with that.</p> <p>To actually update the hosted documentation files online at polyscope.run, the documentation site needs to be recompiled and committed to the to the <code>/docs</code> subdirectory. The <code>build_commit_push.sh</code> script can handle this for you, rebuilding both C++ &amp; Python docs and committing the result to the <code>/docs</code> subdirectory:</p> <pre><code>sh build_commit_push.sh\n</code></pre> <p>If you include these built docs changes in your PR, the webpage will automatically update when it is merged. Otherwise the maintainers (usually @nmwsharp) will need to run this command and commit the update after accepting your PR.</p>"},{"location":"about/contributing/#python-bindings","title":"Python bindings","text":"<p>Python bindings for Polyscope are stored in their own separate repository. We use pybind11 to generate bindings. These bindings are kept as thin wrappers as much as possible, just doing a minimal translation between the C++ interface and typical Python calling conventions.</p> <p>The bindings are actually managed internally as two separate Python packages: <code>polyscope_bindings</code> (which contains the raw bindings generated by our pybind11 code), and the higher-level <code>polyscope</code> (which contains the actual, nice user-facing Python functions). The separation is because there is no way to write additional Python code in the pybind11-generated package, but we often want to do some translation and error checking on the Python side before invoking the bindings. As such, adding a binding generally means writing code in two places:</p> <ol> <li>Add a new pybind11 C++ binding, like those here</li> <li>Add a new Python wrapper function which calls the generated binding, like the ones here</li> </ol> <p>Note that a few stylistic conventions between Python and C++. In particular, we do not expose classes for quantities, but set options via optional keyword arguments when the quantity is added. The pybind11 C++ bindings take Eigen arrays as arguments, because pybind11 performs automatic translation between Eigen/numpy.</p> <p>Python binding unit tests are stored in <code>/test/polyscope_test.py</code>. As with C++, these are mainly just simple \u201csmoke tests\u201d which call the functions with dummy data and ensure no errors are thrown. All new bindings functions need a test! To build and test the bindings, first compile the bindings from the <code>polyscope-py</code> root directory like <pre><code>mkdir build\ncd build\ncmake ..\nmake -j8\n</code></pre> the run <code>python polyscope_test.py</code>. As you write code, these bindings must be recompiled to reflect any changes to the pybind11 C++. When testing, make sure there is not another copy of Polyscope for Python installed in your system, which might unintentionally be used instead of the development version! Also, the adjacent <code>demo_app.py</code> can be used for simple testing.</p> <p>Don\u2019t forget, the Python bindings have a parallel set of docs in the <code>/py</code> directory. Updates to Python should be reflected there.</p> <p>When all your tests are passing, create a pull request! As with C++, submitting a pull request to the Python bindings will trigger a cloud build and some automated checks.</p> <p>Actually deploying a new Python version to <code>pip</code> and <code>conda</code> package managers is a somewhat significant process, so we typically group together updates before cutting a new version.  Ping @nmwsharp to get a new version deployed.  Major and minor versions of the Python library are kept in-sync with the C++ library versions, whereas patch versions (<code>1.2.4</code> \u2013&gt; <code>1.2.5</code>) are used for new updates to the Python bindings only.</p>"},{"location":"about/dependencies/","title":"Dependencies","text":"<p>Polyscope stands on the shoulders of many outstanding open-source projects. These dependencies are all permissively licensed, and bundled with the project; we just list them here to give due credit!</p> Name Purpose Link GLFW Window and input management with openGL glfw.org Dear ImGui GUI interface (buttons, text boxes, etc) github.com/ocornut/imgui glad OpenGL loader (used on Windows/Linux) github.com/Dav1dde/glad glm Vector math and glsl utilities glm.g-truc.net stb Header-only libraries, esp. image loading github.com/nothings/stb json Read/write json text github.com/nlohmann/json MC.h adapted for marching cubes github.com/aparis69/MarchingCubeCpp mkdocs Doc generation mkdocs.org mkdocs-material Doc generation squidfunk.github.io/mkdocs-material/ googletest Unit testing github.com/google/googletest pybind11 (Python only) Python bindings github.com/pybind/pybind11 Eigen (Python only) numpy interop for bindings eigen.tuxfamily.org <p>Additionally, Polyscope includes a few public-domain / permissively licensed assets. Some of the built-in matcaps are from the Blender project, and others were rendered using Blender.  The built-in colormaps come from several sources as detailed on the colormap page, including Smith et. al., cmocean, and matplotlib.  The concrete texture on the ground is from cc0textures.com. Thank you, artists!</p>"},{"location":"about/license/","title":"License","text":"<p>Polyscope is released under an MIT license, and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain).</p> <p>Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works.</p> <pre><code>@misc{polyscope,\ntitle = {Polyscope},\nauthor = {Nicholas Sharp and others},\nnote = {www.polyscope.run},\nyear = {2019}\n}\n</code></pre>"},{"location":"about/release_notes/","title":"Release Notes","text":"<p>See github releases: github.com/nmwsharp/polyscope/releases</p>"},{"location":"basics/camera_controls/","title":"Camera Controls & Parameters","text":"<p>These settings affect the 3D camera view in polyscope. It is often convenient to set them just before calling <code>polyscope::init</code>, but they may set be anywhere.</p> <pre><code>#include \"polyscope/polyscope.h\"\n\n// a few camera options\npolyscope::view::setUpDir(polyscope::UpDir::ZUp);\npolyscope::view::setFrontDir(polyscope::FrontDir::NegYFront);\npolyscope::view::setNavigateStyle(polyscope::NavigateStyle::Free);\n\n// initialize\npolyscope::init();\n\n// set the camera pose explicitly\npolyscope::view::lookAt(glm::vec3{10., 10., 0.}, glm::vec3{0., 2., 0.});\n\n// show the GUI\npolyscope::show();\n</code></pre>"},{"location":"basics/camera_controls/#view-options","title":"View options","text":"<code>void view::setNavigateStyle(NavigateStyle newStyle)</code> <code>NavigateStyle view::getNavigateStyle()</code> <p>Get the current navigation style (see explanation in the setter above)</p> <code>void view::setUpDir(UpDir newDir)</code> <code>UpDir view::getUpDir()</code> <p>Get the current up direction (see explanation in the setter above).</p> <code>void view::setFrontDir(FrontDir newDir)</code> <code>FrontDir view::getFrontDir()</code> <p>Get the current front direction (see explanation in the setter above).</p> <code>void lookAt(glm::vec3 cameraLocation, glm::vec3 target, bool flyTo = false)</code> <code>void lookAt(glm::vec3 cameraLocation, glm::vec3 target, glm::vec3 upDir, bool flyTo = false)</code> <p>Set the camera to be located at the 3D position <code>cameraLocation</code> and looking at the 3D position <code>target</code>, oriented with the up direction <code>upDir</code>, all in world coordinates. If <code>flyTo=true</code>, the camera will smoothly animate to the new configuration.</p> <p>Note that setting the up direction for the camera view with this function is separate from the scene\u2019s <code>view::upDir</code> parameter, which affects things like ground plane placement, and manual view manipulation.</p> <p>Example: <pre><code>polyscope::view::lookAt(glm::vec3{10., 10., 0.}, glm::vec3{0., 2., 0.}, glm::vec3{0., 0., 1.});\n</code></pre></p> <code>void resetCameraToHomeView()</code>"},{"location":"basics/camera_controls/#navigation-style","title":"navigation style","text":"<p>The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the enum <code>view::NavigateStyle</code> contains various settings:</p> <ul> <li><code>NavigateStyle::Turntable</code> The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions.</li> <li><code>NavigateStyle::Free</code> The camera is free to take any orientation, rotation is always about relative to the current camera.</li> <li><code>NavigateStyle::Planar</code> The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data).</li> </ul> <p>Example: <pre><code>polyscope::view::setNavigateStyle(NavigateStyle::Free);\n</code></pre></p>"},{"location":"basics/camera_controls/#up-direction","title":"up direction","text":"<p>Set the default \u201cup\u201d direction for the scene. This setting affects default orientation of the view, the behavior of some navigation styles (esp. <code>Turntable</code>), and the orientation of the ground plane.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the enum <code>view::UpDir</code> contains various settings:</p> <ul> <li><code>UpDir::XUp</code> The positive X-axis is up.</li> <li><code>UpDir::NegXUp</code> The negative X-axis is up.</li> <li><code>UpDir::YUp</code> The positive Y-axis is up.</li> <li><code>UpDir::NegYUp</code> The negative Y-axis is up.</li> <li><code>UpDir::ZUp</code> The positive Z-axis is up.</li> <li><code>UpDir::NegZUp</code> The negative Z-axis is up.</li> </ul> <p>Default: <code>UpDir::Yup</code>.</p> <p>Example: <pre><code>polyscope::view::setUpDir(UpDir::ZUp);\n</code></pre></p>"},{"location":"basics/camera_controls/#front-direction","title":"front direction","text":"<p>Set the default \u201cfront\u201d direction for the scene. This setting affects default orientation of the view; the starting camera looks at the front of the data.</p> <p>This value is interpeted as if the scene were a cube, and you are specifying which face of the cube is the \u2018front\u2019. So <code>ZFront</code> means the +Z face of the cube is the front face, and thus our camera initially points down the -Z axis to look at it.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the enum <code>view::FrontDir</code> contains various settings:</p> <ul> <li><code>FrontDir::XFront</code> The positive X-axis is the front.</li> <li><code>FrontDir::NegXFront</code> The negative X-axis is the front.</li> <li><code>FrontDir::YFront</code> The positive Y-axis is the front.</li> <li><code>FrontDir::NegYFront</code> The negative Y-axis is the front.</li> <li><code>FrontDir::ZFront</code> The positive Z-axis is the front.</li> <li><code>FrontDir::NegZFront</code> The negative Z-axis is the front.</li> </ul> <p>Default: <code>FrontDir::ZFront</code>.</p> <p>Example: <pre><code>polyscope::view::setFrontDir(FrontDir::NegYFront);\n</code></pre></p>"},{"location":"basics/camera_controls/#look-at","title":"look at","text":"<p>Set the camera to be located at the 3D position <code>cameraLocation</code> and looking at the 3D position <code>target</code>, both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If <code>flyTo=true</code>, the camera will smoothly animate to the new configuration.</p> <p>Example: <pre><code>polyscope::view::lookAt(glm::vec3{10., 10., 0.}, glm::vec3{0., 2., 0.});\n</code></pre></p>"},{"location":"basics/camera_controls/#reset-camera-to-home-view","title":"reset camera to home view","text":"<p>Reset the camera view to the home view (a reasonable default view scaled to the scene).</p> <p>Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data.</p> <p>Example: <pre><code>polyscope::view::resetCameraToHomeView();\n</code></pre></p>"},{"location":"basics/camera_controls/#orthographic-view","title":"Orthographic view","text":"<p>By default, Polyscope\u2019s view uses perspective projection. Perspective projections roughly correspond to how images are usually perceived by our eyes and cameras.</p> <p>Alternately orthographic projection is also supported. Orthographic projections are common in engineering and architecture, because they have the property that distances are preserved in the projected image, regardless of whether the object is near or far from the camera.</p> <p></p> <p>In perspective mode, zooming (for instance, by manually scrolling the mouse) translates the camera forward in space. In orthographic mode, it instead adjusts the field of view without moving the camera. This is because counter-intuitively, translating the camera forward does not actually change the view in an orthographic projection!</p> <code>ProjectionMode view::projectionMode</code>"},{"location":"basics/camera_controls/#set-projection-mode","title":"set projection mode","text":"<p>Set the camera view projection to be either orthographic or perspective (default).</p> <p>Example: <pre><code>// Enable the orthographic view\npolyscope::view::projectionMode = polyscope::ProjectionMode::Orthographic;\n\n// Go back to default perspective projection\npolyscope::view::projectionMode = polyscope::ProjectionMode::Perspective;\n</code></pre></p>"},{"location":"basics/camera_controls/#savingrestoring-views","title":"Saving/restoring views","text":"<p>The current camera view (location, direction, camera parameters, and window size) can be saved or loaded from a json string. This is useful for quickly setting up repeatable visualizations.</p> <p>Also, in the Polyscope GUI, this string can be copied to the clipboard at any time via the \u201ccopy\u201d hotkey (ctrl-C or cmd-C), or loaded from your current clipboard using the \u201cpaste\u201d hotkey (ctrl-V or cmd-V).</p> <code>std::string getViewAsJson()</code> <p>Get the current view parameters specified as a json string.</p> <p>Example: <pre><code>std::string myString = polyscope::view::getViewAsJson();\n</code></pre></p> <code>void setViewFromJson(std::string jsonString, bool animateFlight=false)</code> <p>Set the current view to match the parameters specified in the json string.</p> <p>Example: <pre><code>polyscope::view::setViewFromJson(myString);\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-parameters","title":"Camera Parameters","text":"<p><code>CameraParameters</code> objects describe a camera view in Polyscope, including its intrinsics (the field of view and aspect ratio), and extrinsics (the location and orientation). These parameters are used both for manipulations of the interactive viewport, as well as creating Camera View structures which are visualized as part of the content in your scene.</p> <p>Example: <pre><code>// construct camera parameters \npolyscope::CameraParameters params(\npolyscope::CameraIntrinsics::fromFoVDegVerticalAndAspect(60, 2.),\npolyscope::CameraExtrinsics::fromVectors(\nglm::vec3{2., 2., 2.},      // world-space position\nglm::vec3{-1., 0., 0.},     // world-space look direction\nglm::vec3{0., 1., 0.}       // world-space up direction\n)\n);\n\n// set the viewport view to those parameters\npolyscope::view::setViewToCamera(params);\n\n// or, use the parameters to create a camera view\npolyscope::CameraView* cam = polyscope::registerCameraView(\"cam1\", params);\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-intrinsics","title":"Camera Intrinsics","text":"<p>A <code>CameraIntrinsics</code> object describes the field of view and aspect ratio of a camera. It does not describe a \u201cpixel resolution\u201d for a camera\u2014you could have many images of different resolutions all associated with the same camera, as long as the aspect ratios are right.</p> <p>Camera intrinsics can be created by specifying any pair of vertical field of view, horizontal field of view, and aspect ratio.</p> <code>static CameraIntrinsics CameraIntrinsics::fromFoVDegVerticalAndAspect(const float&amp; fovVertDeg, const float&amp; aspectRatioWidthOverHeight)</code> <p>Construct camera intrinsics.</p> <ul> <li><code>fovVertDeg</code> vertical field of view in degrees</li> <li><code>aspectRatioWidthOverHeight</code> aspect ratio, as <code>width / height</code></li> </ul> <p>This is a static named constructor. Call it like <pre><code>CameraIntrinsics camInt = CameraIntrinsics::fromFoVDegVerticalAndAspect(20., 2.);\n</code></pre></p> <code>static CameraIntrinsics CameraIntrinsics::fromFoVDegHorizontalAndAspect(const float&amp; fovHorzDeg, const float&amp; aspectRatioWidthOverHeight)</code> <p>Construct camera intrinsics.</p> <ul> <li><code>fovHorzDeg</code> horizontal field of view in degrees</li> <li><code>aspectRatioWidthOverHeight</code> aspect ratio, as <code>width / height</code></li> </ul> <p>This is a static named constructor. Call it like <pre><code>CameraIntrinsics camInt = CameraIntrinsics::fromFoVDegHorizontalAndAspect(20., 2.);\n</code></pre></p> <code>static CameraIntrinsics CameraIntrinsics::fromFoVDegHorizontalAndVertical(const float&amp; fovHorzDeg, const float&amp; fovVertDeg)</code> <p>Construct camera intrinsics.</p> <ul> <li><code>fovHorzDeg</code> horizontal field of view in degrees</li> <li><code>fovVertDeg</code> vertical field of view in degrees</li> </ul> <p>This is a static named constructor. Call it like <pre><code>CameraIntrinsics camInt = CameraIntrinsics::fromFoVDegHorizontalAndVertical(20., 30.);\n</code></pre></p> <p>Various getters access the properties of an intrinsics object: <pre><code>float CameraIntrinsics::getFoVVerticalDegrees()             // vertical FoV\nfloat CameraIntrinsics::getAspectRatioWidthOverHeight()     // horizontal FoV\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-extrinsics","title":"Camera Extrinsics","text":"<p>A <code>CameraExtrinsics</code> object describes the location and orientation of a camera. It can be defined by the forward/up/right axes of the camera in world coordinates, or via an extrinsic matrix, typically denoted <code>E</code>, which maps points in world coordinates to points in the camera\u2019s local coordinate system. Polyscope uses openGL conventions for camera space, such that the camera points toward the -Z axis, with +Y pointing up and +X pointing right.</p> <p>Camera extrinsics can be created by specifying frame axes or an extrinsic matrix.</p> <code>static CameraExtrinsics CameraExtrinsics::fromVectors(const T1&amp; root, const T2&amp; lookDir, const T3&amp; upDir)</code> <p>Construct camera extrinsics.</p> <ul> <li><code>root</code> the world-space position of the camera</li> <li><code>lookDir</code> a world-space unit vector along which the camera looks</li> <li><code>upDir</code> a world-space unit vector defining the up axis for the camera</li> </ul> <p>These are all 3D vectors, and can be any type which is accessible via Polyscope\u2019s data adaptors.</p> <p>This is a static named constructor. Call it like <pre><code>CameraExtrinsics camExt = CameraExtrinsics::fromVectors(rootVec, lookDir, upDir);\n</code></pre></p> <code>static CameraExtrinsics CameraExtrinsics::fromMatrix(const glm::mat4&amp; E)</code> <p>Construct camera extrinsics.</p> <ul> <li><code>E</code> is a 4x4 matrix mapping points in world-space to local camera space. Polyscope\u2019s camera space uses openGL convention.</li> </ul> <p>This is a static named constructor. Call it like <pre><code>CameraExtrinsics camExt = CameraExtrinsics::fromMatrix(E_mat);\n</code></pre></p> <p>Various getters access the properties of an extrinsics object: <pre><code>glm::vec3       CameraExtrinsics::getT()\nglm::mat3x3     CameraExtrinsics::getR()\nglm::mat4x4     CameraExtrinsics::getViewMat() // synonym for getE()\nglm::mat4x4     CameraExtrinsics::getE()\nglm::vec3       CameraExtrinsics::getPosition()\nglm::vec3       CameraExtrinsics::getLookDir()\nglm::vec3       CameraExtrinsics::getUpDir()\nglm::vec3       CameraExtrinsics::getRightDir()\nstd::tuple&lt;glm::vec3, glm::vec3, glm::vec3&gt; CameraExtrinsics::getCameraFrame() // &lt;look, up, right&gt; world-space vectors\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-parameters_1","title":"Camera Parameters","text":"<p>The <code>CameraParameters</code> object combines a set of intrinsics and extrinsics to fully define a camera.</p> <code>CameraParameters(const CameraIntrinsics&amp; intrinsics, const CameraExtrinsics&amp; extrinsics)</code> <p>Construct camera parameters from intrinsics and extrinsics.</p> <p>This is a plain old constructor. Call it like <pre><code>CameraExtrinsics camExt = CameraExtrinsics::fromMatrix(E_mat);\nCameraIntrinsics camInt = CameraIntrinsics::fromFoVDegHorizontalAndVertical(20., 30.);\nCameraParameters camParam(camInt, camExt);\n</code></pre></p> <p>Various getters access the properties of the parameters object. All getters for the intrinsics and extrinsics are also forwarded to the combined parameters class. <pre><code>// intrinsics\nfloat CameraParameters::getFoVVerticalDegrees()             // vertical FoV\nfloat CameraParameters::getAspectRatioWidthOverHeight()     // horizontal FoV\n\n// extrinsics\nglm::vec3       CameraParameters::getT()\nglm::mat3x3     CameraParameters::getR()\nglm::mat4x4     CameraParameters::getViewMat() // synonym for getE()\nglm::mat4x4     CameraParameters::getE()\nglm::vec3       CameraParameters::getPosition()\nglm::vec3       CameraParameters::getLookDir()\nglm::vec3       CameraParameters::getUpDir()\nglm::vec3       CameraParameters::getRightDir()\nstd::tuple&lt;glm::vec3, glm::vec3, glm::vec3&gt; CameraParameters::getCameraFrame() // &lt;look, up, right&gt; world-space vectors\n</code></pre></p>"},{"location":"basics/camera_controls/#generating-pixel-rays","title":"Generating pixel rays","text":"<p>It is often necessary to generate the world-space ray corresponding to each pixel of an image in a camera view. The base point for these rays is easy, it is just <code>params.getPosition()</code>. However the ray directions vary-per pixel; the <code>CameraParameters</code> object has two helpers to automatically construct these rays.</p> <code>std::vector&lt;glm::vec3&gt; CameraParameters::generateCameraRays(size_t w, size_t h, ImageOrigin origin = ImageOrigin::UpperLeft)</code> <p>Fill a buffer with rays corresponding to an image with the given resolution. The result is a <code>w*h</code>-length buffer, flattened such that each row is stored contiguously. Ray origins are all implicitly given by <code>this-&gt;getPosition()</code>.</p> <code>std::array&lt;glm::vec3, 4&gt; CameraParameters::generateCameraRayCorners()</code> <p>Generate the rays corresponding to the [upperleft, upperright, lowerleft, lowerright] corners of the camera\u2019s view. </p> <p>This method is useful because the caller can easily linearly interpolate the normalize get ray directions for all pixels in an image, but this method just needs to return a small amount of data. This makes it easy to e.g. generate rays for a real-time renderer on a GPU, without transferring a whole buffer of ray directions for each frame.</p>"},{"location":"basics/flow/","title":"Basic Flow","text":"<p>This page describes the basic control flow to initialize Polyscope and invoke it from you program. See the structures and quantities sections on the left for the various kinds of data you can add to Polyscope.</p> <p>Polyscope needs to be initialized exactly once by calling <code>init()</code>, typically near the beginning of your program. You can then register structures to the scene, and show the window using either of two methods.</p>"},{"location":"basics/flow/#program-structure","title":"Program Structure","text":"<p>There are two separate ways to structure your program\u2019s control flow with polyscope.</p> <p>Option 1: show() The simpler, and more-common approach is to call <code>show()</code>, which will run Polyscope\u2019s window continuously. The <code>show()</code> function will not return until the window is closed. If you want to execute your own code while the Polyscope window is active, you must do so via the <code>userCallback</code>.</p> <pre><code>#include \"polyscope/polyscope.h\"\npolyscope::init();\n\n/* \n * ... your code ...\n * ... add visualizations to Polyscope, etc ...\n */\n\n// if desired, set up a userCallback to execute your code each\n// frame and add ImGui UI elements\n\npolyscope::show(); // shows the UI, blocks until the UI exits\n\n// If desired, add more visualizations, then show the UI again.\n// Data is preserved between calls to show() unless explicitly removed.\n// ... your code ...\npolyscope::show();\n</code></pre> <p>Option 2: frameTick() An alternate approach is to manually call <code>frameTick()</code> in a tight loop to run the UI. This is useful to quickly integrate Polyscope into existing programs which already have a main loop. The <code>userCallback</code> is still necessary to add ImGui UI elements.</p> <pre><code>#include \"polyscope/polyscope.h\"\npolyscope::init();\n\n// if desired, set up a userCallback to add ImGui UI elements\n\nwhile (!polyscope::windowRequestsClose()) { /* program runs */\n/* \n     * ... your code ...\n     * ... add visualizations to Polyscope, etc ...\n     */\n\npolyscope::frameTick(); // renders one UI frame, returns immediately\n}\n</code></pre> <p>Either way, <code>init()</code> must be called before you do anything with Polyscope.</p> <p>Where to make ImGui calls</p> <p>Polyscope includes ImGui, allowing you to build custom UI elements like buttons and fields. </p> <p>Regardless of which control flow method you use, ImGui calls can only be make within the <code>userCallback</code> function. Making ImGui calls elsewhere will lead to errors and crashes.</p>"},{"location":"basics/flow/#functions","title":"Functions","text":"<p><code>#include \"polyscope/polyscope.h\"</code></p> <code>init(std::string backend=\"\")</code> <code>show()</code> <code>unshow()</code> <code>frameTick()</code> <code>bool windowRequestsClose()</code>"},{"location":"basics/flow/#init","title":"init()","text":"<p>Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization.</p> <p>Performs one-time work like setting up openGL and creating a window.</p> <p><code>backend</code> is an optional specifier for which rendering backend to use, passing <code>\"\"</code> selects a reasonable default backend. Generally, you should not need to manually set the backend.</p>"},{"location":"basics/flow/#show","title":"show()","text":"<p>Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.</p> <p>This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to <code>frameTick()</code> and <code>show()</code>.</p> <p>You can even nest calls to <code>show()</code>\u2014for instance, if the user clicks a button in your callback which executes some function, you can invoke <code>show()</code> again within that function for immediate debugging. Closing the nested window will then \u201cpop back\u201d to continue displaying the previously shown GUI.</p> <p>If desired, register a <code>userCallback</code> which will be internally executed by Polyscope within each frame, you may not make ImGui calls arbitrarily throughout your code.</p> <p>Several options are available which affect the behavior of <code>show()</code>, such as whether the window is automatically brought to the front and given focus. See the options listing for details.</p>"},{"location":"basics/flow/#unshow","title":"unshow()","text":"<p>The opposite of <code>show()</code>. If <code>show()</code> is currently active, this closes the window and causes the call to <code>show()</code> to return. This is equivalent to manually closing the Polyscope window by clicking the window manager\u2019s close button.</p> <p>Generally it is not necessary to call this function; the user can exit by closing the window. However, <code>unshow()</code> may be useful to programmatically close the window when a condition is met, or via a custom ImGui element.</p> <p><code>unshow()</code> does not deinitialize Polyscope. You can still call <code>show()</code> again after.</p>"},{"location":"basics/flow/#frametick","title":"frameTick()","text":"<p>Render one frame of the polyscope UI. This function needs to be called in a tight loop by your code, like:</p> <pre><code>polyscope::init();\n\nwhile(/* program runs */) {\n\n/* \n     * ... your code ...\n     */\n\npolyscope::frameTick();\n}\n</code></pre> <p>If <code>frameTick()</code> is not called often enough, the interface will be unresponsive.</p> <p>This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed.  Existing data will be preserved between calls to <code>frameTick()</code> and <code>show()</code>.</p> <p>If any ImGui UI elements are to be created, they must be created inside of a <code>userCallback()</code> (which will be internally executed by Polyscope within each <code>frameTick()</code>, you may not make ImGui calls arbitrarily throughout your code.</p> <p>The <code>frameTick()</code> function can be called anywhere within your program\u2019s control flow, including from multiple call sites. You may also interleave or nest calls to <code>frameTick()</code> and <code>show()</code> to use both kinds of control flow within a program.</p>"},{"location":"basics/flow/#windowrequestsclose","title":"windowRequestsClose()","text":"<p>Returns <code>true</code> if the user has tried to exit the window at the OS level, e.g. by clicking the close button. </p> <p>Useful for deciding when to exit your control loop when using <code>frameTick()</code>.</p>"},{"location":"basics/parameters/","title":"Parameters","text":"<p>Many structures and quantities in Polyscope have optional values which can be set to control their appearance or behavior, such as the radius of points in a point cloud or the color of a mesh. These values can generally be manually adjusted in the GUI, or set programmatically in code.</p> <p>This page documents special features in Polyscope which provide extra functionality while setting these parameters.</p>"},{"location":"basics/parameters/#persistent-values","title":"Persistent values","text":"<p>In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values.</p> <p>Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match.</p> <p>Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. <pre><code>PointCloud* psCloud = polyscope::getPointCloud(\"my cloud\");\npsCloud-&gt;setPointColor(glm::vec3(0.5, 0.5, 0.5));  // the persistent value is recorded in the cache\n\n// ... later ...\n\nPointCloud* newCloud = polyscope::registerPointCloud(\"my cloud\", new_points);\n// newCloud will automatically pick up the pointColor we set above, \n// since this point cloud has the same name\n</code></pre> Note that this persistence behavior applies even when variables are manually manipulated in the GUI.</p> for implementors <p>If writing custom Polyscope library code (e.g. your own custom structures and quantities), here\u2019s what you need to know to use persistent values.</p> <p>The class <code>PersistentValue&lt;T&gt;</code> is templated on the underlying scalar type, like <code>PersistentValue&lt;double&gt;</code>. Only a predefined set of types can be used as template arguments because the corresponding global cache must be allocated. See <code>persistent_value.h</code> for a listing, which currently includes <code>bool</code>, <code>float</code>, <code>double</code>, <code>ScaledValue&lt;float&gt;</code>, <code>ScaledValue&lt;double&gt;</code>, <code>glm::vec3</code>, and <code>std::string</code>.</p> <p>Construct a persistent value like <pre><code>PersistentValue&lt;float&gt; myVar(\"unique_name\", 0.5)\n</code></pre> the variable will the cached value if one exists, and if not take the value <code>0.5</code> (and add it to the cache).  Remember to use a globally unique name for the for the name argument; in structures you can use a concatenation of the type name, structure name, and (if applicable) quantity name.</p> <p>To access a persistent value, call <code>myVar.get()</code>, which returns a reference to the underlying value.</p> <p>In some occasions, in particular when using ImGui, you may need to write to a value directly via the pointer from <code>&amp;myVar.get()</code>. This is problematic, because the variable does not know it has been written to and thus needs to update the cache. The function <code>myVar.manuallyUpdated()</code> can be called to notify the persistent value that it needs to update the cache. The paradigm for using a persistent value with ImGui then looks like <pre><code>if (ImGui::SliderFloat(\"some text\", &amp;myVar.get())) {\nmyVar.manuallyChanged();\n}\n</code></pre></p>"},{"location":"basics/parameters/#scaled-values","title":"Scaled values","text":"<p>Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. The <code>ScaledValue</code> type tracks such represents such values, if we set <code>ScaledValue s = 7.</code>, then <code>s.asAbsolute()</code> will return <code>7. * state::lengthScale</code> when used. Most length-valued parameters in Polyscope use this mechanism, and thus are relative by default.</p> <pre><code>using namespace polyscope;\nPointCloud* psCloud = polyscope::getPointCloud(\"my cloud\");\n\n// radius will be 0.05 * lengthScale when used\npsCloud-&gt;pointRadius = ScaledValue&lt;double&gt;::relative(0.05); psCloud-&gt;pointRadius = relativeValue(0.05); // shorthand, same as previous\npsCloud-&gt;pointRadius = 0.05; // shorthand, same as previous\n</code></pre> <p>However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use.</p> <pre><code>// radius will be 1.6 when used\npsCloud-&gt;pointRadius = ScaledValue&lt;double&gt;::absolute(1.6) psCloud-&gt;pointRadius = absoluteValue(1.6); // shorthand, same as previous\n</code></pre> <p>Note that scaled values can be (and often are) used as persistent values, as described above; the two concepts are complementary. </p> for implementors <p>If writing custom Polyscope library code (e.g. your own custom structures and quantities), here\u2019s what you need to know to use scaled values.</p> <p>The class <code>ScaledValue&lt;T&gt;</code> is templated on the scalar type, which basically just needs to support scalar multiplicaiton.</p> <p>The examples above show how to construct scaled values as relative or absolute.</p> <p>If you want to get the value represented by the <code>ScaledValue</code> as an absolute quantity, use <code>ScaledValue&lt;T&gt;::asAbsolute()</code>, which scales by <code>state::lengthScale</code> if the value is relative.</p> <p>Use <code>ScaledValue&lt;T&gt;::getValuePtr</code> to get a pointer to the underlying <code>T</code>, for instance if using ImGui. A basic ImGui pattern to manipulate the variable looks like: <pre><code>ImGui::SliderFloat(\"value \", value.getValuePtr());\n</code></pre></p> <p>If the value is a persistent scaled value, like <code>PersistentValue&lt;ScaledValue&lt;float&gt;&gt;</code>, it can be used like: <pre><code>// example persistent scaled value\nPersistentValue&lt;ScaledValue&lt;float&gt;&gt;&gt; myVal(\"unique name\", relativeValue(0.03));\n\n// access\nfloat myValInWorldCoords = myVal.get().asAbsolute();\n\n// use with ImGUI\nif (ImGui::SliderFloat(\"my val\", myVal.get().getValuePtr())) {\nmyVal.manuallyChanged();\n}\n</code></pre></p>"},{"location":"basics/program_options/","title":"Program Options","text":"<p>These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling <code>polyscope::init</code>, but they may set be anywhere.</p> <pre><code>#include \"polyscope/polyscope.h\"\n\n// a few options\npolyscope::options::programName = \"important app\";\npolyscope::options::verbosity = 0;\npolyscope::options::usePrefsFile = false;\n\n// initialize\npolyscope::init();\n</code></pre>"},{"location":"basics/program_options/#options","title":"Options","text":"<code>std::string options::programName</code> <code>int options::verbosity</code> <code>std::string options::printPrefix</code> <code>bool options::errorsThrowExceptions</code> <code>bool options::enableRenderErrorChecks</code> <code>int options::ssaaFactor</code> <code>int options::maxFPS</code> <code>bool options::usePrefsFile</code> <code>bool options::alwaysRedraw</code> <code>bool options::buildGui</code> <code>bool options::openImGuiWindowForUserCallback</code> <code>bool options::invokeUserCallbackForNestedShow</code> <code>bool options::giveFocusOnShow</code>"},{"location":"basics/program_options/#program-name","title":"program name","text":"<p>A general name to use when referring to the program in window headings, etc. Default: <code>Polyscope</code>.</p> <p>Example: <pre><code>polyscope::options::programName = \"important app\";\n</code></pre></p>"},{"location":"basics/program_options/#verbosity","title":"verbosity","text":"<p>How much useful info should polyscope print to <code>std::cout</code>? Default: <code>1</code>.</p> <ul> <li><code>0</code> print nothing</li> <li><code>1</code> print occasionally</li> <li><code>&gt;= 2</code> print a lot</li> </ul> <p>Example: <pre><code>polyscope::options::verbosity = 1;\n</code></pre></p>"},{"location":"basics/program_options/#print-prefix","title":"print prefix","text":"<p>A string used as a prefix for all messages printed to the terminal by polyscope.  Default: <code>[polyscope]</code>.</p> <p>Example: <pre><code>polyscope::options::printPrefix = \"[MYAPP] \";\n// prints now look like \"[MYAPP] loaded openGL\"\n</code></pre></p>"},{"location":"basics/program_options/#errors-throw-execptions","title":"errors throw execptions","text":"<p>If true, errors in polyscope throw execptions. If false, a <code>polyscope::error</code> is shown in the UI, but processing attempts to continue. Default: <code>false</code>.</p>"},{"location":"basics/program_options/#render-error-checks","title":"render error checks","text":"<p>If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems.</p> <p>Default: <code>true</code> when compiled in <code>Debug</code> mode, <code>false</code> in <code>Release</code> mode.</p>"},{"location":"basics/program_options/#ssaa-anti-aliasing-factor","title":"SSAA anti-aliasing factor","text":"<p>Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. </p> <p>Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range <code>1</code> to <code>4</code>. Using <code>2</code> is generally sufficient for anti-aliasing.</p> <p>Default: <code>1</code> (no anti-aliasing)</p>"},{"location":"basics/program_options/#max-fps","title":"max fps","text":"<p>The main loop will not run at more than <code>maxFPS</code> iterations per second. <code>-1</code> disables, running the loop as fast as possible. Default: <code>60</code>.</p>"},{"location":"basics/program_options/#use-prefs-file","title":"use prefs file","text":"<p>Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a <code>json</code>-formatted plaintext file called <code>.polyscope.ini</code>.</p> <p>This option controls the use of the preferences file. If <code>false</code>, if will be neither written nor read. Default: <code>true</code>.</p>"},{"location":"basics/program_options/#always-redraw","title":"always redraw","text":"<p>Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities.</p> <p>If this option is <code>true</code>, the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: <code>false</code>.</p>"},{"location":"basics/program_options/#build-gui","title":"build gui","text":"<p>This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope.</p> <p>If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs.</p> <p>If desired, the functions <code>buildStrctureGui()</code>, etc can be manually invoked to build pieces of the UI, but know that these are internal details which may change without warning in future verisons.</p> <p>Default: <code>true</code>.</p>"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","title":"open imgui window for user callback","text":"<p>If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like <code>ImGui::Button(\"do stuff\")</code>. </p> <p>If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any).</p> <p>Default: <code>true</code>.</p>"},{"location":"basics/program_options/#invoke-user-callback-for-nested-show","title":"invoke user callback for nested show","text":"<p>Suppose you call <code>polyscope::show()</code>, and within your callback, another instance of <code>polyscope::show()</code> is called\u2014this is a nested show.</p> <p>Depending on the situation, you might or might not want your <code>userCallback</code> to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option.</p> <p>If true, your callback will be executed as normal for every main loop iteration, even in nested show windows.</p> <p>If false, your callback will only be executed for initial, outermost calls to <code>polyscope::show()</code>.</p> <p>Default: <code>false</code>.</p>"},{"location":"basics/program_options/#give-focus-on-show","title":"give focus on show","text":"<p>If true, the Polyscope window will request focus from the window manager whenever <code>show()</code> is called. If false, the focus state will be left unchanged.</p> <p>Default: <code>false</code>.</p>"},{"location":"basics/scene_options/","title":"Scene Options","text":"<p>These are settings which affect the visual display of the scene. It is often convenient to set them just before calling <code>polyscope::init</code>, but they may set be anywhere.</p> <pre><code>#include \"polyscope/polyscope.h\"\n\n// a few options\npolyscope::options::autocenterStructures = true;\npolyscope::options::autoscaleStructures = true;\n\n// initialize\npolyscope::init();\n</code></pre> <code>bool options::autocenterStructures</code> <code>bool options::autoscaleStructures</code>"},{"location":"basics/scene_options/#autocenter-structures","title":"autocenter structures","text":"<p>If true, all structures will have their transform set to center their bounding box immediately after being registered.</p> <p>This centers the content nicely in view, but obscures any important absolute world positions.</p> <p>Default: <code>false</code>.</p>"},{"location":"basics/scene_options/#autoscale-structures","title":"autoscale structures","text":"<p>If true, all structures will have their transform set to rescale their length to 1 immediately after being registered.</p> <p>This scales the content nicely in view, but obscures any important absolute world positions.</p> <p>Default: <code>false</code>.</p>"},{"location":"basics/scene_options/#extents","title":"Extents","text":"<p>By default, Polyscope computes a bounding box and length scale for the structures in the scene, and uses them to adjust the rendered view. For instance, the camera view is initially pointed at the center of the bounding box, and the length scale is used to set reasonable values for the radii of points, curves, and vectors.</p> <p>However, sometimes it important to fix these extents rather than automatically computing them from data. One such case is producing precisely consistent visualizations across many inputs which might have slightly different extents. Another is when outlier data makes the automatically-computed extents egregiously large. The settings below can be used to manually adjust these extents.</p> <p>These parameters can be adjust in the UI under <code>[View] --&gt; [Scene Extents]</code>.</p> <p>Example:  fix the length scale to the unit bounding box <pre><code>polyscope::init()\npolyscope::options::automaticallyComputeSceneExtents = false;\npolyscope::state::lengthScale = 1.;\npolyscope::state::boundingBox = std::tuple&lt;glm::vec3, glm::vec3&gt;{ {-1., -1., -1.}, {1., 1., 1.} };\n</code></pre></p> <code>float state::lengthScale</code> <p>A representative length scale for the scene. </p> <p>When Polyscope automatically computes this, most structures simply use the length of the diagonal of the bounding box.</p> <code>std::tuple&lt;glm::vec3, glm::vec3&gt; state::boundingBox</code> <p>A bounding box for the scene, in world coordinates. The first and second elements of the tuple are the lower and upper corners of the bounding box, respectively.</p> <code>bool options::automaticallyComputeSceneExtents</code>"},{"location":"basics/scene_options/#automatically-compute-extents","title":"automatically compute extents","text":"<p>If true, the <code>lengthScale</code> and <code>boundingBox</code> parameters will be automatically computed from the registered structures, and updated whenever a a structure is added or changed.</p> <p>If false, these parameters will be left unchanged.  If set to false before the first structure is registered, you are required to set the bounding box and length scale manually.</p> <p>Default: <code>true</code>.</p>"},{"location":"basics/scene_options/#other-options","title":"Other Options","text":"<code>glm::vec4 view::bgColor</code>"},{"location":"basics/scene_options/#background-color","title":"background color","text":"<p>Set the background color of the rendered scne. Values should be RGBA on <code>[0,1]</code>.</p> <p>Default: <code>{1., 1., 1., 1.}</code>.</p>"},{"location":"building/","title":"Building","text":"<p>Polyscope uses CMake to configure its build system. </p>"},{"location":"building/#unix-like-environments-macoslinuxwsl","title":"Unix-like environments (macOS,Linux,WSL)","text":"<p>If you\u2019re using CMake in a Unix-like environment, integrating Polyscope in to your codebase should be as simple as running <pre><code>git clone --recurse-submodules https://github.com/nmwsharp/polyscope.git\n</code></pre> and adding <pre><code>add_subdirectory(\"path/to/polyscope\")\n\n...\n\ntarget_link_libraries(YOUR_TARGET polyscope)\n</code></pre> to your <code>CMakeLists.txt</code>. If you place polyscope outside of your project\u2019s source tree, you may need  <code>add_subdirectory(\"path/to/polyscope\" \"polyscope\")</code> to also set a library build directory.</p> <p>See these repositories for some simple examples of using Polyscope with an existing codebase or library:</p> <ul> <li>with geometry-central \u2013 example project</li> <li>with libIGL \u2013 example project</li> </ul>"},{"location":"building/#building-in-windows","title":"Building in Windows","text":"<p>If you are using Cygwin, WSL, or some other unix-emulation environment on Windows, just follow the Unix instructions above (though be wary that these tools often do not have good openGL and windowing support, which can be a problem at runtime for a graphical application like Polyscope). </p> <p>Additionally, Polyscope builds out of the box on Visual Studio 2019 (earlier versions have not been tested). Simply run CMake (either with the GUI or terminal interface) on Polyscope\u2019s CMakeLists.txt to generate Visual Studio project and solution files. </p> <p>To integrate Polyscope with an existing Visual Studio project:</p> <ul> <li>(if the project uses CMake): add Polyscope to your projects <code>CMakeLists.txt</code> as in the Unix instructions above</li> <li>(otherwise): first generate the Polyscope project with its <code>CMakeLists.txt</code>, then manually add the <code>polyscope</code> project to your existing Visual Studio solution</li> </ul> <p>Polyscope has been verified to compile in Visual Studio 2019 &amp; 2017; other versions should work but have not been tested! Polyscope uses only C++11 language features, but does make advanced use of templates (for instance, SFINAE), which some older versions of MSVC do not fully support.  To test Polyscope on your machine, you can compile the demo app with <code>examples/demo-app/CMakeLists.txt</code>.</p>"},{"location":"building/#dependencies","title":"Dependencies","text":"<p>Polyscope packages all of its source code dependencies with the repository.</p>"},{"location":"building/#ubuntu","title":"Ubuntu","text":"<p>On Ubuntu and friends, you may want to <code>apt-get install xorg-dev libglu1-mesa-dev freeglut3-dev mesa-common-dev</code> to pull graphics and windowing related headers to build.</p>"},{"location":"building/#macos","title":"MacOS","text":"<p>On MacOS it may be necessary to install X11 dependencies, this can be done using Homebrew and xquartz package with the command: <code>brew install --cask xquartz</code>. If you are not using CMake you will need to link against the <code>OpenGL</code>, <code>CoreVideo</code>, <code>Cocoa</code> and <code>IOKit</code> MacOS frameworks explicitly. A sample command to link your application with <code>g++</code> on MacOS is:</p> <pre><code>g++ &lt;object files&gt; -framework OpenGL -framework CoreVideo -framework Cocoa -framework IOKit \\\n-L/opt/X11/lib/ &lt;Other Unix Linking flags (libraries + directories)&gt;\n</code></pre>"},{"location":"building/#backends","title":"Backends","text":"<p>Internally, Polyscope has (very preliminary) support for changing the rendering backend. At compile time, CMake flags control which backends Polyscope will be built with, and at runtime one of the available backends can be selected during <code>init()</code>.</p> <p>Currently, only a single \u201creal\u201d backend is supported. However, an additional \u201cmock\u201d backend enables testing on headless machines.</p> Backend CMake option String name Description OpenGL3 &amp; GLFW <code>POLYSCOPE_BACKEND_OPENGL3_GLFW</code> <code>openGL3_glfw</code> The standard rendering engine for Polyscope mock <code>POLYSCOPE_BACKEND_OPENGL_MOCK</code> <code>openGL_mock</code> Fake backend which stubs out all calls to the rendering engine, but still performs many useful internal checks. <p>By default the CMake script builds all (both) backends. But for instance, the OpenGL3 backend could be excluded from the build with <pre><code>cmake -DPOLYSCOPE_BACKEND_OPENGL3_GLFW=OFF ..\n</code></pre> and the mock backend could be used at runtime with <code>polyscope::init(\"openGL_mock\")</code>.</p>"},{"location":"building/#tests","title":"Tests","text":"<p>Unit test live in the <code>/test/</code> directory, and cover most of the core functionality of Polyscope. Polyscope uses googletest, which will be downloaded automatically when you build the tests.</p> <p>To build and run the tests, use:</p> <p><pre><code>cd test\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake -j4 &amp;&amp; ./bin/polyscope-test --gtest_catch_exceptions=0\n</code></pre> The backend can be set for the test script by passing an additional argument: <pre><code>./bin/polyscope-test --gtest_catch_exceptions=0 backend=openGL_mock\n</code></pre></p>"},{"location":"common/color_quantity/","title":"Color quantity","text":""},{"location":"common/color_quantity/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"common/parameterization_quantity/","title":"Parameterization quantity","text":""},{"location":"common/parameterization_quantity/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>These options and behaviors are available for all types of parameterization quantities on any structure.</p>"},{"location":"common/parameterization_quantity/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>enum class ParamVizStyle</code> has options for how parameterizations are visualized:</p> <ul> <li><code>CHECKER</code>: a two-color checker pattern</li> <li><code>GRID</code>: a grid with thin lines</li> <li><code>LOCAL_CHECK</code>: a checkboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>LOCAL_RAD</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul> <p>The function <code>SurfaceParameterizationQuantity::setStyle(ParamVizStyle newStyle)</code> can be used to programmatically change the style.</p>"},{"location":"common/parameterization_quantity/#types","title":"Types","text":"<p>The <code>enum class ParamCoordsType</code> has options that control how parameter coordinates are interpreted:</p> <ul> <li><code>UNIT</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>WORLD</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul> <p>These enums can be passed as an optional third argument when a parameterization is registered.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes style the visualization style (see above) <code>ParamVizStyle getStyle</code> <code>setStyle(ParamVizStyle style)</code> yes checker colors two colors to use for checkerboards <code>std::pair&lt;glm::vec3,glm::vec3&gt;getCheckerColors()</code> <code>setCheckerColors(std::pair&lt;glm::vec3, glm::vec3&gt; colors)</code> yes grid colors two colors to use for line and background of grid <code>std::pair&lt;glm::vec3,glm::vec3&gt;getGridColors()</code> <code>setGridColors(std::pair&lt;glm::vec3, glm::vec3&gt; colors)</code> yes checker size the width of checkers / stripes, always used as a relative value, unless the coord tpe is <code>UNIT</code> <code>double getCheckerSize()</code> <code>setCheckerSize(double val)</code> yes color map the color map to use for radial displays <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"common/scalar_quantity/","title":"Scalar quantity","text":""},{"location":"common/scalar_quantity/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"common/vector_quantity/","title":"Vector quantity","text":""},{"location":"common/vector_quantity/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>These options and behaviors are available for all types of vector quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes vector radius the radius vectors are drawn with <code>double getVectorRadius()</code> <code>setVectorRadius(double val, bool isRelative=true)</code> yes vector length vectors will be scaled so the longest is this long. ignored if <code>VectorType::Ambient</code> <code>double getVectorLengthScale()</code> <code>setVectorLengthScale(double val, bool isRelative=true)</code> yes vector color the color to draw the vectors with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"features/2D_data/","title":"2D Data","text":"<p>Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so.</p> <p>Example: register a 2D point cloud and add some vectors to it  <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/point_cloud.h\"\n\npolyscope::init();\n\n// Set the camera to 2D mode (see below)\npolyscope::view::style = polyscope::view::NavigateStyle::Planar;\n\n// Build a random point cloud\nsize_t N = 3000;\nstd::vector&lt;glm::vec2&gt; points(N);\nfor (size_t i = 0; i &lt; N; i++) {\npoints.push_back(glm::vec2{polyscope::randomUnit() - .5, polyscope::randomUnit() - .5});\n}\n\n// Register it. Note the \"2D\" in the function call.\npolyscope::registerPointCloud2D(\"flat points\", points);\n\n\n// Build a random vector\nstd::vector&lt;glm::vec2&gt; randVec(N);\nfor (size_t i = 0; i &lt; N; i++) {\nrandVec[i] = glm::vec2{polyscope::randomUnit() - .5, polyscope::randomUnit() - .5};\n}\n\n// Add it to the point cloud. Note the \"2D\" in the function call\npolyscope::getPointCloud(\"flat points\")-&gt;addVectorQuantity2D(\"random vector\", randVec);\n\npolyscope::show();\n</code></pre></p>"},{"location":"features/2D_data/#adding-2d-data","title":"Adding 2D data","text":"<p>Functions which accept 3D positions (or vectors) as input have a variant which takes 2D positions, and appends a 0 z-coordinate.  For instance, <code>registerPointCloud()</code> has a matching <code>registerPointCloud2D()</code>, there\u2019s <code>registerSurfaceMesh2D</code>, etc. Any other functions which don\u2019t take 3D positions can be used as normal, like <code>addScalarQuantity()</code>.</p> <p>Note that you definitely should not just call the normal 3D versions with 2D data. If you\u2019re lucky, it will fail to compile; if you\u2019re unlucky your code may segfault!</p>"},{"location":"features/2D_data/#planar-camera-mode","title":"Planar camera mode","text":"<p>The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to <code>Planar</code>. In the UI, this option is in the main Polyscope window, set to <code>Turntable</code> by default. Setting the camera mode to <code>Planar</code> will also hide the ground plane.</p> <p></p> <p>To set this option programmatically, use: <pre><code>polyscope::view::style = polyscope::view::NavigateStyle::Planar;\n</code></pre></p>"},{"location":"features/callbacks_and_UIs/","title":"Callbacks & Custom UIs","text":""},{"location":"features/callbacks_and_UIs/#intro","title":"Intro","text":"<p>When <code>polyscope::show()</code> has been called, Polyscope will optionally invoke user-supplied callback function as each frame of the interface is redrawn. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc.</p> <p>See Dear ImGui for documentation of UI commands.</p> <code>std::function&lt;void()&gt; polyscope::state::userCallback</code>"},{"location":"features/callbacks_and_UIs/#user-callback","title":"user callback","text":"<p>A function which will be invoked on every main loop iteration by Polyscope, once <code>show()</code> has been called.</p> <p>If null, nothing will be invoked.</p>"},{"location":"features/callbacks_and_UIs/#example","title":"Example","text":"<p>The code below creates the following UI using a callback.</p> <p></p> <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/point_cloud.h\"\n\n// Parameters which we will set in the callback UI.\nint nPts = 2000;\nfloat anotherParam = 3.14;\n\nvoid mySubroutine() {\n\n// do something useful...\n\n// Register a structure\nstd::vector&lt;glm::vec3&gt; points;\nfor (int i = 0; i &lt; nPts; i++) {\npoints.push_back(\nglm::vec3{ polyscope::randomUnit(), polyscope::randomUnit(), polyscope::randomUnit()\n});\n}\npolyscope::registerPointCloud(\"my point cloud\", points);\n}\n\n// Your callback functions\nvoid myCallback() {\n\n// Since options::openImGuiWindowForUserCallback == true by default, \n// we can immediately start using ImGui commands to build a UI\n\nImGui::PushItemWidth(100); // Make ui elements 100 pixels wide,\n// instead of full width. Must have \n// matching PopItemWidth() below.\n\nImGui::InputInt(\"num points\", &amp;nPts);             // set a int variable\nImGui::InputFloat(\"param value\", &amp;anotherParam);  // set a float variable\n\nif (ImGui::Button(\"run subroutine\")) {\n// executes when button is pressed\nmySubroutine();\n}\nImGui::SameLine();\nif (ImGui::Button(\"hi\")) {\npolyscope::warning(\"hi\");\n}\n\nImGui::PopItemWidth();\n}\n\nint main(int argc, char** argv) {\n\n/*\n    ...your program setup...\n  */ // Initialize polyscope\npolyscope::init();\n\n// Specify the callback\npolyscope::state::userCallback = myCallback;\n\n// Give control to the polyscope gui\npolyscope::show();\n\nreturn EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"features/callbacks_and_UIs/#options","title":"Options","text":"<code>bool options::openImGuiWindowForUserCallback</code> <code>bool options::invokeUserCallbackForNestedShow</code> <code>bool options::giveFocusOnShow</code>"},{"location":"features/callbacks_and_UIs/#open-imgui-window-for-user-callback","title":"open imgui window for user callback","text":"<p>If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like <code>ImGui::Button(\"do stuff\")</code>. </p> <p>If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any).</p> <p>Default: <code>true</code>.</p>"},{"location":"features/callbacks_and_UIs/#invoke-user-callback-for-nested-show","title":"invoke user callback for nested show","text":"<p>Suppose you call <code>polyscope::show()</code>, and within your callback, another instance of <code>polyscope::show()</code> is called\u2014this is a nested show.</p> <p>Depending on the situation, you might or might not want your <code>userCallback</code> to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option.</p> <p>If true, your callback will be executed as normal for every main loop iteration, even in nested show windows.</p> <p>If false, your callback will only be executed for initial, outermost calls to <code>polyscope::show()</code>.</p> <p>Default: <code>false</code>.</p>"},{"location":"features/callbacks_and_UIs/#give-focus-on-show","title":"give focus on show","text":"<p>If true, the Polyscope window will request focus from the window manager whenever <code>show()</code> is called. If false, the focus state will be left unchanged.</p> <p>Default: <code>false</code>.</p>"},{"location":"features/callbacks_and_UIs/#mouse-interactions","title":"Mouse Interactions","text":"<p>You can implement custom mouse behaviors on clicks and other actions within your per-frame callback function. Generally, you can use the mouse-related functions available via <code>ImGui</code> to implement a wide variety of behaviors.</p> <p>Example: print a variety of info about a mouse click <pre><code>ImGuiIO&amp; io = ImGui::GetIO();\nif (io.MouseClicked[0]) { // if the left mouse button was clicked\n// gather values\nglm::vec2 screenCoords{io.MousePos.x, io.MousePos.y};\nglm::vec3 worldRay = polyscope::view::screenCoordsToWorldRay(screenCoords);\nglm::vec3 worldPos = polyscope::view::screenCoordsToWorldPosition(screenCoords);\nstd::pair&lt;polyscope::Structure*, size_t&gt; pickPair = polyscope::pick::pickAtScreenCoords(screenCoords);\n\n// print some values\nstd::cout &lt;&lt; \"    io.MousePos.x: \" &lt;&lt; io.MousePos.x &lt;&lt; \" io.MousePos.y: \" &lt;&lt; io.MousePos.y &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"    screenCoords.x: \" &lt;&lt; screenCoords.x &lt;&lt; \" screenCoords.y: \" &lt;&lt; screenCoords.y &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"    worldRay: \";\npolyscope::operator&lt;&lt;(std::cout, worldRay) &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"    worldPos: \";\npolyscope::operator&lt;&lt;(std::cout, worldPos) &lt;&lt; std::endl;\nif (pickPair.first == nullptr) {\nstd::cout &lt;&lt; \"    structure: \" &lt;&lt; \"none\" &lt;&lt; std::endl;\n} else {\nstd::cout &lt;&lt; \"    structure: \" &lt;&lt; pickPair.first &lt;&lt; \" element id: \" &lt;&lt; pickPair.second &lt;&lt; std::endl;\n}\n}\n</code></pre></p> <code>glm::vec3 view::screenCoordsToWorldRay(glm::vec2 screenCoords)</code> <code>glm::vec3 view::screenCoordsToWorldPosition(glm::vec2 screenCoords)</code> <code>std::pair&lt;polyscope::Structure*, size_t&gt; pick::pickAtScreenCoords(glm::vec2 screenCoords)</code>"},{"location":"features/callbacks_and_UIs/#screen-coords-to-world-ray","title":"screen coords to world ray","text":"<p>Convert a click location to a ray in world-space.</p>"},{"location":"features/callbacks_and_UIs/#screen-coords-to-world-position","title":"screen coords to world position","text":"<p>Convert a click location to a location in world-space, by reading from the scene\u2019s depth buffer.</p>"},{"location":"features/callbacks_and_UIs/#pick-at-screen-coords","title":"pick at screen coords","text":"<p>Evaluate a \u201cpick\u201d query to get the object onscreen at a given location. Returns a pointer to the structure (or <code>nullptr</code> if none), and an index to an element within the structure. The meaning of this index is specific to the structure, for instance for surface meshes it is a packed layout of vertices, then faces, etc.</p>"},{"location":"features/callbacks_and_UIs/#custom-uis","title":"Custom UIs","text":"<p>If desired, you can circumvent Polyscope\u2019s standard ImGui style and UI panes, in ordered to build dramatically customized applications.</p> <p>Warning</p> <p>Circumventing the standard Polyscope user interface should be considered \u201cadvanced\u201d usage. You are more likely to encounter bugs, and you may need to look at the Polyscope source to understand the behavior. The functions listed in this section may change in future versions of Polyscope.</p> <p>Two callback functions are made available to configure the appearance of Polyscope\u2019s ImGui panes. These callbacks are invoked internally by Polyscope during the setup process. If desired, you can set them to your own custom functions to use alternate styles.</p> <p>Example: <pre><code>// clearing the callback will fall back on default imgui styles\npolyscope::options::configureImGuiStyleCallback = nullptr;\n\n// alternately, set a custom callback \n// (which in this case simply configures the imgui light style)\npolyscope::options::configureImGuiStyleCallback = []() { ImGui::StyleColorsLight(); };\n\n// clearing the fonts callback will fall back on default imgui fonts\npolyscope::options::prepareImGuiFontsCallback = nullptr;\n\n// initialize polyscope\npolyscope::init();\n\n// ... the rest of your program as usual\n</code></pre></p> <code>std::function&lt;void()&gt; options::configureImGuiStyleCallback</code> <code>std::function&lt;std::tuple&lt;ImFontAtlas*, ImFont*, ImFont*&gt;()&gt; options::prepareImGuiFontsCallback</code> <p>The option <code>buildGui</code> can be used to entirely disable all of Polyscope\u2019s ImGui UI elements, allowing you to build your own UI. Polyscope will still initialize ImGui and invoke its drawing routines each frame.</p> <code>bool options::buildGui</code> <p>The functions <code>buildPolyscopeGui()</code>, <code>buildStructureGui()</code>, <code>buildPickGui()</code>, and <code>buildUserGuiAndInvokeCallback()</code> can be used to manually build pieces of the UI one at a time.</p>"},{"location":"features/callbacks_and_UIs/#imgui-style-callback","title":"imgui style callback","text":"<p>A callback function which will be invoked when an ImGui context is created (which may happen several times as Polyscope runs). By default, this is set to invoke <code>configureImGuiStyle()</code> from Polyscope\u2019s <code>imgui_config.cpp</code>, but you may assign your own function to create custom styles. If this callback is null, the default ImGui style will be used.</p>"},{"location":"features/callbacks_and_UIs/#imgui-fonts-callback","title":"imgui fonts callback","text":"<p>A callback function which will be invoked exactly once during initialization to construct a font atlas for ImGui to use. The callback should return a tuple of three pointers: a newly created global shared font atlas, a regular font, and a mono font. By default, this is set to invoke <code>prepareImGuiFonts()</code> from Polyscope\u2019s <code>imgui_config.cpp</code>, but you may assign your own function to create custom styles. If this callback is null, default fonts will be used.</p> <p>This callback is invoked when <code>polycope::init()</code> is called, so if you are going to customize it you must do so before <code>init()</code>.</p> <p>The default implementation of this callback looks something like the following. You can customize your own version of this function to modify any Polyscope fonts, or if you simply want to load additional fonts, do so at the commented note below.</p> <pre><code>std::tuple&lt;ImFontAtlas*, ImFont*, ImFont*&gt; prepareImGuiFonts() {\nImGuiIO&amp; io = ImGui::GetIO();\n\n// outputs\nImFontAtlas* globalFontAtlas;\nImFont* regularFont;\nImFont* monoFont;\n\n{ // add regular font\nImFontConfig config;\nregularFont = io.Fonts-&gt;AddFontFromMemoryCompressedTTF(render::getLatoRegularCompressedData(),\nrender::getLatoRegularCompressedSize(), 18.0f, &amp;config);\n}\n\n{ // add mono font\nImFontConfig config;\nmonoFont = io.Fonts-&gt;AddFontFromMemoryCompressedTTF(render::getCousineRegularCompressedData(),\nrender::getCousineRegularCompressedSize(), 16.0f, &amp;config);\n}\n\n// Add your own additional fonts here\n\nio.Fonts-&gt;Build();\nglobalFontAtlas = io.Fonts;\n\nreturn std::tuple&lt;ImFontAtlas*, ImFont*, ImFont*&gt;{globalFontAtlas, regularFont, monoFont};\n}\n</code></pre>"},{"location":"features/callbacks_and_UIs/#build-gui","title":"build gui","text":"<p>This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope.</p> <p>If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs.</p> <p>Default: <code>true</code>.</p>"},{"location":"features/color_maps/","title":"Color Maps","text":""},{"location":"features/color_maps/#built-in-color-maps","title":"Built-in color maps","text":"<p>Different color maps are appropriate for different situations:</p> <ul> <li>sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below).</li> <li>diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases <code>0</code> semantially means \u201cnothing\u201d, and the endpoints have opposite meaning.</li> <li>cyclic maps data defined on the circle, like an angle</li> <li>decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes</li> </ul> <p>Polyscope supports the following built-in color maps:</p> Name Type String Key viridis sequential <code>viridis</code> blues sequential <code>blues</code> reds sequential <code>reds</code> coolwarm diverging <code>coolwarm</code> pink-green diverging <code>pink-green</code> phase cyclic <code>phase</code> spectral decorative <code>spectral</code> rainbow decorative <code>rainbow</code> jet decorative <code>jet</code> turbo decorative <code>turbo</code>"},{"location":"features/color_maps/#loading-custom-color-maps","title":"Loading custom color maps","text":"<p>Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from <code>[Appearance] --&gt; [Color maps] --&gt; [Load color map]</code>, or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting <code>stb_image</code> can read).</p> <p></p> <code>void polyscope::loadColorMap(std::string cmapName, std::string filename)</code> <ol> <li> <p>Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9</p> </li> <li> <p>Phase is from the <code>cmocean</code> package. link \u21a9</p> </li> <li> <p>Turbo is by Anton Mikhailov and others at Google. link \u21a9</p> </li> <li> <p>The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib.\u00a0\u21a9</p> </li> </ol>"},{"location":"features/color_maps/#loadcolormap","title":"loadColorMap","text":"<p>Load a new colormap from the image file <code>filename</code>, which will be assigned the name <code>cmapName</code>.</p>"},{"location":"features/ground_and_shadows/","title":"Ground and Shadows","text":"<p>The Polyscope scene view includes a ground plane which optionally supports reflection and soft-shadow effects. This section outlines the various modes and options available for the ground plane.</p> <p></p>"},{"location":"features/ground_and_shadows/#ground-plane-and-shadow-modes","title":"Ground plane and shadow modes","text":"<ul> <li><code>GroundPlaneMode::None</code> no ground plane, nor reflection/shadows are shown</li> <li><code>GroundPlaneMode::Tile</code> a tiled ground plane </li> <li><code>GroundPlaneMode::TileReflection</code> a tiled ground plane with a reflection of the scene (default)</li> <li><code>GroundPlaneMode::ShadowOnly</code> a transparent ground plane with a soft vertical shadow of the scene</li> </ul> <p>The ground plane and shadow settings can also be manually adjusted in the GUI under the <code>[Appearance] --&gt; [Ground Plane]</code> menu.</p> <p>Example: adjust the ground plane &amp; shadow appearance</p> <pre><code>#include \"polyscope/polyscope.h\"\n\npolyscope::init();\n\n// set the ground location manually\npolyscope::options::groundPlaneHeightMode = polyscope::GroundPlaneHeightMode::Manual;\npolyscope::options::groundPlaneHeight = 0.; // in world coordinates along the up axis\n\n// set soft shadows on the ground\npolyscope::options::groundPlaneMode = polyscope::GroundPlaneMode::ShadowOnly;\npolyscope::view::upDir = UpDir::ZUp;                 // set +Z as up direction\npolyscope::options::groundPlaneHeightFactor = -0.25; // adjust the plane height\npolyscope::options::shadowDarkness = 0.1;            // lighter shadows\n\n/* load your mesh, point cloud, etc */\n\n// take screenshot from the current camera view, which will have transparent shadows\npolyscope::screenshot(\"test_image.png\", true);\n\n// open the GUI\npolyscope::show();\n</code></pre> <code>GroundPlaneMode options::groundPlaneMode</code> <p>Set the mode used for the ground plane, as described above. Should be one of <code>GroundPlaneMode::None</code>, <code>GroundPlaneMode::Tile</code>, <code>GroundPlaneMode::TileReflection</code>, or <code>GroundPlaneMode::ShadowOnly</code>.</p> <p>Default: <code>GroundPlaneMode::TileReflection</code>.</p> <p>Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set <code>alpha = options::shadowDarkness</code> values for shadowed areas, and set <code>alpha=0</code> for unshadowed parts of the ground plane.</p> <p>The <code>options::shadowBlurIters</code> and <code>options::shadowDarkness</code> parameters below adjust the visual appearance of soft shadows for <code>GroundPlaneMode::ShadowOnly</code>.</p> <code>int options::shadowBlurIters</code> <p>The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy.</p> <p>Default: <code>2</code>. </p> <code>float options::shadowDarkness</code> <p>How dark the shadows are. <code>0</code> is totally transparent (white), and <code>1</code> is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions.</p> <p>Default: <code>.25</code>. </p>"},{"location":"features/ground_and_shadows/#ground-plane-positioning","title":"Ground plane positioning","text":"<p>The orientation of the ground plane is determined by the up direction for the scene, which can be set along any of the coordinate directions such as <code>+X</code>, <code>-Z</code>, etc.</p> <p>By default, the height of the ground plane is set automatically to the bottom of the bounding box for the scene content (and can optionally be relatively offset via <code>groundPlaneHeightFactor</code>).</p> <p>Alternately, the height can be specified to a fixed location in world coordinates like: <pre><code>polyscope::options::groundPlaneHeightMode = polyscope::GroundPlaneHeightMode::Manual;\npolyscope::options::groundPlaneHeight = 0.; // in world coordinates along the up axis\n</code></pre></p> <code>GroundPlaneMode options::groundPlaneHeightMode</code> <p>Set how the height of the ground plane is computed, one of:</p> <ul> <li><code>GroundPlaneHeightMode::Automatic</code> anchored to the bottom of the scene bounding box, optionally offset by <code>groundPlaneHeightFactor</code></li> <li><code>GroundPlaneHeightMode::Manual</code> in absolute world coordinates, at the location <code>groundPlaneHeight</code></li> </ul> <p>Default: <code>GroundPlaneHeightMode::Automatic</code>.</p> <code>ScaledValue&lt;float&gt; options::groundPlaneHeight</code> <p>The location of the ground plane, in world coordinates.</p> <p>This parameter only has an effect if <code>options::groundPlaneHeightMode == GroundPlaneHeightMode::Manual</code>.</p> <p>Default: <code>0</code>. </p> <code>ScaledValue&lt;float&gt; options::groundPlaneHeightFactor</code> <p>The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down.</p> <p>This parameter only has an effect if <code>options::groundPlaneHeightMode == GroundPlaneHeightMode::Automatic</code>.</p> <p>This parameter is a scaled value. You can assign to it like a normal float, <code>options::groundPlaneHeightFactor = 0.5</code>, and the resulting value will be relative to the scene length scale. Alternately, absolute values can also be used, as described on the linked page.</p> <p>Default: <code>0</code>. </p>"},{"location":"features/groups/","title":"Groups","text":"<p>To manage large numbers of structures, or manage structures which are related to each other, you can gather them in groups. A group is a collection of structures which can be enabled/disabled together and hidden from the UI if needed. A structure can be in 0, 1, or many groups. Groups can also hold other groups, allowing nested organization.</p>    Your browser does not support the video tag.  <p>Example: Basic usage of groups</p> <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/point_cloud.h\"\n#include \"polyscope/curve_network.h\"\n\npolyscope::init();\n\n// make a point cloud\nstd::vector&lt;glm::vec3&gt; points;\nfor (size_t i = 0; i &lt; 300; i++) {\npoints.push_back(glm::vec3{polyscope::randomUnit() - .5, polyscope::randomUnit() - .5, polyscope::randomUnit() - .5}); }\npolyscope::PointCloud* psCloud = polyscope::registerPointCloud(\"my cloud\", points);\npsCloud-&gt;setPointRadius(0.02);\npsCloud-&gt;setPointRenderMode(polyscope::PointRenderMode::Quad);\n\n// make a curve network\nstd::vector&lt;glm::vec3&gt; nodes;\nstd::vector&lt;std::array&lt;size_t, 2&gt;&gt; edges;\nnodes = { {1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {0, 0, 0}, };\nedges = {{1, 3}, {3, 0}, {1, 0}, {0, 2}};\npolyscope::CurveNetwork* psCurve = polyscope::registerCurveNetwork(\"my network\", nodes, edges);\n\n// create a group for these two objects\nstd::string groupName = \"my group\";\npolyscope::Group* group = polyscope::createGroup(groupName);\npsCurve-&gt;addToGroup(*group);    // add by group ref\npsCloud-&gt;addToGroup(groupName); // add by name\n\n// toggle enabled for everything in the group\ngroup-&gt;setEnabled(false);\n\n// hide items in group from displaying in the UI\n// (useful if you are registering huge numbers of structures you don't always need to see)\ngroup-&gt;setHideDescendantsFromStructureLists(true);\ngroup-&gt;setShowChildDetails(false);\n\n// nest groups inside of other groups\nstd::string superGroupName = \"my parent group\";\npolyscope::Group* superGroup = polyscope::createGroup(superGroupName);\nsuperGroup-&gt;addChildGroup(*group);\n\npolyscope::show(3);\n</code></pre>"},{"location":"features/groups/#create-get-and-remove-groups","title":"Create, get, and remove groups","text":"<code>Group* createGroup(std::string name)</code> <code>Group* getGroup(std::string name)</code> <code>void removeGroup(std::string name, bool errorIfAbsent=true)</code> <code>void removeGroup(Group* group, bool errorIfAbsent=true)</code> <code>void removeAllGroups()</code>"},{"location":"features/groups/#create-group","title":"create group","text":"<p>Create a new group and return it. Group name must be a unique string (no other group may have that name).</p> <p>As always, the returned pointer is non-owning. Don\u2019t delete it.</p>"},{"location":"features/groups/#get-group","title":"get group","text":"<p>Get an existing group by name. </p> <p>As always, the returned pointer is non-owning. Don\u2019t delete it.</p>"},{"location":"features/groups/#remove-group-by-name","title":"remove group by name","text":"<p>Remove an existing group by name</p>"},{"location":"features/groups/#remove-group-by-reference","title":"remove group by reference","text":"<p>Remove an existing group by reference</p>"},{"location":"features/groups/#remove-all-groups","title":"remove all groups","text":"<p>Removes all existing groups.</p>"},{"location":"features/groups/#group-membership","title":"Group membership","text":"<code>void Structure::addToGroup(Group&amp; group)</code> <code>void Structure::addToGroup(std::string groupName)</code> <code>void Group::addChildStructure(Structure&amp; newChild)</code> <code>void Group::removeChildStructure(Structure&amp; child)</code> <code>void Group::addChildGroup(Group&amp; newChild)</code> <code>void Group::removeChildGroup(Group&amp; child)</code>"},{"location":"features/groups/#add-structure-to-group","title":"add structure to group","text":"<p>Add a structure as a member of a group.</p> <p>Note that this is a member function of a structure object, like <code>pointCloud-&gt;addToGroup(group)</code>.</p>"},{"location":"features/groups/#add-structure-to-group_1","title":"add structure to group","text":"<p>Add a structure as a member of a group, via the string name of the group.</p> <p>Note that this is a member function of a structure object, like <code>pointCloud-&gt;addToGroup(groupName)</code>.</p>"},{"location":"features/groups/#add-child-structure","title":"add child structure","text":"<p>Add a structure as a member of this group</p>"},{"location":"features/groups/#remove-child-structure","title":"remove child structure","text":"<p>Remove a structure as a member of this group</p>"},{"location":"features/groups/#add-child-group","title":"add child group","text":"<p>Add a group as a (nested) member of this group</p>"},{"location":"features/groups/#remove-child-group","title":"remove child group","text":"<p>Remove a group as a (nested) member of this group</p>"},{"location":"features/groups/#group-settings","title":"Group settings","text":"<code>Group* Group::setEnabled(bool newEnabled)</code> <code>Group* Group::setShowChildDetails(bool newVal)</code> <code>Group* Group::setHideDescendantsFromStructureLists(bool newVal)</code>"},{"location":"features/groups/#set-enabled","title":"set enabled","text":"<p>Set all descendants of a group to be enabled or disabled (applies to direct members of a group, as well as recursively to all members-of-members for nested groups).</p>"},{"location":"features/groups/#show-ui-details","title":"show UI details","text":"<p>If true, the Groups section of the ImGui UI panel will show each childs structure info as a submenu under the group. If false, only the group name and toggle checkbox will be shown.</p> <p>(Default: true)</p> <p>There is also a corresponding <code>getShowChildDetails()</code>.</p>"},{"location":"features/groups/#hide-from-structure-list","title":"hide from structure list","text":"<p>If true, the structures which are members of this group (or descendants in any nested groups) will be hidden from the ImGui UI panel structure list.</p> <p>(Default: false)</p> <p>There is also a corresponding <code>getHideDescendantsFromStructureLists()</code>.</p>"},{"location":"features/implicit_helpers/","title":"Implicit Helpers","text":"<p>Implicit functions take an xyz position as input, and return a value. Polyscope contains several helper features to directly visualize implicit functions by taking a callable as input and automatically invoking it as needed. This can be a much easier way to interface with volumetric and inherently implicit data. In particular, Polyscope contains a built-in renderer to render images of levelsets of implicit functions.</p> <p><code>#include \"polyscope/implicit_helpers.h\"</code></p> <p>Individual vs. Batch Evaluation</p> <p>Each implicit helper function comes in two versions:</p> <ul> <li>A simple individual version, which invokes the implicit function just once to produce a single value. It expects a function with a signature like <code>float my_func(glm::vec3 pos)</code>. </li> <li>A batch evaluation version, which invokes the implicit function many times on a batch of inputs in buffers. It expects a function with a signature like <code>void my_func(float* inPos, float* outResult, size_t N)</code>, where the first argument is a length-<code>3*N</code> array of query locations, the second argument is an already-allocated buffer of length N to store the results, and <code>N</code> is the number of queries. For color functions, the outResult with be of length <code>3*N</code> instead.</li> </ul> <p>The first individual version is simplest, and fits the usual definition of an implicit function. However, Polyscope might need to invoke the callback function millions of times, which can introduce excessive performance overhead, especially if the underlying function is being evaluated on a GPU, or via bindings to another language. For this reason, the batch version is also available, to perform many evaluations with each invocation and amortize the overhead.</p>"},{"location":"features/implicit_helpers/#directly-rendering-implicit-isosurfaces","title":"Directly Rendering Implicit Isosurfaces","text":"<p>Polyscope can directly render images of an isosurface of an implicit function in space, from the current viewport or from a defined camera view. The resulting renders are added as Render Images, which support material shading, colormapping, transparency, and depth-compositing with other content in the scene.</p> <p></p> <p>Not a Fast Renderer</p> <p>There is a long history of highly efficient real-time implicit shaders and ray marchers in computer graphics. Polyscope\u2019s built-in implicit ray marching renderer is not fast, and it never will be! It should be viewed as a debugging tool, not a real-time renderer. Its design fundamentally prioritizes ease-of-use over speed; for instance even if your function is defined on the GPU, Polyscope will perform many expensive CPU round-trips to render it, doing multiple evaluations of the given implicit function.</p> <p>If you want real-time implicit rendering, you will need to perform that rendering outside of Polyscope. However, the resulting renders can still be added to Polyscope as a Render Image to take advantage of Polyscope\u2019s functionality. You can even use direct GPU interop (beta feature!) to do so with minimal realtime overhead.</p> <p>Example: <pre><code>#include \"polyscope/implicit_helpers.h\"\n\npolyscope::init();\n\n// define some implicit functions\nauto torusSDF = [](glm::vec3 p) { /* evaluates the SDF of a torus, returns a float */ };\nauto boxFrameSDF = [](glm::vec3 p) { /* evaluates the SDF of a box, returns a float */ };\nauto colorFunc = [](glm::vec3 p) { /* gives a color in space, returns a glm::vec3 */ };\nauto scalarFunc = [](glm::vec3 p) {/* gives a scalar in space, returns a float */  };\n\n// setup options\npolyscope::ImplicitRenderOpts opts;\npolyscope::ImplicitRenderMode mode = polyscope::ImplicitRenderMode::SphereMarch;\n// polyscope::ImplicitRenderMode mode = polyscope::ImplicitRenderMode::FixedStep; // (alternately, if not an SDF)\nopts.subsampleFactor = 2; // downsample the rendering\n\n// render the implicit isosurfaces from the current viewport\npolyscope::DepthRenderImageQuantity* img = polyscope::renderImplicitSurface(\"torus sdf\", torusSDF, mode, opts);\npolyscope::DepthRenderImageQuantity* img2 = polyscope::renderImplicitSurface(\"box sdf\", boxFrameSDF, mode, opts);\npolyscope::ColorRenderImageQuantity* img2Color =\npolyscope::renderImplicitSurfaceColor(\"box sdf color\", boxFrameSDF, colorFunc, mode, opts);\npolyscope::RawColorRenderImageQuantity* img2rawColor =\npolyscope::renderImplicitSurfaceRawColor(\"box sdf raw color\", boxFrameSDF, colorFunc, mode, opts);\npolyscope::ScalarRenderImageQuantity* imgScalar =\npolyscope::renderImplicitSurfaceScalar(\"torus sdf scalar\", torusSDF, scalarFunc, mode, opts);\n\npolyscope::show();\n</code></pre> There is also an alternate version of every render function that takes an additional first argument which is a pointer to any structure. The resulting render images will be added to that structure, following the same semantics as floating quantities.</p>"},{"location":"features/implicit_helpers/#implicit-render-options","title":"Implicit Render Options","text":"<p>The most important option to set the <code>mode</code> for the renderer. There are two choices:</p> <ul> <li><code>ImplicitRenderMode::SphereMarch</code> should be used if your implicit function is a Signed Distance Function (SDF). That is, its magnitude gives the distance to the surface, or at least a conservative bound on the distance. This allows the renderer to take large steps based on the SDF value.</li> <li><code>ImplicitRenderMode::FixedStep</code> must be used if your implicit function is not necessarily an SDF. This forces to renderer to take many small steps, which is inefficient but always works for sufficiently small step size.</li> </ul> <p>The <code>ImplicitRenderOpts</code> struct controls the remaining settings for the renderer.</p> <pre><code>struct ImplicitRenderOpts {\n\n// = Options for how the image is defined\n\n// (1) If camera parameters &amp; resolution are passed, in these options, they will always be respected.\n//\n// (2) Otherwise, if the parent structure is null (or the global floating struct), we will render from the current\n// polyscope camera view, and take the resolution etc from that.\n//\n// (3) Otherwise, if the parent structure is a camera view, we will take the camera parameters from that, but the\n// dimensions must be specified.\n//\n// (4) Otherwise, if the parent structure is a structure other than the camera view, the parameters should have been\n// explicitly specified as in (1), and an error will be thrown.\n\n// The camera parameters to use.\n// If left as the default uninitialized camera, it will be overwritten according to the policies above.\nCameraParameters cameraParameters = CameraParameters::createInvalid();\n\n// The dimensions at which to render the image.\n// These normally must be set explicitly, unless we are rendering from the current view as specified above.\nint32_t dimX = -1;\nint32_t dimY = -1;\n\n// If dimX and dimY are being set automatically, downscale them by this factor (e.g. subsampleFactor=2 means use\n// dimX/2 and dimY/2)\nint subsampleFactor = 1;\n\n// = Options for the rendering computation itself\n\n// How far the ray must go before it is abandoned as a miss\nScaledValue&lt;float&gt; missDist = ScaledValue&lt;float&gt;::relative(20.);\n\n// How small the the value of the implicit function must be to be considered a hit\nScaledValue&lt;float&gt; hitDist = ScaledValue&lt;float&gt;::relative(1e-4);\n\n// For mode == SphereMarch, a small tolerance factor applied to step sizes\nfloat stepFactor = 0.99;\n\n// Used to estimate normals via finite differences, also used relative value times the hit distance.\nfloat normalSampleEps = 1e-3;\n\n// The size of the steps used for mode == FixedStep\nScaledValue&lt;float&gt; stepSize = ScaledValue&lt;float&gt;::relative(1e-2);\n\n// The maximum number of steps to take\nsize_t nMaxSteps = 1024;\n};\n</code></pre>"},{"location":"features/implicit_helpers/#render-depth-images","title":"Render Depth Images","text":"<p>Render a depth Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting.</p> <code>DepthRenderImageQuantity* renderImplicitSurface(std::string name, Func&amp;&amp; func, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts())</code> <ul> <li><code>func</code> a callable defining the function whose 0-levelset we will render</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p> <code>DepthRenderImageQuantity* renderImplicitSurfaceBatch(std::string name, Func&amp;&amp; func, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts())</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-scalar-images","title":"Render Scalar Images","text":"<p>Render a scalar Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting. An additional implicit function defines a scalar value which will be shaded with colormapping on the isosurface.</p> <code>ScalarRenderImageQuantity* renderImplicitSurfaceScalar(std::string name, Func&amp;&amp; func, FuncScalar&amp;&amp; funcScalar, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts(), DataType dataType = DataType::STANDARD)</code> <ul> <li><code>func</code> a callable defining the function whose 0-levelset we will render</li> <li><code>funcScalar</code> another callable defining a scalar function which will be evaluated on the isosurface and displayed with color mapping</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p> <code>ScalarRenderImageQuantity* renderImplicitSurfaceScalarBatch(std::string name, Func&amp;&amp; func, FuncScalar&amp;&amp; funcScalar, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts(), DataType dataType = DataType::STANDARD)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>funcScalar</code> another batch callable defining a scalar function which will be evaluated on the isosurface and displayed with color mapping</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-color-images","title":"Render Color Images","text":"<p>Render a color Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting. An additional implicit function defines a color value which will be shaded with colormapping on the isosurface.</p> <code>ColorRenderImageQuantity* renderImplicitSurfaceColor(std::string name, Func&amp;&amp; func, FuncColor&amp;&amp; funcColor, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts())</code> <ul> <li><code>func</code> a callable defining the function whose 0-levelset we will render</li> <li><code>funcColor</code> another callable defining a color function which will be evaluated on the isosurface and displayed with color mapping</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p> <code>ColorRenderImageQuantity* renderImplicitSurfaceColorBatch(std::string name, Func&amp;&amp; func, FuncColor&amp;&amp; funcColor, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts())</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>funcColor</code> another batch callable defining a color function which will be evaluated on the isosurface and displayed with color mapping</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-raw-color-images","title":"Render Raw Color Images","text":"<p>Render a raw color Render Image of the 0 isosurface of a function. An additional implicit function defines a color value which will be used on the isosurface. The difference between color and raw color images is that plain <code>Color</code> rendered images apply lighting and material shading to the colors (like a <code>SurfaceMesh</code> would), whereas <code>RawColor</code> images really just directly display the given color as the pixel values.</p> <code>RawColorRenderImageQuantity* renderImplicitSurfaceRawColor(std::string name, Func&amp;&amp; func, FuncColor&amp;&amp; funcColor, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts())</code> <ul> <li><code>func</code> a callable defining the function whose 0-levelset we will render</li> <li><code>funcColor</code> another callable defining a color function which will be evaluated on the isosurface</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p> <code>RawColorRenderImageQuantity* renderImplicitSurfaceRawColorBatch(std::string name, Func&amp;&amp; func, FuncColor&amp;&amp; funcColor, ImplicitRenderMode mode, ImplicitRenderOpts opts = ImplicitRenderOpts())</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>funcColor</code> another batch callable defining a color function which will be evaluated on the isosurface</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cIndividual vs. Batch\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#implicit-volumes","title":"Implicit Volumes","text":"<p>In addition rendering isosurfaces, Polyscope can automatically register the implicit function as a volumetric grid of values. See the volume grid scalar quantity for details.</p>"},{"location":"features/materials/","title":"Materials","text":"<p>Polyscope uses matcaps to render the appearance of objects in the scene, as opposed to more traditional configurations of lights and shading models, etc. A matcap is a small image of a material, which is sampled by the renderer to query the materials\u2019 appearance from a some angle. Scene information like lighting is implicitly baked in to the matcap image.</p> <p>Most objects in Polyscope (surface meshes, point clouds, vectors, etc) expose a <code>setMaterial(std::string)</code> option to choose a material for the object\u2019s appearance. Additionally, materials can generally be set in the UI from <code>[Options] --&gt; [Material]</code>.</p>"},{"location":"features/materials/#blended-materials","title":"Blended materials","text":"<p>In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities).  Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps.</p> How it works <p>Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components.</p> <p> </p> <p>At runtime, to generate a color from a triple of <code>rgb</code> values each in the range <code>[0,1]</code>, we sample the images like:</p> <pre><code>outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k\n</code></pre> <p>Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color.  Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space.</p> <p>Materials which which support this blending are denoted by <code>(rgb)</code> in the options menu.  Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options.</p>"},{"location":"features/materials/#preserving-colors-with-the-flat-material","title":"Preserving colors with the flat material","text":"<p>Generally, Polyscope applies material shading and tone-mapping to render 3D content. However, this means that data such as colors and tonemapped scalars will be a somewhat different color on-screen compared to what is in the data.</p> <p>The <code>flat</code> material is special: it not only applies flat coloring with no shading effects, but furthermore cancels-out tonemapping and other effects to ensure that the color you see onscreen is exactly the same as the data specified.</p> <p>Use the <code>flat</code> material any time you need exact color reproduction.</p>"},{"location":"features/materials/#built-in-materials","title":"Built-in materials","text":"<p>Polyscope supports the following built-in materials:</p> Name String Key Blendable Image clay <code>clay</code> yes wax <code>wax</code> yes candy <code>candy</code> yes flat <code>flat</code> yes mud1 <code>mud</code> no ceramic1 <code>ceramic</code> no jade1 <code>jade</code> no normal1 <code>normal</code> no"},{"location":"features/materials/#loading-custom-materials","title":"Loading custom materials","text":"<p>Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from <code>[Appearance] --&gt; [Materials] --&gt; [Load material]</code>, or programatically using the function below. For blendable matcaps, if the single filename <code>mat.hdr</code> is given, Polyscope will try to load <code>mat_r.hdr</code>, <code>mat_g.hdr</code>, etc.</p> <p>Ideally, matcap images should be linear <code>.hdr</code> images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with <code>intensity=1</code> and <code>gamma=2.2</code> before use.  Most common image formats are accepted (anything <code>stb_image</code> can read).</p> <code>void polyscope::loadStaticMaterial(std::string matName, std::string filename)</code> <code>void polyscope::loadBlendableMaterial(std::string matName, std::array&lt;std::string, 4&gt; filenames)</code> <code>void polyscope::loadBlendableMaterial(std::string matName, std::string filenameBase, std::string filenameExt)</code> <ol> <li> <p>The matcaps are from the Blender matcap repository, available under a CC0/public domain license. Thanks to the Blender community for contributing them!\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"features/materials/#loadstaticmaterial","title":"loadStaticMaterial","text":"<p>Load a new static (non-blendable) material from a single image file <code>filename</code>. The new material will be called <code>matName</code>.</p>"},{"location":"features/materials/#loadblendablematerial","title":"loadBlendableMaterial","text":"<p>Load a new blendable material from image files <code>filenames</code>, corresponding to red, green, blue, and black basis materials. The new material will be called <code>matName</code>.</p>"},{"location":"features/materials/#loadblendablematerial_1","title":"loadBlendableMaterial","text":"<p>Same as above, but the four filenames will be generated as <code>filenameBase + \"_r\" + filenameExt</code>, etc.</p>"},{"location":"features/messages/","title":"Messages","text":""},{"location":"features/messages/#using-messages","title":"Using messages","text":"<p>We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging.  Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way.</p> <p>There are a few levels of messages available:</p> <ul> <li>error A very bad error; immediately shows and blocks the UI for user response.</li> <li>terminating error Like <code>error</code>, but terminates the program after being dismissed.</li> <li>warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program.</li> <li>info A low-priority message, which is just printed to <code>stdout</code>.</li> </ul> <p>Messages can be dismissed by clicking the button in dialog box, or pressing <code>[space]</code>.</p> <p></p> <p>Example: <pre><code>#include \"polyscope/polyscope.h\"\n\n// Generate a single warning.\n// Has no effect on the GUI until polyscope gets control flow\n// back, which happens here in the show() call below.\npolyscope::warning(\"Something went slightly wrong\");\n\n// Generate a lot of warnings. Becase all of these warnings \n// have the same base message (the first string), they will \n// be batched together and only shown as one dialog. The detail \n// message for the first such warning will also be shown.\nfor (int i = 0; i &lt; 5000; i++) {\npolyscope::warning(\"Some problems come in groups\", \"detail = \" + std::to_string(i));\n}\n\n// The previous warnings would be displayed here\npolyscope::show();\n\n// Generating an error.\n// The UI will block and show this error immediately. After \n// the error is dismissed, the call will return.\npolyscope::error(\"Resistance is futile.\");\n\n// Generate a fatal error.\n// After the error is dismissed, the program will terminate.\npolyscope::terminatingError(\"Resistance is futile.\");\n</code></pre></p>"},{"location":"features/messages/#messages","title":"Messages","text":"<code>void polyscope::info(std::string message)</code> <code>void polyscope::warning(std::string baseMessage, std::string detailMessage = \"\")</code> <code>void polyscope::error(std::string message)</code> <code>void polyscope::terminatingError(std::string message)</code>"},{"location":"features/messages/#info","title":"info","text":"<p>Simply logs a message to <code>stdout</code>.</p>"},{"location":"features/messages/#warning","title":"warning","text":"<p>Create a warning message, to be displayed the next time the UI gets flow control. </p> <p>When issuing a one-off warning, the <code>detailMessage</code> field need not be used.  However, if issuing warnings in a loop, warnings with the same <code>baseMessage</code> are batched together, so the UI doesn\u2019t get completely overwhelmed.</p> <p>Example: <pre><code>#include \"polyscope/polyscope.h\"\n\n// Generate a single warning.\n// Has no effect on the GUI until polyscope gets control flow\n// back, which happens here in the show() call below.\npolyscope::warning(\"Something went slightly wrong\");\n\n// Generate a lot of warnings. Becase all of these warnings \n// have the same base message (the first string), they will \n// be batched together and only shown as one dialog. The detail \n// message for the first such warning will also be shown.\nfor (int i = 0; i &lt; 5000; i++) {\npolyscope::warning(\"Some problems come in groups\", \"detail = \" + std::to_string(i));\n}\n\n// The previous warnings would be displayed here\npolyscope::show();\n</code></pre></p>"},{"location":"features/messages/#error","title":"error","text":"<p>Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.</p>"},{"location":"features/messages/#terminating-error","title":"terminating error","text":"<p>Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, the program terminates.</p>"},{"location":"features/screenshots/","title":"Screenshots","text":"<p>Polyscope includes simple functionality for saving screenshots from the current camera view to disk. The ImGUI interface windows will be automatically hidden when taking a screenshot.</p> <p>Screenshots can be taken manually by pressing the <code>[screenshot]</code> button in the options GUI window, or programmatically using the functions below. Clicking the GUI button generates a numbered screenshot file in the current directory; the arrow to the side of the button can be used to adjust file format and transparency settings for these screenshots.</p> <p>It is not necessary to call <code>polyscope::show()</code> before taking screenshots. You can set up you scene and programmatically configure the camera view, then call <code>polyscope::screenshot()</code> to save a rendered image to disk, all without any user interaction.</p> <p>Example: Register a mesh, position the camera, and take a screenshot <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\n// Initialize Polyscope\npolyscope::init();\n\n// Register your mesh with Polyscope\npolyscope::registerSurfaceMesh(\"input mesh\", /* your verts */, /* your faces */);\n\n// Position the camera\npolyscope::view::lookAt(glm::vec3{10., 10., 0.}, glm::vec3{0., 2., 0.});\n\n// Adjust some screenshot default settings if you'd like\npolyscope::screenshotExtension = \".jpg\";\n\n// Take a screenshot\n// It will be written to your current directory as screenshot_000000.jpg, etc\npolyscope::screenshot();\n</code></pre></p> <code>void screenshot(bool transparentBG = true)</code> <code>std::string options::screenshotExtension</code> <code>void screenshot(std::string filename, bool transparentBG = true)</code> <code>std::vector&lt;unsigned char&gt; screenshotToBuffer(bool transparentBG = true)</code>"},{"location":"features/screenshots/#numbered-screenshot","title":"numbered screenshot","text":"<p>Saves a screenshot to the current directory, with file named like <code>screenshot_000000.png</code>, numbered automatically in increasing order. The numbering is reset to <code>0</code> for each run of the program; existing files will be silently overwritten.</p> <p>If <code>transparentBG</code> is <code>true</code>, the background will be rendered as transparent, and set as transparency alpha in the saved image if the file format supports it.</p>"},{"location":"features/screenshots/#screenshot-extension","title":"screenshot extension","text":"<p>Set the extension used when taking automatically-numbered screenshots, either with <code>screenshot()</code> or by clicking the GUI button.</p> <p>The extension should be <code>.png</code>, or <code>.jpg</code>.</p>"},{"location":"features/screenshots/#named-screenshot","title":"named screenshot","text":"<p>Saves a screenshot to the path given as <code>filename</code>, with format inferred from the file extension. </p> <p>The extension should be <code>.png</code>, or <code>.jpg</code>.</p> <p>If <code>transparentBG</code> is <code>true</code>, the background will be rendered as transparent.</p>"},{"location":"features/screenshots/#screenshot-to-buffer","title":"screenshot to buffer","text":"<p>Take a screenshot from the current view and return it as a buffer. The dimensions are <code>view::bufferWidth</code> * <code>view::bufferHeight</code>, with entries RGBA at 1 byte each.</p> <p>If <code>transparentBG</code> is <code>true</code>, the background will be rendered as transparent.</p>"},{"location":"features/slice_planes/","title":"Slice Planes","text":"<p>Geometric data often has complex internal structures. Slice planes can be added to the scene to cull away parts of an object and inspect its interior. These planes can be manipulated either programmatically or manually in the GUI.</p>    Your browser does not support the video tag.  <p>Example: sweep a slice plane through the scene to produce the animation above</p> <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n#include &lt;igl/readOBJ.h&gt;\n\n// Initialize Polyscope\npolyscope::init();\n\n// Read &amp; register the mesh\nEigen::MatrixXd meshV;\nEigen::MatrixXi meshF;\nigl::readOBJ(filename, meshV, meshF);\npolyscope::SurfaceMesh* psMesh = polyscope::registerSurfaceMesh(\"input mesh\", meshV, meshF);\n\n// Add a slice plane\npolyscope::SlicePlane* psPlane = polyscope::addSceneSlicePlane();\npsPlane-&gt;setDrawPlane(true);  // render the semi-transparent gridded plane\npsPlane-&gt;setDrawWidget(true);\n\n// Animate the plane sliding along the scene\nfor (float t = 0.; t &lt; 2. * M_PI; t += 2. * M_PI / 120) {\nfloat pos = std::cos(t) * .8 + .2;\npsPlane-&gt;setPose(glm::vec3{0., 0., pos}, glm::vec3{0., 0., -1.});\n\n// Take a screenshot at each frame\npolyscope::screenshot(false);\n}\n</code></pre> <p>Slice planes can also be manipulated in the GUI under <code>[View] --&gt; [Slice Planes]</code>, where you can add and remove slice planes and control whether they are active and widgets are visible. When a plane is active in the scene, you can drag the 3D widget to adjust its pose. Additionally, for each structure, <code>[Options] --&gt; [Slice Planes]</code> allows you to toggle whether the slice plane effects that structure.</p>"},{"location":"features/slice_planes/#creating-and-modifying-slice-planes","title":"Creating and modifying slice planes","text":"<code>SlicePlane* addSceneSlicePlane(bool initiallyVisible=false)</code> <code>void removeLastSceneSlicePlane()</code> <code>const std::string SlicePlane::name</code> <code>void SlicePlane::setPose(glm::vec3 planePosition, glm::vec3 planeNormal)</code> <code>void SlicePlane::setActive(bool newVal)</code> <code>bool SlicePlane::getActive()</code> <p>Test whether the slice plane is active.</p> <code>void SlicePlane::setDrawPlane(bool newVal)</code> <code>bool SlicePlane::getDrawPlane()</code> <p>Test whether the slice plane is drawing its plane.</p> <code>void SlicePlane::setDrawWidget(bool newVal)</code> <code>bool SlicePlane::getDrawWidget()</code> <p>Test whether the slice plane is drawing its widget.</p>"},{"location":"features/slice_planes/#add-slice-plane","title":"add slice plane","text":"<p>Add a new slice plane to the scene. An arbitrary number of slices planes may be added.</p> <p>If <code>initiallyVisible = false</code>, then the widget and plane grid will be disabled by default, which is usually what one wants when creating a slice plane programatically.</p>"},{"location":"features/slice_planes/#remove-slice-plane","title":"remove slice plane","text":"<p>Remove the most recently created slice plane.</p>"},{"location":"features/slice_planes/#name","title":"name","text":"<p>The unique name of the slice plane, which can be accessed like <code>myPlane-&gt;name</code>.</p>"},{"location":"features/slice_planes/#set-pose","title":"set pose","text":"<p>Set the position and orientation of the slice plane.</p> <ul> <li><code>planePosition</code> is any 3D position which the plane touches (the center of the plane)</li> <li><code>planeNormal</code> is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled</li> </ul>"},{"location":"features/slice_planes/#active","title":"active","text":"<p>Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view.</p>"},{"location":"features/slice_planes/#draw-plane","title":"draw plane","text":"<p>Set the slice plane to draw its plane (as a colored, semi-transparent grid). If <code>false</code> the slice plane will still slice objects, but the plane itself will not be rendered.</p>"},{"location":"features/slice_planes/#draw-widget","title":"draw widget","text":"<p>Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If <code>false</code> the slice plane will still slice objects, but the widget will not be rendered.</p> <p>Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes.</p>"},{"location":"features/slice_planes/#per-structure-ignore-slice-planes","title":"Per-structure ignore slice planes","text":"<p>By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under <code>[Options] --&gt; [Slice Planes]</code>, or programatically with the function below.</p> <pre><code>polyscope::SurfaceMesh* psMesh = polyscope::registerSurfaceMesh(\"input mesh\", meshV, meshF);\npolyscope::SlicePlane* psPlane = polyscope::addSceneSlicePlane();\npsMesh-&gt;setIgnoreSlicePlane(psPlane-&gt;name, true);\n</code></pre> <code>Structure* Structure::setIgnoreSlicePlane(std::string name, bool newValue)</code> <code>bool Structure::getIgnoreSlicePlane(std::string name)</code> <p>Get if a slice plane is currently being ignored by the structure.</p>"},{"location":"features/slice_planes/#ignore-plane","title":"ignore plane","text":"<p>Set a slice plane to be ignored by the structure. If <code>newValue</code> is <code>true</code> the slice plane will be ignored, and if <code>false</code> it will be respected.</p>"},{"location":"features/slice_planes/#cull-whole-elements","title":"Cull whole elements","text":"<p>For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element.  This option can be set in the GUI for each structure under <code>[Options] --&gt; [Slice Planes]</code>, or programatically with the function below.</p> <p></p> <pre><code>polyscope::SurfaceMesh* psMesh = polyscope::registerSurfaceMesh(\"input mesh\", meshV, meshF);\npolyscope::SlicePlane* psPlane = polyscope::addSceneSlicePlane();\npsMesh-&gt;setCullWholeElements(false);\n</code></pre> <code>Structure* Structure::setCullWholeElements(bool newVal)</code> <code>bool Structure::getCullWholeElements()</code> <p>Get whether the cull whole elements setting is applied.</p>"},{"location":"features/slice_planes/#set-cull-whole-elements","title":"set cull whole elements","text":"<p>If <code>true</code>, slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements.</p> <p>Note that not all structures may support culling whole elements. If not supported, this setting will do nothing.</p> <p>Default: false.</p>"},{"location":"features/slice_planes/#inspecting-volume-meshes","title":"Inspecting volume meshes","text":"<p>Slice planes can also inspect volume meshes, rendering a surface where the structure is cut by the plane. Not only does this help to visualize the interior of the shape, but scalar and color quantities can be drawn along the plane to better inspect values on the interior of the mesh.</p> <p>This can also be set in the UI under <code>[View] --&gt; [Slice Planes] --&gt; [Inspect]</code>. This option will only be available when there is at least one volume mesh in the scene.</p> <p>If the volume mesh has a vertex scalar or vertex color quantity enabled, it will be automatically drawn on the inspecting slice plane.</p> <code>void SlicePlane::setVolumeMeshToInspect(std::string meshName)</code> <p>Give the name of a volume mesh to inspect. Pass the empty string <code>\"\"</code> to clear the inspection.</p> <code>std::string SlicePlane::getVolumeMeshToInspect()</code> <p>Get the volume mesh being inspected.</p>"},{"location":"features/transparency/","title":"Transparency","text":"<p>The Polyscope rendering framework supports transparency to visualize complicated data with nested internal structures.</p> <p></p> <p>Example: register a surface mesh and render it with transparency</p> <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\npolyscope::init();\n\n/* load a mesh */\n\n// Register the mesh with Polyscope\nauto* psMesh = polyscope::registerSurfaceMesh(\"input mesh\", /* vertices */, /* faces */);\n\n// Set transparency\npsMesh-&gt;setTransparency(0.5);\n\n// Optional: change transparency rendering settings\n// polyscope::options::transparencyMode = polyscope::TransparencyMode::Simple;\n// polyscope::options::transparencyRenderPasses = 16;\n\npolyscope::show();\n</code></pre>"},{"location":"features/transparency/#transparency-modes","title":"Transparency modes","text":"<p>In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering:</p> <ul> <li><code>TransparencyMode::None</code> is the default, which does not use any transparency and ignores any related settings.</li> <li><code>TransparencyMode::Simple</code> uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use).</li> <li><code>TransparencyMode::Pretty</code> implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling, which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter <code>polyscope::options::transparencyRenderPasses</code> controls the number passes performed (default: <code>8</code>); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes.</li> </ul> <p>The modes are set in <code>options::transparencyMode</code>. Initially, the transparency mode is set to <code>TransparencyMode::None</code>. However, if the transparency of any object is modified while the mode is <code>None</code>, the mode will be automatically updated to <code>Pretty</code> so that the effect is visible.</p> <p>Any ground plane reflections are disabled when using transparency.</p> <p>The transparency mode can also be changed in the GUI in the <code>[Appearance] --&gt; [Transparency]</code> menu.</p> <code>TransparencyMode options::transparencyMode</code> <p>Set the mode used for transparent rendering. One of <code>TransparencyMode::None</code>, <code>TransparencyMode::Simple</code>, or <code>TransparencyMode::Pretty</code> (see above for explanation).</p> <p>Default: <code>None</code>. Automatically updated when a transparency value is set for some structure.</p> <code>int options::transparencyRenderPasses</code> <p>The number of passes used for <code>Transparency::Pretty</code>. Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes.</p> <p>Default: <code>8</code>. </p>"},{"location":"features/transparency/#setting-structure-transparency","title":"Setting structure transparency","text":"<p>Transparency is controlled via a real-valued parameter from <code>0</code> to <code>1</code>, commonly called \u201calpha\u201d. Setting transparency to <code>1</code> means completely opaque (the default), whereas <code>0</code> means completely transparent.  This parameter is specified on a per-structure basis via <code>Structure::setTransparency(float)</code>.  Transparency for each structure can also be modified in the GUI by selecting <code>[Options] --&gt; [Transparency]</code> for the structure.</p> <code>Structure::setTransparency(float)</code> <p>Set the transparency for a structure, <code>1</code> means completely opaque (the default), whereas <code>0</code> means completely transparent.</p> <p>Example: <pre><code>polyscope::SurfaceMesh* psMesh = registerSurfaceMesh(\"mesh\", verts, faces);\npsMesh-&gt;setTransparency(0.5);\n</code></pre></p>"},{"location":"integrations/DGtal/","title":"DGtal","text":"<p>This section demonstrates using Polyscope with DGtal for digital geometry processing. See this repository for a sample project configuration, CMAKE build system, and a quick demo!</p>"},{"location":"integrations/DGtal/#adding-a-surface","title":"Adding a surface","text":"<p>These snippets are from the example here. See that code for full setup and template definitions! <pre><code>// Initialize polyscope\npolyscope::init();\n\n// ... surface setup here, see full example...\n// create the surface\nauto primalSurface = SH3::makePrimalPolygonalSurface(c2i, surface);\n\n// Convert faces to appropriate indexed format\nstd::vector&lt;std::vector&lt;unsigned long&gt;&gt; faces;\nfor(auto &amp;face: primalSurface-&gt;allFaces())\nfaces.push_back(primalSurface-&gt;verticesAroundFace( face ));\n\n// Register pointels as a point cloud\npolyscope::registerPointCloud(\"Pointels\", primalSurface-&gt;positions());\n\n// Register surface with quadrilateral faces\nauto digsurf = polyscope::registerSurfaceMesh(\"Primal surface\", primalSurface-&gt;positions(), faces);\n\n// Set appearance parameters\ndigsurf-&gt;edgeWidth=1.0;\ndigsurf-&gt;edgeColor={1.,1.,1.};\n\n// Show the gui\npolyscope::show();\n</code></pre></p> <p>The resulting surface:</p> <p></p>"},{"location":"integrations/DGtal/#computing-surface-quantities","title":"Computing surface quantities","text":"<pre><code>// Compute some differential quantities\nparams(\"r-radius\", 5.0);\nauto normals   = SHG3::getCTrivialNormalVectors(surface, surfels, params);\nauto normalsTrivial   = SHG3::getTrivialNormalVectors(K,surfels);\nauto normalsII = SHG3::getIINormalVectors(binary_image, surfels, params);\nauto Mcurv     = SHG3::getIIMeanCurvatures(binary_image, surfels, params);\nauto Gcurv     = SHG3::getIIGaussianCurvatures(binary_image, surfels, params);\n\n// Surfel area measure\nstd::vector&lt;double&gt; areaMeasure(surfels.size());\nfor(auto i=0; i &lt; areaMeasure.size(); ++i)\nareaMeasure[i] = normalsTrivial[i].dot(normalsII[i]);\n\n\n// Add quantities for visualization \ndigsurf-&gt;addFaceVectorQuantity(\"Trivial normal vectors\", normalsTrivial);\ndigsurf-&gt;addFaceVectorQuantity(\"CTrivial normal vectors\", normals);\ndigsurf-&gt;addFaceVectorQuantity(\"II normal vectors\", normalsII);\ndigsurf-&gt;addFaceScalarQuantity(\"II mean curvature\", Mcurv);\ndigsurf-&gt;addFaceScalarQuantity(\"II Gaussian curvature\", Gcurv);\ndigsurf-&gt;addFaceScalarQuantity(\"Surfel area measure\", areaMeasure);\n\n// Show the gui\npolyscope::show();\n</code></pre> <p>The resulting curvatures:</p> <p></p> <p>The resulting normal vectors:</p> <p></p>"},{"location":"integrations/geometry_central/","title":"Geometry Central","text":"<p>This section demonstrates using Polyscope with geometry-central! Note that a few useful adaptor functions are included in <code>geometrycentral/surface/meshio.h</code>.</p> <p>See this repository for a sample project configuration and CMAKE build system.</p>"},{"location":"integrations/geometry_central/#registering-a-surface-mesh","title":"Registering a surface mesh","text":"<pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\n#include \"geometrycentral/surface/surface_mesh.h\"\n#include \"geometrycentral/surface/vertex_position_geometry.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\nusing namespace geometrycentral::surface;\n\nSurfaceMesh&amp; mesh = /* your mesh */;\nEmbeddedGeometryInterface&amp; geom = /* your geometry */;\n\n// Be sure your mesh has vertex positions available\ngeom.requireVertexPositions();\n\n// Register the mesh with polyscope\npolyscope::registerSurfaceMesh(\"myMesh\", geom.vertexPositions, mesh.getFaceVertexList());\n\n// Note: for a VertexPositionGeometry, one could instead use:\nVertexPositionGeometry&amp; posGeom = /* your geometry */;\npolyscope::registerSurfaceMesh(\"myMesh\", posGeom.inputVertexPositions, mesh.getFaceVertexList());\n</code></pre> <p>Compressed meshes</p> <p>Polyscope expects dense buffers of data, but geometry-central uses sparse and lazily allocated buffers to support fast mesh modification.</p> <p>If you are modifying your mesh, be sure to call <code>mesh-&gt;compress()</code> before registering it with Polyscope.</p> <p>Note: Geometry-central meshes must be in \u201ccompressed mode\u201d (with dense indices) to register with Polyscope. If you have deleted elements from your mesh, this may require calling <code>SurfaceMesh::compress()</code> before you register it.</p>"},{"location":"integrations/geometry_central/#meshdata-containers","title":"Meshdata containers","text":"<p>Geometry-central\u2019s <code>Meshdata&lt;&gt;</code> containers can be passed directly to Polyscope for visualization.</p> <pre><code>/* (continuing up from the Registering example above) */\n\nVertexData&lt;double&gt; myScalar = /* some scalar on vertices */;\npolyscope::getMesh(\"myMesh\")-&gt;addVertexScalarQuantity(\"myScalar\", myScalar);\n\nFaceData&lt;double&gt; otherScalar = /* another scalar on faces*/;\npolyscope::getMesh(\"myMesh\")-&gt;addFaceScalarQuantity(\"otherScalar\", otherScalar);\n\nFaceData&lt;double&gt; anotherScalar = /* another scalar on edges*/;\npolyscope::getMesh(\"myMesh\")-&gt;addEdgeScalarQuantity(\"super important edge scalar\", anotherScalar);\n\n// Containers holding `Vector3`s can be used for 3D vectors at faces and vertices\n// Example: vertex normals as computed in geometry-central\nposGeom-&gt;requireVertexNormals();\npolyscope::getMesh(\"myMesh\")-&gt;addVertexVectorQuantity(\"vertex normals\", posGeom-&gt;vertexNormals);\n</code></pre>"},{"location":"integrations/geometry_central/#custom-ordering","title":"Custom ordering","text":"<p>Geometry-central\u2019s ordering of mesh halfedges and corners is different from Polyscope\u2019s default ordering (see indexing convention). As such, you must tell Polyscope about this ordering for edge-valued, halfedge-valued or corner-valued visualizations to work properly. The geometry-central function <code>polyscopePermutations(HalfedgeMesh&amp; mesh)</code> from <code>meshio.h</code> generates the ordering data in an approriate form for Polyscope, and can be passed either at construction time or after.</p> <pre><code>polyscope::SurfaceMesh* psMesh = polyscope::registerSurfaceMesh(\"myMesh\", geom-&gt;vertexPositions, mesh-&gt;getFaceVertexList());\n\npsMesh-&gt;setAllPermutations(polyscopePermutations(*mesh));\n\n// could alternately pass polyscopePermutations(*mesh) as additional \n// last parameter of constructor\npolyscope::SurfaceMesh* psMesh = polyscope::registerSurfaceMesh(\"myMesh\", geom-&gt;vertexPositions, mesh-&gt;getFaceVertexList(),\npolyscopePermutations(*mesh));\n</code></pre>"},{"location":"integrations/geometry_central/#tangent-vector-data","title":"Tangent vector data","text":""},{"location":"integrations/geometry_central/#1-forms","title":"1-forms","text":"<p>To communicate the canonical edge orientation when passing a 1-form, use <code>polyscopeEdgeOrientations(mesh)</code> from <code>meshio.h</code>.</p> <p>Example: <pre><code>#include \"geometrycentral/surface/meshio.h\"\n\nHalfedgeMesh&amp; mesh = /* your mesh */;\nEdgeData&lt;double&gt; myForm = /* your 1-form */;\n\npolyscope::getSurfaceMesh(\"myMesh\")-&gt;\naddOneFormIntrinsicVectorQuantity(\"my form\", myForm, polyscopeEdgeOrientations(mesh));\n</code></pre></p>"},{"location":"integrations/libIGL/","title":"libIGL","text":"<p>This section demonstrates using Polyscope with libIGL.</p> <p>See this repository for a sample project configuration, CMAKE build system, and a quick demo.</p> <p>Generally, Polyscope\u2019s data adaptors work as expected with libIGL! You can simply call Polyscope functions and pass your IGL Eigen matrix types.</p>"},{"location":"integrations/libIGL/#adding-a-mesh","title":"Adding a mesh","text":"<p>Example: <pre><code>// Initialize polyscope\npolyscope::init();\n\n// Read a mesh\nigl::readOBJ(filename, meshV, meshF);\n\n// Register the mesh with Polyscope\npolyscope::registerSurfaceMesh(\"input mesh\", meshV, meshF);\n\n// Show the gui\npolyscope::show();\n</code></pre></p>"},{"location":"integrations/libIGL/#adding-mesh-quantities","title":"Adding mesh quantities","text":"<p>Adding a scalar quantity: <pre><code>using namespace Eigen;\n\n// Compute pointwise Gaussian curvature\nVectorXd K;\nigl::gaussian_curvature(meshV, meshF, K);\nSparseMatrix&lt;double&gt; M, Minv;\nigl::massmatrix(meshV, meshF, igl::MASSMATRIX_TYPE_DEFAULT, M);\nigl::invert_diag(M, Minv);\nK = (Minv * K).eval();\n\n// Add for visualization in Polyscope\npolyscope::getSurfaceMesh(\"input mesh\")-&gt;addVertexScalarQuantity(\"gaussian curvature\", K);\n</code></pre></p> <p>Adding a vector quantity: <pre><code>// Compute vertex normals\nEigen::MatrixXd N_vertices;\nigl::per_vertex_normals(meshV, meshF, N_vertices);\n\n// Add them for visualization in Polyscope\npolyscope::getSurfaceMesh(\"input mesh\")\n-&gt;addVertexVectorQuantity(\"libIGL vertex normals\", N_vertices);\n</code></pre></p>"},{"location":"integrations/openMesh/","title":"openMesh","text":"<p>This section demonstrates using Polyscope with openMesh. </p> <p>This example is from https://github.com/vijaiaeroastro/openMeshPolyscope. See the repository for a sample project configuration, build system, and a quick demo!</p> <p>Note: this example does not make use of Polyscope\u2019s templated data adaptors, but instead simply copies data in to new containers for Polyscope.</p> <p></p> <pre><code>#include &lt;OpenMesh/Core/IO/importer/ImporterT.hh&gt;\n#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;\n#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;\n#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n#include \"polyscope/curve_network.h\"\n\n// These are required for functions like get_feature_edge\nstruct simpleTraits : public OpenMesh::DefaultTraits {\nVertexAttributes(OpenMesh::Attributes::Status);\nFaceAttributes(OpenMesh::Attributes::Status | OpenMesh::Attributes::Color);\nEdgeAttributes(OpenMesh::Attributes::Status);\n};\n\ntypedef OpenMesh::TriMesh_ArrayKernelT&lt;simpleTraits&gt; simpleMesh;\n\n\n// This function unpacks openmesh data to a simpler cpp containers suitable for polyscope\nstd::pair&lt;std::vector&lt;std::array&lt;double, 3&gt;&gt;, std::vector&lt;std::array&lt;unsigned int, 3&gt;&gt;&gt;\nunpack_open_mesh(simpleMesh &amp;reference_mesh) {\nstd::vector&lt;std::array&lt;double, 3&gt; &gt; vertexPositions;\nstd::vector&lt;std::array&lt;unsigned int, 3&gt; &gt; meshConnectivity;\nfor (auto v: reference_mesh.vertices()) {\nauto current_point = reference_mesh.point(v);\nstd::array&lt;double, 3&gt; current_array_point;\ncurrent_array_point[0] = current_point[0];\ncurrent_array_point[1] = current_point[1];\ncurrent_array_point[2] = current_point[2];\nvertexPositions.push_back(current_array_point);\n}\nfor (auto f: reference_mesh.faces()) {\nstd::array&lt;unsigned int, 3&gt; current_triangle;\nunsigned int temp_index = 0;\nfor (auto fv_it = reference_mesh.fv_iter(f); fv_it.is_valid(); ++fv_it) {\ncurrent_triangle[temp_index] = fv_it-&gt;idx();\ntemp_index++;\n}\nmeshConnectivity.push_back(current_triangle);\ntemp_index = 0;\n}\nreturn std::make_pair(vertexPositions, meshConnectivity);\n}\n\n// This function ensures that only the vertices that are part of feature network are present\n// If extra vertices are present, polyscope results look weird\nstd::pair&lt;std::vector&lt;std::array&lt;double, 3&gt;&gt;, std::vector&lt;std::array&lt;unsigned int, 2&gt; &gt; &gt;\nget_feature_edges(simpleMesh &amp;reference_mesh, double feature_angle = 45.0) {\nstd::vector&lt;std::array&lt;unsigned int, 2&gt; &gt; feature_edges_global;\nstd::set&lt;unsigned int&gt; unique_vertex_ids;\nreference_mesh.find_feature_edges(feature_angle);\nstd::map&lt;unsigned int, std::array&lt;double, 3&gt; &gt; global_id_to_vertex_positions;\nfor (auto e: reference_mesh.edges()) {\nif (reference_mesh.status(e).feature()) {\nstd::array&lt;unsigned int, 2&gt; current_feature_edge;\ncurrent_feature_edge[0] = e.v0().idx();\ncurrent_feature_edge[1] = e.v1().idx();\nfeature_edges_global.push_back(current_feature_edge);\nunique_vertex_ids.insert(current_feature_edge[0]);\nunique_vertex_ids.insert(current_feature_edge[1]);\nauto vertex_one = reference_mesh.point(e.v0());\nauto vertex_two = reference_mesh.point(e.v1());\nstd::array&lt;double, 3&gt; vertex_one_array = std::array&lt;double, 3&gt;{\nvertex_one[0], vertex_one[1], vertex_one[2]\n};\nstd::array&lt;double, 3&gt; vertex_two_array = std::array&lt;double, 3&gt;{\nvertex_two[0], vertex_two[1], vertex_two[2]\n};\nglobal_id_to_vertex_positions[current_feature_edge[0]] = vertex_one_array;\nglobal_id_to_vertex_positions[current_feature_edge[1]] = vertex_two_array;\n}\n}\nstd::map&lt;unsigned int, unsigned int&gt; global_id_to_local_id;\nstd::map&lt;unsigned int, unsigned int&gt; local_id_to_global_id;\nunsigned int new_id = 0;\nfor (auto v: unique_vertex_ids) {\nglobal_id_to_local_id[v] = new_id;\nlocal_id_to_global_id[new_id] = v;\nnew_id++;\n}\nstd::vector&lt;std::array&lt;double, 3&gt; &gt; new_positions;\nstd::vector&lt;std::array&lt;unsigned int, 2&gt; &gt; new_feature_edges;\nfor (unsigned int i = 0; i &lt; new_id; ++i) {\nnew_positions.push_back(global_id_to_vertex_positions[local_id_to_global_id[i]]);\n}\nfor (unsigned int i = 0; i &lt; feature_edges_global.size(); ++i) {\nstd::array&lt;unsigned int, 2&gt; current_feature_edge;\ncurrent_feature_edge[0] = global_id_to_local_id[feature_edges_global.at(i)[0]];\ncurrent_feature_edge[1] = global_id_to_local_id[feature_edges_global.at(i)[1]];\nnew_feature_edges.push_back(current_feature_edge);\n}\nreturn std::make_pair(new_positions, new_feature_edges);\n}\n\n// This is quite useless, try to do some useful computation to visualize\nvoid initialize_random_scalar_field(simpleMesh &amp;reference_mesh, const std::string field_name) {\nOpenMesh::VPropHandleT&lt;double&gt; field_handle;\nreference_mesh.add_property(field_handle, field_name);\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution&lt;double&gt; distribution(0, 1); // define the range\nfor (auto vertex_id: reference_mesh.vertices()) {\nif (reference_mesh.status(vertex_id).deleted()) {\ncontinue;\n}\nreference_mesh.property(field_handle, vertex_id) = distribution(gen);\n}\n}\n\n// This can be extended to other entities like edge or face\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; get_vertex_scalar_quantity(simpleMesh &amp;reference_mesh, const std::string identifier) {\nstd::vector&lt;T&gt; scalar_quantity;\nOpenMesh::VPropHandleT&lt;T&gt; scalar_handle;\nreference_mesh.get_property_handle(scalar_handle, identifier);\nfor (auto v: reference_mesh.vertices()) {\nscalar_quantity.push_back(reference_mesh.property(scalar_handle, v));\n}\nreturn scalar_quantity;\n}\n\n\nint main() {\npolyscope::init();\n\n// Let's read a mesh and draw it in polyscope\nsimpleMesh input_mesh;\nOpenMesh::IO::read_mesh(input_mesh, \"../data/Bot_Shoulder.stl\");\nauto unpackOpenMesh = unpack_open_mesh(input_mesh);\npolyscope::registerSurfaceMesh(\"openMesh\", unpackOpenMesh.first,\nunpackOpenMesh.second);\n\n// Now detect the feature edges in openmesh and draw the same in polyscope\nauto featureData = get_feature_edges(input_mesh, 45.0);\nif (featureData.first.size() &gt; 0) {\npolyscope::registerCurveNetwork(\"feature_edges\", featureData.first, featureData.second);\n}\n\n// Here is an example for visualizing a scalar quantity\ninitialize_random_scalar_field(input_mesh, \"RANDOM_SCALAR\");\nauto random_scalar = get_vertex_scalar_quantity&lt;double&gt;(input_mesh, \"RANDOM_SCALAR\");\npolyscope::getSurfaceMesh(\"openMesh\")-&gt;addVertexScalarQuantity(\"VERTEX_SCALAR\", random_scalar);\n\n// Finally show it all\npolyscope::show();\n}\n</code></pre>"},{"location":"structures/structure_management/","title":"Structure Management","text":""},{"location":"structures/structure_management/#intro","title":"Intro","text":"<p>A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields.</p> <p>Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: <pre><code>polyscope::registerSurfaceMesh(\"my mesh\", vertices, faces);\n</code></pre> Then, in a distant part of your code, add a scalar function to it with: <pre><code>polyscope::getSurfaceMesh(\"my mesh\")-&gt;addScalarQuantity(\"some values\", values);\n</code></pre> This avoids the need to pass a pointer to the structure you created around your entire codebase. </p> <p>Memory management</p> <p>As a general policy, Polyscope always manages its own memory, and will take care of deleting anything it allocated. Whenever a routine returns a pointer (like <code>getStructure()</code>), it is a non-owning pointer. You should never <code>delete</code> one of these pointers. To delete a structure and free memory, see the <code>removeStructure()</code> methods below.</p>"},{"location":"structures/structure_management/#registering-structures","title":"Registering structures","text":"<p>Each structure offers a <code>register___(name, ...)</code> function (like <code>registerPointCloud()</code>) which accepts the name of the structure and the data necessary to construct it. These functions will return a <code>Structure*</code> pointer which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions.</p> <p>The general form for registering structures is below; it may be useful if you are implementing your own structures.</p> <code>bool registerStructure(Structure* structure, bool replaceIfPresent = true)</code> <p>Register a new structure with Polyscope. The structure must have a <code>Structure::name</code> which is unique amongst all registered structures of that type.</p> <p>Polyscope takes ownership of the memory when the structure is registered, and will <code>delete</code> it when no longer needed.</p> <p>Note: most users will create structures via the individual <code>registerPointCloud()</code> (etc) functions, rather than this general form.</p>"},{"location":"structures/structure_management/#accessing-structures","title":"Accessing structures","text":"<p>Polyscope offers two patterns for calling methods on a registered structure: you can either use the pointer returned after structure creation, or refer to the structure by name.</p> <p><pre><code>#include \"polyscope/surface_mesh.h\"\n\n// register a structure\npolyscope::SurfaceMesh* psMesh = polyscope::registerSurfaceMesh(\"my mesh\", vertices, faces);\n\n// access with the pointer\npsMesh-&gt;addScalarQuantity(\"some values\", values);\n\n// access by name\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addScalarQuantity(\"some values\", values);\n</code></pre> The former is concise and programmatic, while the latter avoids the need to keep track of a variable.</p> <p>As before, each structure offers a <code>get___(name)</code> method, like <code>getSurfaceMesh(name)</code> which can be used to get a pointer to the structure of that type by name. The general form below may be useful if you are implementing your own structures.</p> <code>Structure* getStructure(std::string type, std::string name = \"\")</code> <p>Get a pointer to a registered structure. The <code>type</code> must be the unique string corresponding to the structure type.</p> <p>As a convenience, if the <code>name</code> may be argument omitted only if there is exactly one structure of that type.</p> <p>If not such structure is available, <code>nullptr</code> will be returned.</p> <p>Note: most users will get structures via the individual <code>getPointCloud()</code> (etc) functions, rather than this general form.</p>"},{"location":"structures/structure_management/#removing-structures","title":"Removing structures","text":"<p>If no longer needed, structures can be removed by name or by pointer. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities.</p> <code>void removeStructure(Structure* structure, bool errorIfAbsent = true)</code> <p>Remove the specified structure and free objects associated with it.</p> <p>If <code>errorIfAbsent == true</code>, and error will be thrown if there is no such structure registered, otherwise the function will return silently.</p> <code>void removeStructure(std::string type, std::string name, bool errorIfAbsent = true)</code> <p>Identical to <code>removeStructure(Struture*)</code>, but accepts a type name and name instead.</p> <code>void removeStructure(std::string name, bool errorIfAbsent = true)</code> <p>Identical to <code>removeStructure(Struture*)</code>, but accepts a name instead. Will fail unless there is exactly one structure with the given name across all structure types.</p>"},{"location":"structures/structure_management/#structure-options","title":"Structure options","text":"<p>These basic options are shared by all structures.  Structure options are managed as persistent values, and thus will persist if a new structure is registered with the same name.</p>"},{"location":"structures/structure_management/#enabled","title":"Enabled","text":"<p>If a structure is disabled, it will be hidden from view, along with any quantities associated with that structure.</p> <code>bool Structure::isEnabled()</code> <p>Is the structure enabled?</p> <code>void Structure::setEnabled(bool newVal)</code> <p>Set the structure to be enabled or disabled.</p>"},{"location":"structures/structure_management/#transparency","title":"Transparency","text":"<p>Set the transparency parameter for the structure. <code>1</code> is fully opaque (the default), and <code>0</code> is fully transparent. When the first structure has transparency applied, transparent rendering will be automatically enabled.</p> <p>Transparency can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Transparency]</code> menu.</p> <code>float Structure::getTransparency()</code> <p>Get the transparency parameter for the structure.</p> <code>void Structure::setTransparency(float alpha)</code> <p>Set the transparancy for the structure.</p>"},{"location":"structures/structure_management/#transforms","title":"Transforms","text":"<p>Each structure has an associated spatial transform applied to it for display in the scene. The transform encodes a translation, rotation, and scaling represented as a 4x4 homogeneous matrix. Initially this transformation is just the identity transform (it does nothing), but it can be adjusted to position the structures in your scene.</p> <p>The transform can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Transform]</code> menu.</p> <code>void Structure::centerBoundingBox()</code> <p>Set the transformation such that the structure\u2019s bounding box is centered at the world origin.</p> <code>void Structure::rescaleToUnit()</code> <p>Set the transformation scaling such that the structure has length scale 1. This makes all structures roughly the same size.</p> <code>void Structure::resetTransform()</code> <p>Reset the structure\u2019s transform to be the identity transform (i.e. to do nothing).</p> <code>void Structure::setTransform(glm::mat4x4 transform)</code> <p>Set a particular transform matrix. </p> <code>void Structure::setPosition(glm::vec3 vec)</code> <p>Set the transformation matrix such that structure is transformed to the position <code>vec</code>.</p> <code>void Structure::translate(glm::vec3 vec)</code> <p>Translate the transformation matrix by offset <code>vec</code>.</p> <code>glm::mat4x4 Structure::getTransform()</code> <p>Get the current transformation matrix. </p> <code>glm::vec3 Structure::getPosition()</code> <p>Get the translation component of the transformation matrix, the position to which the structure\u2019s origin is translated.</p>"},{"location":"structures/structure_management/#slice-planes","title":"Slice planes","text":"<p>Options relating to slice planes which may be present in the scene.</p> <p>Slice plane options can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Slice Planes]</code> menu.</p> <code>Structure* Structure::setCullWholeElements(bool newVal)</code> <p>If <code>true</code>, slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements.</p> <p>Note that not all structures may support culling whole elements. If not supported, this setting will do nothing.</p> <p>Default: false.</p> <code>bool Structure::getCullWholeElements()</code> <p>Get whether the cull whole elements setting is applied.</p> <code>Structure* Structure::setIgnoreSlicePlane(std::string name, bool newValue)</code> <p>Set a slice plane to be ignored by the structure. If <code>newValue</code> is <code>true</code> the slice plane will be ignored, and if <code>false</code> it will be respected.</p> <code>bool Structure::getIgnoreSlicePlane(std::string name)</code> <p>Get if a slice plane is currently being ignored by the structure.</p>"},{"location":"structures/camera_view/basics/","title":"Camera Views","text":"<p>Use camera view structures to represent pinhole cameras in a 3D scene. Given camera locations, orientations, and field of view (intrinsics + extrinsics), Polyscope will draw a camera frame on the scene. Images quantities can be associated with the cameras and displayed on the camera frame. You can even align the interactive viewport with a selected camera.</p>    Your browser does not support the video tag.  <p>Add an Image Quantity!</p> <p>Camera views structures on their own are not so interesting; they are simplify displayed as a wireframe camera widget in the viewport.</p> <p>Try adding an Image Quantitiy to the camera view. When image quantities are added to camera view structures, they gain the additional ability to be displayed in the camera\u2019s frame.</p> <p>Example:</p> <pre><code>#include \"polyscope/camera_view.h\"\npolyscope::init();\n\n// Create a camera view from parameters\npolyscope::CameraParameters params(\npolyscope::CameraIntrinsics::fromFoVDegVerticalAndAspect(60, 2.),\npolyscope::CameraExtrinsics::fromVectors(\nglm::vec3{2., 2., 2.},      // root position\nglm::vec3{-1., 0., 0.},   // look direction \nglm::vec3{0., 1., 0.})      // up direction\n);\n\npolyscope::CameraView* cam1 = polyscope::registerCameraView(\"cam1\", params);\n\n// Set some options for the camera view\ncam1-&gt;setWidgetFocalLength(0.75);           // size of displayed widget (relative value)\ncam1-&gt;setWidgetThickness(0.25);             // thickness of widget lines\nglm::vec3 c = glm::vec3{0.25, 0.25, 0.25}; cam1-&gt;setWidgetColor(c);                    // color of widget lines\n\n\n// Add an image to be displayed in the camera frame\nint width = 600;\nint height = 300;\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; imageColor(width * height); // fill with your data\npolyscope::ColorImageQuantity* im = cam1-&gt;addColorImageQuantity(\"color image\", width, height, imageColor, polyscope::ImageOrigin::UpperLeft);\nim-&gt;setEnabled(true);\nim-&gt;setShowInCameraBillboard(true);\n\npolyscope::show(3);\n</code></pre>"},{"location":"structures/camera_view/basics/#registering-a-camera-view","title":"Registering a Camera View","text":"<p>Camera views are created from Camera Parameters.</p> <p>Note that we do not specify an image resolution for the camera view. It can hold images of any resolution, as long as the aspect ratio is right.</p> <code>CameraView* registerCameraView(std::string name, const CameraParameters&amp; params)</code> <p>Add a new camera view structure to Polyscope.</p> <ul> <li><code>params</code> is a Camera Parameters.</li> </ul> <p>As with all structures, there is also <code>getCameraView(\"name\")</code>, <code>hasCameraView(\"name\")</code>, and <code>removeCameraView(\"name\")</code>.</p>"},{"location":"structures/camera_view/basics/#updating-a-camera-view","title":"Updating a Camera View","text":"<p>You can update the parameters associated with a camera view to move it within the scene after creation.</p> <code>void CameraView::updateCameraParameters(const CameraParameters&amp; newParams)</code> <p>Update camera parameters.</p> <ul> <li><code>params</code> is a Camera Parameters.</li> </ul>"},{"location":"structures/camera_view/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? focal length size of rendered widget <code>double getWidgetFocalLength()</code> <code>setWidgetFocalLength(double newVal, bool isRelative=true)</code> yes thickness rendered widget line thickness <code>double getWidgetThickness()</code> <code>setWidgetThickness(double newVal)</code> yes color widget color <code>glm::vec3 getWidgetColor()</code> <code>setWidgetColor(glm::vec3 newVal)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/curve_network/basics/","title":"Curve Networks","text":"<p>Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network.</p> <p>Try clicking on a node or edge to see the data associated with that point!</p> <p></p>"},{"location":"structures/curve_network/basics/#registering-a-curve-network","title":"Registering a curve network","text":"<p>Curve network structures can be registered with Polyscope by passing the node position and edge indices. There are also two helpers for constructing lines and loops which only require the node locations and automatically build connectivity.</p> <p>As usual in Polyscope, the data adaptors allow these functions to accept a wide variety of data types as input\u2013 any <code>nodes</code> which are essentially a list of vectors and any <code>edges</code> which are a list of index tuples will work. The <code>std::vector&lt;&gt;</code> types in the example below are just one possibility.</p> <p>Example: add a curve network <pre><code>#include \"polyscope/curve_network.h\"\n\npolyscope::init();\n\nstd::vector&lt;glm::vec3&gt; nodes = /* some nodes */;\nstd::vector&lt;std::array&lt;size_t, 2&gt;&gt; edges = /* edges between nodes */;\n\n// Add the curve network\npolyscope::registerCurveNetwork(\"my network\", nodes, edges);\n\n// visualize!\npolyscope::show();\n</code></pre></p> <code>CurveNetwork* polyscope::registerCurveNetwork(std::string name, const P&amp; nodes, const E&amp; edges)</code> <p>Add a new curve network to polyscope</p> <ul> <li> <p><code>nodes</code> is the array of 3D point locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors. The length will be the number of nodes.</p> </li> <li> <p><code>edges</code> is the array of edges, each of which is a pair of 0-based node indices node. The type should be adaptable to an array of <code>size_t</code>-valued 2-vectors. The length will be the number of edges.</p> </li> </ul> <p>Note: the inner vector type of the <code>nodes</code> input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, <code>registerCurveNetwork2D</code> exists with the same signature. See 2D data.</p> <code>CurveNetwork* polyscope::registerCurveNetworkLine(std::string name, const P&amp; nodes)</code> <p>Add a new curve network to polyscope from a polyline of points. The connectivity will be automatically created to connect the points in order.</p> <ul> <li><code>nodes</code> is the array of 3D point locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors. The length will be the number of nodes.</li> </ul> <p>Note: the inner vector type of the <code>points</code> input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, <code>registerCurveNetworkLine2D</code> exists with the same signature. See 2D data.</p> <code>CurveNetwork* polyscope::registerCurveNetworkLoop(std::string name, const P&amp; nodes)</code> <p>Add a new curve network to polyscope from a closed loop of points. The connectivity will be automatically created to connect the points in order.</p> <ul> <li><code>nodes</code> is the array of 3D point locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors. The length will be the number of nodes.</li> </ul> <p>Note: the inner vector type of the <code>points</code> input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D curve network, <code>registerCurveNetworkLoop2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/curve_network/basics/#updating-a-curve-network","title":"Updating a curve network","text":"<p>The locations of the nodes in a curve network can be updated with the member function <code>updateNodePositions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite).</p> <code>void CurveNetwork::updateNodePositions(const V&amp; newPositions)</code> <p>Update the node positions in a curve network structure.</p> <ul> <li><code>newPositions</code> is the vector array of 3D node locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors.  The length must be equal to the current number of nodes.</li> </ul> <p>Note: <code>updatePointPositions2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/curve_network/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? radius size of rendered points and lines <code>double getRadius()</code> <code>setRadius(double newVal, bool isRelative=true)</code> yes color default color the curve network <code>glm::vec3 getColor</code> <code>setColor(glm::vec3 newVal)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/curve_network/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the nodes or edges of a curve network.</p> <p></p> <p>Example: <pre><code>#include \"polyscope/curve_network.h\"\n\nstd::vector&lt;std::array&lt;double, 3&gt;&gt; randColor(edges.size());\nfor (size_t i = 0; i &lt; edges.size(); i++) {\nrandColor[i] = {{polyscope::randomUnit(), polyscope::randomUnit(), polyscope::randomUnit()}};\n}\n\n// visualize\npolyscope::getCurveNetwork(curveNetworkName)-&gt;addEdgeColorQuantity(\"random color\", randColor);\n</code></pre></p> <code>CurveNetwork::addNodeColorQuantity(std::string name, const T&amp; values)</code> <p>Add a color quantity to the nodes of the curve network</p> <ul> <li><code>values</code> is the array of colors at nodes. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of nodes in the curve network.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <code>CurveNetwork::addEdgeColorQuantity(std::string name, const T&amp; values)</code> <p>Add a color quantity to the edges of the curve network</p> <ul> <li><code>values</code> is the array of colors at edges. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of edges in the curve network.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p>"},{"location":"structures/curve_network/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/curve_network/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar valued data at the nodes or edges of a curve network.</p> <p></p> <p>Example: <pre><code>#include \"polyscope/curve_network.h\"\n\nstd::vector&lt;double&gt; xC(nodes.size());\nfor (size_t i = 0; i &lt; nodes.size(); i++) {\nxC[i] = nodes[i].x; // (use the x coordinate as sample data)\n}\n\n// visualize\npolyscope::getCurveNetwork(curveNetworkName)-&gt;addNodeScalarQuantity(\"sample value\", xC);\n</code></pre></p> <code>CurveNetwork::addNodeScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity to the nodes of the curve network.</p> <ul> <li><code>values</code> is the array of scalars at nodes. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of nodes in the curve network.</li> </ul> <code>CurveNetwork::addEdgeScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity to the edges of the curve network.</p> <ul> <li><code>values</code> is the array of scalars at edges . The type should be adaptable to a <code>float</code> scalar array. The length should be the number of edges in the curve network.</li> </ul>"},{"location":"structures/curve_network/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/curve_network/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the nodes or edges of a curve network.</p> <p>Example: add vectors at nodes <pre><code>#include \"polyscope/curve_network.h\"\n\n// Generate random vectors as example vector data\nstd::vector&lt;glm::vec3&gt; randVec(nNodes);\nfor (size_t iN = 0; iN &lt; nNodes; iN++) {\nrandVec[iN] = glm::vec3{polyscope::randomUnit() - .5, polyscope::randomUnit() - .5, polyscope::randomUnit() - .5};\n}\n\n// Add the vector data to the curve network\npolyscope::getCurveNetwork(\"my curve\")-&gt;addNodeVectorQuantity(\"sample vectors\", randVec);\n\n// Visualize\npolyscope::show();\n</code></pre></p> <code>CurveNetwork::addNodeVectorQuantity(std::string name, const T&amp; vectors, VectorType vectorType = VectorType::STANDARD)</code> <p>Add a vector quantity to the nodes of a curve network. Vectors will be drawn with their roots at each edge.</p> <ul> <li><code>vectors</code> is the array of vectors at nodes. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of nodes in the curve network.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D curve network), <code>addNodeVectorQuantity2D</code> exists with the same signature. See 2D data.</p> <code>CurveNetwork::addEdgeVectorQuantity(std::string name, const T&amp; vectors, VectorType vectorType = VectorType::STANDARD)</code> <p>Add a vector quantity to the edges of a curve network. Vectors will be drawn with their roots at the center of each each.</p> <ul> <li><code>vectors</code> is the array of vectors at edges. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of edges in the curve network.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D curve network), <code>addEdgeVectorQuantity2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/curve_network/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>These options and behaviors are available for all types of vector quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes vector radius the radius vectors are drawn with <code>double getVectorRadius()</code> <code>setVectorRadius(double val, bool isRelative=true)</code> yes vector length vectors will be scaled so the longest is this long. ignored if <code>VectorType::Ambient</code> <code>double getVectorLengthScale()</code> <code>setVectorLengthScale(double val, bool isRelative=true)</code> yes vector color the color to draw the vectors with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/floating_quantities/basics/","title":"Basics","text":"<p>Most quantities in Polyscope are associated with a particular structure, such as a <code>PointCloudScalarQuantity</code> on a <code>PointCloud</code>. In contrast, Floating Quantities are generic quantities which can be added to any and all kinds of structures. You can also add them to the root level of the scene, not associated with any structure. </p> <p>One example of a floating quantity is an Images Quantity. You might want to visualize a single image, not specific to any structure, by adding it to the scene at the root level. Or, you might have an image associated with a particular mesh, in which case you could add the image quantity to that <code>SurfaceMesh</code> structure.</p> <p>TL;DR What are floating quantities?</p> <p>Floating quantities are quantities that are general and not specific to any kind of structure.</p> <p>You have two options for how to add them:</p> <ul> <li>Add them as standalone quantities in the scene at the root level, like <code>polyscope::addImageQuantity(...)</code>.</li> <li>Add them to any structure of any type, like <code>pointCloud-&gt;addImageQuantity(...)</code>. This can be useful to associate the quantity with a structure.</li> </ul> <p>The sub-menus to the left give the various floating quantities available.</p>"},{"location":"structures/floating_quantities/images/","title":"Images","text":"<p>Images are rectangular grids of pixel values.</p> <p>Sample: An image quantity of a majestic cat, shown here in the ImGui window display mode.</p> <p></p> <p>Floating Quantities</p> <p>Images are floating quantities, which means they can be added to the scene at the root level, or added to any kind of structure.</p> <p>See the floating quantity introduction for more info.</p> <p>Example:</p> <pre><code>#include \"polyscope/image_quantity.h\"\n#include \"polyscope/camera_view.h\"\n\npolyscope::init();\n\n// Your image data, must be populated somehow\n// Buffer layouts are assumed to be [rows, columns, components]\n// As always, Polyscope's data adaptors allow it to directly read from many\n// containers: std::vector&lt;&gt;, Eigen::MatrixXd, raw buffers, etc.\nint width = 1024;\nint height = 768;\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; imageColor(width * height);\nstd::vector&lt;std::array&lt;float, 4&gt;&gt; imageColorAlpha(width * height);\nstd::vector&lt;float&gt; imageScalar(width * height);\n\n// == Add images at the root level of the scene\n\npolyscope::ColorImageQuantity* colorImage =\npolyscope::addColorImageQuantity(\"test color image\", width, height, imageColor, polyscope::ImageOrigin::UpperLeft);\npolyscope::addColorAlphaImageQuantity(\"test color alpha image\", width, height, imageColorAlpha,\npolyscope::ImageOrigin::UpperLeft);\npolyscope::ScalarImageQuantity* scalarImage =\npolyscope::addScalarImageQuantity(\"test scalar image\", width, height, imageScalar,\npolyscope::ImageOrigin::UpperLeft);\n\n// Set some options\ncolorImage-&gt;setEnabled(true);\ncolorImage-&gt;setShowFullscreen(false);\ncolorImage-&gt;setShowInImGuiWindow(true);\nscalarImage-&gt;setColorMap(\"blues\");\nscalarImage-&gt;setMapRange({0.0, 10.0});\n\n// == Add images associated with a structure\n// Here, a camera view, you could also use a point cloud, or a mesh, etc\npolyscope::CameraView* targetView = polyscope::getCameraView(\"my view\"); // some structure you previously registered\n\npolyscope::ColorImageQuantity* colorImageView =\ntargetView-&gt;addColorImageQuantity(\"test color image\", width, height, imageColor, polyscope::ImageOrigin::UpperLeft);\ntargetView-&gt;addColorAlphaImageQuantity(\"test color alpha image\", width, height, imageColorAlpha,\npolyscope::ImageOrigin::UpperLeft);\ntargetView-&gt;addScalarImageQuantity(\"test scalar image\", width, height, imageScalar,\npolyscope::ImageOrigin::UpperLeft);\n\n// When added to a camera view, images can be displayed in the camera frame\ncolorImageView-&gt;setShowInCameraBillboard(true);\n\npolyscope::show();\n</code></pre> <p>Images vs. Render Images</p> <p>If your image happens to represent a rendering of the scene from the user\u2019s viewport (for example, from custom renderer code), check out the Render Image quantity, which offers additional functionality for view-rendered images such as depth-compositing them into the scene to layer and blend with other content.</p> <p>Camera Views</p> <p>Image quantities get special functionality when added to <code>CameraView</code> structures: they can additionally be displayed in the camera frame, aligned with the view of the scene.</p> <p>Image Array Layout</p> <p>Images are always passed as arrays of length <code>width*height</code>, flattened such that the rows are stored contiguously. For multi-channel image data like colors or normals, this becomes a <code>width*height</code> array of tuples, or a <code>width*height x 3</code> matrix, etc. The <code>ImageOrigin</code> enum controls the row layout order; most commonly the first element is the upper-left of the image.</p> <p>Remember that Polyscope\u2019s data adaptors allow many container types to be used as input. For instance, an RGB color image could be stored as a such as <code>std::vector&lt;std::array&lt;float,3&gt;&gt;</code>, with <code>.size() == width*height</code>, or an <code>Eigen::MatrixXd</code> with dimensions <code>width*height x 3</code>, etc.</p>"},{"location":"structures/floating_quantities/images/#image-origin","title":"Image Origin","text":"<p>When registering an image quantity, you also need to specify whether the image should be interpreted such that the first row is the \u201ctop\u201d row of the image (<code>ImageOrigin::UpperLeft</code>), or the first row is the \u201cbottom\u201d row of the image (<code>ImageOrigin::LowerLeft</code>). This is a confusing issue, as there are many overlapping conventions of coordinate systems and buffer layouts for images.</p> <p>Most of the time, <code>ImageOrigin::UpperLeft</code> is the right choice.</p>"},{"location":"structures/floating_quantities/images/#scalar-image-quantity","title":"Scalar Image Quantity","text":"<p>These can be called at the root level, like <code>polyscope::addScalarImageQuantity()</code>, or on a structure, like <code>cameraView-&gt;addScalarImageQuantity()</code>.</p> <code>ScalarImageQuantity* addScalarImageQuantity(std::string name, int width, int height, const T&amp; values, ImageOrigin imageOrigin, DataType type = DataType::STANDARD)</code> <p>Add an image of scalar values</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>values</code> is a flattened array of scalars values per pixel. The type should be adaptable to a <code>float</code> scalar array. See the note above about image array layouts.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> <li><code>type</code> is the scalar datatype as for other scalar quantities</li> </ul>"},{"location":"structures/floating_quantities/images/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/floating_quantities/images/#color-image-quantity","title":"Color Image Quantity","text":"<p>These can be called at the root level, like <code>polyscope::addColorImageQuantity()</code>, or on a structure, like <code>cameraView-&gt;addColorImageQuantity()</code>.</p> <code>ColorImageQuantity* addColorImageQuantity(std::string name, int width, int height, const T&amp; values_rgb, ImageOrigin imageOrigin)</code> <p>Add an image of rgb color values</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>values_rgb</code> is a flattened array of rgb values per pixel. The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <code>ColorImageQuantiy* addColorAlphaImageQuantity(std::string name, int width, int height, const T&amp; values_rgba, ImageOrigin imageOrigin)</code> <p>Add an image of rgb color values</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>values_rgba</code> is a flattened array of rgba values per pixel. The type should be adaptable to a 4-vector array of <code>float</code>s. See the note above about image array layouts.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>By default, alpha values are interpreted to be non-premultiplied. Use  <code>colorAlphaImage-&gt;setIsPremultiplied(true);</code> to directly pass premultiplied alpha images.</p>"},{"location":"structures/floating_quantities/images/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/floating_quantities/images/#image-options","title":"Image Options","text":"<p>These options are common to all images</p> Parameter Meaning Getter Setter Persistent? transparency the image transparency <code>float getTransparency()</code> <code>setTransparency(float val)</code> yes show fullscreen show in the full window, if enabled <code>bool getShowFullscreen()</code> <code>setShowFullscreen(bool val)</code> yes show in ImGui show in an ImGui UI window, if enabled <code>bool getShowInImGuiWindow()</code> <code>setShowInImGuiWindow(bool val)</code> yes show in camera billboard for <code>CameraView</code> structure only, if enabled <code>bool getShowInCameraBillboard()</code> <code>setShowInCameraBillboard(bool val)</code> yes"},{"location":"structures/floating_quantities/render_images/","title":"Render Images","text":"<p>Render images are special images which are renderings of scene through the Polyscope viewport. These are useful when using Polyscope to visualize renders from your own custom renderers, such as ray tracers, SDF-field implicit tracers, or neural field renderers.</p> <p>Render images always show the image in fullscreen viewport. Additional, depth and transparency allow the image to be composited with other scene content, so that you can still see your usual Polyscope meshes and point clouds in the scene along with the outputs of your renderer.</p> <p>Sample: A colored box and scalar torus, displayed as render images from a user\u2019s custom implicit surface renderer.</p> <p></p> <p>Floating Quantities</p> <p>Render images are floating quantities, which means they can be added to the scene at the root level, or added to any kind of structure.</p> <p>It is most common to add render image quantities at the root level. However, it might still be useful to add render images to structures, to associate the rendering with a particular structure, e.g. as a separate rendering of each point cloud in the scene.</p> <p>See the floating quantity introduction for more info.</p> <p>Image Array Layout</p> <p>Images are always passed as arrays of length <code>width*height</code>, flattened such that the rows are stored contiguously. For multi-channel image data like colors or normals, this becomes a <code>width*height</code> array of tuples, or a <code>width*height x 3</code> matrix, etc. The <code>ImageOrigin</code> enum controls the row layout order; most commonly the first element is the upper-left of the image.</p> <p>Remember that Polyscope\u2019s data adaptors allow many container types to be used as input. For instance, an RGB color image could be stored as a such as <code>std::vector&lt;std::array&lt;float,3&gt;&gt;</code>, with <code>.size() == width*height</code>, or an <code>Eigen::MatrixXd</code> with dimensions <code>width*height x 3</code>, etc.</p>"},{"location":"structures/floating_quantities/render_images/#image-origin","title":"Image Origin","text":"<p>When registering an image quantity, you also need to specify whether the image should be interpreted such that the first row is the \u201ctop\u201d row of the image (<code>ImageOrigin::UpperLeft</code>), or the first row is the \u201cbottom\u201d row of the image (<code>ImageOrigin::LowerLeft</code>). This is a confusing issue, as there are many overlapping conventions of coordinate systems and buffer layouts for images.</p> <p>Most of the time, <code>ImageOrigin::UpperLeft</code> is the right choice.</p>"},{"location":"structures/floating_quantities/render_images/#depth-render-image-quantity","title":"Depth Render Image Quantity","text":"<p>A depth render image quantity takes a depth value per-pixel, and (optionally) a world-space normal per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials.</p> <p>Example: <pre><code>size_t width = 1024; size_t height = 768;\nstd::vector&lt;float&gt; depthVals(width * height, 0.44); // placeholder data\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; normalVals(width * height, std::array&lt;float, 3&gt;{0.44, 0.55, 0.66});\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; normalValsEmpty;\n\npolyscope::DepthRenderImageQuantity* im = polyscope::addDepthRenderImageQuantity(\n\"render im depth\", width, height, depthVals, normalVals, polyscope::ImageOrigin::UpperLeft);\nim-&gt;setEnabled(true);\n\n// with no normals\npolyscope::DepthRenderImageQuantity* imNoNormal = polyscope::addDepthRenderImageQuantity(\n\"render im depth no normal\", width, height, depthVals, normalValsEmpty, polyscope::ImageOrigin::UpperLeft);\nimNoNormal-&gt;setEnabled(true);\n\npolyscope::show(3);\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <p>This can be called at the root level, like <code>polyscope::addDepthRenderImageQuantity()</code>, or on a structure, like <code>cameraView-&gt;addDepthRenderImageQuantity()</code>.</p> <code>DepthRenderImageQuantity* addDepthRenderImageQuantity(std::string name, size_t width, size_t height, const T1&amp; depthData, const T2&amp; normalData, ImageOrigin imageOrigin)</code> <p>Add a depth render image.</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>depthData</code> is a flattened array of depth scalars per pixel. Use <code>inf</code> for any pixels which missed the scene. The type should be adaptable to a <code>float</code> scalar array. See the note above about image array layouts.</li> <li><code>normalData</code> is an optional flattened array of world-space normals per pixel.  The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts. If not given, pass an empty array.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p>"},{"location":"structures/floating_quantities/render_images/#color-render-image-quantity","title":"Color Render Image Quantity","text":"<p>A color render image quantity takes a depth value per-pixel, (optionally) a world-space normal per-pixel, and a color value per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials, colored according to the given color.</p> <p>Color vs. Raw Color Render Images</p> <p>A color render image applies materials shading and lighting to the image, just like Polyscope usually does for meshes and other objects. A raw color render image does not do any additional shading, and simply displays the given colors directly onto the screen.</p> <p>Example: <pre><code>size_t width = 1024; size_t height = 768;\nstd::vector&lt;float&gt; depthVals(width * height, 0.44); // placeholder data\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; normalVals(width * height, std::array&lt;float, 3&gt;{0.44, 0.55, 0.66});\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; colorVals(width * height, std::array&lt;float, 3&gt;{0.44, 0.55, 0.66});\n\npolyscope::ColorRenderImageQuantity* im = polyscope::addColorRenderImageQuantity(\n\"render im color\", width, height, depthVals, normalVals, colorVals, polyscope::ImageOrigin::UpperLeft);\nim-&gt;setEnabled(true);\n\npolyscope::show(3);\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <p>This can be called at the root level, like <code>polyscope::addColorRenderImageQuantity()</code>, or on a structure, like <code>cameraView-&gt;addColorRenderImageQuantity()</code>.</p> <code>ColorRenderImageQuantity* addColorRenderImageQuantity(std::string name, size_t width, size_t height, const T1&amp; depthData, const T2&amp; normalData, const T3&amp; colorData, ImageOrigin imageOrigin)</code> <p>Add a depth render image, annotated with additional color values per-pixel.</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>depthData</code> is a flattened array of depth scalars per pixel. Use <code>inf</code> for any pixels which missed the scene. The type should be adaptable to a <code>float</code> scalar array . See the note above about image array layouts.</li> <li><code>normalData</code> is an optional flattened array of world-space normals per pixel.  The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts. If not given, pass an empty array.</li> <li><code>colorData</code> is a flattened array of colors per pixel.  The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p>"},{"location":"structures/floating_quantities/render_images/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/floating_quantities/render_images/#scalar-render-image-quantity","title":"Scalar Render Image Quantity","text":"<p>A scalar render image quantity takes a depth value per-pixel, (optionally) a world-space normal per-pixel, and a scalar value per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials, with the scalar value shaded and colormapped as a scalar quantity.</p> <p>Example: <pre><code>size_t width = 1024; size_t height = 768;\nstd::vector&lt;float&gt; depthVals(width * height, 0.44); // placeholder data\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; normalVals(width * height, std::array&lt;float, 3&gt;{0.44, 0.55, 0.66});\nstd::vector&lt;float&gt; scalarVals(width * height, 0.44);\n\npolyscope::ScalarRenderImageQuantity* im = polyscope::addScalarRenderImageQuantity(\n\"render im scalar\", width, height, depthVals, normalVals, scalarVals, polyscope::ImageOrigin::UpperLeft);\nim-&gt;setEnabled(true);\n\npolyscope::show(3);\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <p>This can be called at the root level, like <code>polyscope::addScalarRenderImageQuantity()</code>, or on a structure, like <code>cameraView-&gt;addScalarRenderImageQuantity()</code>.</p> <code>ScalarRenderImageQuantity* addScalarRenderImageQuantity(std::string name, size_t width, size_t height, const T1&amp; depthData, const T2&amp; normalData, const T3&amp; scalarData, ImageOrigin imageOrigin, DataType type = DataType::STANDARD)</code> <p>Add a depth render image, annotated with additional scalar values per-pixel.</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>depthData</code> is a flattened array of depth scalars per pixel. Use <code>inf</code> for any pixels which missed the scene. The type should be adaptable to a <code>float</code> scalar array. See the note above about image array layouts.</li> <li><code>normalData</code> is an optional flattened array of world-space normals per pixel.  The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts.</li> <li><code>colorData</code> is a flattened array of colors per pixel.  The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts.    </li> <li><code>imageOrigin</code> is the row origin convention, see above</li> <li><code>type</code> is the scalar datatype as for other scalar quantities</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p>"},{"location":"structures/floating_quantities/render_images/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/floating_quantities/render_images/#raw-color-render-image-quantity","title":"Raw Color Render Image Quantity","text":"<p>A raw color render image quantity takes a depth value per-pixel and a color value per-pixel. The colors will be directly displayed onscreen, with depth compositing into the scene.</p> <p>Example: <pre><code>size_t width = 1024; size_t height = 768;\nstd::vector&lt;float&gt; depthVals(width * height, 0.44); // placeholder data\nstd::vector&lt;std::array&lt;float, 3&gt;&gt; colorVals(width * height, std::array&lt;float, 3&gt;{0.44, 0.55, 0.66});\n\npolyscope::RawColorRenderImageQuantity* im = polyscope::addRawColorRenderImageQuantity(\n\"render im raw color\", width, height, depthVals, colorVals, polyscope::ImageOrigin::UpperLeft);\nim-&gt;setEnabled(true);\n\npolyscope::show(3);\n</code></pre></p> <p>Color vs. Raw Color Render Images</p> <p>A color render image applies materials shading and lighting to the image, just like Polyscope usually does for meshes and other objects. A raw color render image does not do any additional shading, and simply displays the given colors directly onto the screen.</p> <p>This can be called at the root level, like <code>polyscope::addRawColorRenderImageQuantity()</code>, or on a structure, like <code>cameraView-&gt;addRawColorRenderImageQuantity()</code>.</p> <code>RawColorRenderImageQuantity* addRawColorRenderImageQuantity(std::string name, size_t width, size_t height, const T1&amp; depthData, const T2&amp; colorData, ImageOrigin imageOrigin)</code> <p>Add a raw color render image described by pixel color and depth.</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>depthData</code> is a flattened array of depth scalars per pixel. Use <code>inf</code> for any pixels which missed the scene. The type should be adaptable to a <code>float</code> scalar array. See the note above about image array layouts.</li> <li><code>colorData</code> is a flattened array of colors per pixel.  The type should be adaptable to a 3-vector array of <code>float</code>s. See the note above about image array layouts.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p>"},{"location":"structures/floating_quantities/render_images/#raw-color-alpha-render-image-quantity","title":"Raw Color Alpha Render Image Quantity","text":"<p>Just like the above <code>ColorRenderImageQuantity</code>, but with an additional alpha channel which gets alpha-composited onto the scene.</p> <p>Example: <pre><code>size_t width = 1024; size_t height = 768;\nstd::vector&lt;float&gt; depthVals(width * height, 0.44); // placeholder data\nstd::vector&lt;std::array&lt;float, 4&gt;&gt; colorAlphaVals(width * height, std::array&lt;float, 4&gt;{0.44, 0.55, 0.66, 0.77});\n\npolyscope::RawColorAlphaRenderImageQuantity* im = polyscope::addRawColorAlphaRenderImageQuantity(\n\"render im raw color alpha\", width, height, depthVals, colorAlphaVals, polyscope::ImageOrigin::UpperLeft);\nim-&gt;setEnabled(true);\nim-&gt;setIsPremultiplied(true);\npolyscope::show(3);\n</code></pre></p> <code>RawColorAlphaRenderImageQuantity* addRawColorAlphaRenderImageQuantity(std::string name, size_t width, size_t height, const T1&amp; depthData, const T2&amp; colorData, ImageOrigin imageOrigin)</code> <p>Add a raw color render image described by RGBA pixel color and depth.</p> <ul> <li><code>width</code> and <code>height</code> are dimensions in pixels</li> <li><code>depthData</code> is a flattened array of depth scalars per pixel. Use <code>inf</code> for any pixels which missed the scene. The type should be adaptable to a <code>float</code> scalar array. See the note above about image array layouts.</li> <li><code>colorData</code> is a flattened array of rgba colors per pixel.  The type should be adaptable to a 4-vector array of <code>float</code>s. See the note above about image array layouts.</li> <li><code>imageOrigin</code> is the row origin convention, see above</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGBA values are interpreted in the range <code>[0,1]</code>.</p> <p>By default, alpha values are interpreted to be non-premultiplied. Use  <code>rawColorAlphaRenderImage-&gt;setIsPremultiplied(true);</code> to directly pass premultiplied alpha images.</p>"},{"location":"structures/floating_quantities/render_images/#render-image-options","title":"Render Image Options","text":"<p>These options are common to all render images</p> Parameter Meaning Getter Setter Persistent? transparency the image transparency <code>float getTransparency()</code> <code>setTransparency(float val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes allow compositing if true, multiple renders can composite with each other <code>bool getAllowFullscreenCompositing()</code> <code>setAllowFullscreenCompositing(bool val)</code> yes <p>Raw color render images ignore material-related settings.</p>"},{"location":"structures/point_cloud/basics/","title":"Point Clouds","text":"<p>Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points.</p> <p>As always, try clicking on a point to see the data associated with that point.</p> <p></p>"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","title":"Registering a point cloud","text":"<p>Example: a point cloud of random points <pre><code>#include \"polyscope/point_cloud.h\"\n\nstd::vector&lt;glm::vec3&gt; points;\n\n// generate points\nfor (size_t i = 0; i &lt; 3000; i++) {\npoints.push_back(\nglm::vec3{polyscope::randomUnit() - .5, polyscope::randomUnit() - .5, polyscope::randomUnit() - .5});\n}\n\n// visualize!\npolyscope::PointCloud* psCloud = polyscope::registerPointCloud(\"really great points\", points);\n\n// set some options\npsCloud-&gt;setPointRadius(0.02);\npsCloud-&gt;setPointRenderMode(polyscope::PointRenderMode::Quad);\n\n// show\npolyscope::show()\n</code></pre></p> <code>PointCloud* registerPointCloud(std::string name, const T&amp; pointPositions)</code> <p>Add a new point cloud structure to Polyscope.</p> <ul> <li><code>pointPositions</code> is the array of 3D point locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors. The length will be the number of points.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D point cloud, <code>registerPointCloud2D</code> exists with the same signature. See 2D data.</p> <p>As with all structures, there is also <code>getPointCloud(\"name\")</code>, <code>hasPointCloud(\"name\")</code>, and <code>removePointCloud(\"name\")</code>.</p>"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","title":"Updating a point cloud","text":"<p>The locations of the points in a point cloud can be updated with the member function <code>updatePointPositions(newPositions)</code>. All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one).</p> <code>void PointCloud::updatePointPositions(const V&amp; newPositions)</code> <p>Update the point positions in a point cloud structure.</p> <ul> <li><code>newPositions</code> is the vector array of 3D point locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors.  The length must be equal to the current number of points.</li> </ul> <p>Note: <code>updatePointPositions2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/point_cloud/basics/#point-render-mode","title":"Point render mode","text":"<p>By default, Polyscope renders point clouds with a sphere for each point. However, for large point clouds (for instance, &gt; 500,000 points, or on low-end hardware), this sphere rendering may become prohibitively expensive and lead to a laggy interface. As an alternative, points can be rendered as a small quad per-point, which is more efficient (for instance, it renders in real-time with 20,000,000+ points on my mid-range GPU).</p> <p></p> <p>The <code>PointRenderMode</code> specifies which style is used:</p> <ul> <li><code>PointRenderMode::Sphere</code> a small sphere is drawn for each point (default)</li> <li><code>PointRenderMode::Quad</code> a small quad is drawn for each point</li> </ul> <code>PointCloud* PointCloud::setPointRenderMode(PointRenderMode newVal)</code> <p>Set the the rendering method used to draw each point. One of <code>PointRenderMode::Sphere</code> (default) or <code>PointRenderMode::Quad</code>.</p> <p>There is also a corresponding <code>getPointRenderMode()</code>.</p>"},{"location":"structures/point_cloud/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? point radius size of rendered points <code>double getPointRadius()</code> <code>setPointRadius(double newVal, bool isRelative=true)</code> yes point color default color for point <code>glm::vec3 getPointColor()</code> <code>setPointColor(glm::vec3 newVal)</code> yes point render mode how to draw points <code>PointRenderMode getPointRenderMode()</code> <code>setPointRenderMode(PointRenderMode newVal)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/point_cloud/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the points of a point cloud.</p> <p>Example: <pre><code>#include \"polyscope/point_cloud.h\"\n\nstd::vector&lt;std::array&lt;double, 3&gt;&gt; randColor(points.size());\nfor (size_t i = 0; i &lt; points.size(); i++) {\nrandColor[i] = {{polyscope::randomUnit(), polyscope::randomUnit(), polyscope::randomUnit()}};\n}\n\n// visualize\npolyscope::getPointCloud(pointCloudName)-&gt;addColorQuantity(\"random color\", randColor);\n</code></pre></p> <code>PointCloud::addColorQuantity(std::string name, const T&amp; values)</code> <p>Add a color quantity to the point cloud.</p> <ul> <li><code>values</code> is the array of colors at points. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of points in the point cloud.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p>"},{"location":"structures/point_cloud/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/point_cloud/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the points of a point cloud.</p> <p>Example: <pre><code>#include \"polyscope/point_cloud.h\"\n\nstd::vector&lt;double&gt; xC(points.size());\nfor (size_t i = 0; i &lt; points.size(); i++) {\nxC[i] = points[i].x;\n}\n\n// visualize\npolyscope::getPointCloud(pointCloudName)-&gt;addScalarQuantity(\"xC\", xC);\n</code></pre></p> <code>PointCloud::addScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity to the point cloud.</p> <ul> <li><code>values</code> is the array of scalars at points. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of points in the point cloud.</li> </ul>"},{"location":"structures/point_cloud/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/point_cloud/variable_radius/","title":"Variable Radius","text":"<p>By default, all points in the cloud have the same radius. However, any point cloud scalar quantity can be additionally interpreted as the radius of the points. This can also be set manually in the GUI via the point cloud [Options] \u2013&gt; [Variable Radius].</p> <p></p> <p>Example: <pre><code>#include \"polyscope/point_cloud.h\"\n\n// Populate a random scalar quantity\nstd::vector&lt;double&gt; xC(points.size());\nfor (size_t i = 0; i &lt; points.size(); i++) {\nxC[i] = points[i].x;\n}\n\n// Get a reference to some point cloud\nauto psCloud = polyscope::getPointCloud(/* your point cloud name */);\n\nauto q = psCloud-&gt;addScalarQuantity(\"xC\", xC); // add the quantity\npsCloud-&gt;setPointRadiusQuantity(q); // set the quantity as the radius\n// psCloud-&gt;setPointRadiusQuantity(\"xC\"); // equivalently, the name can be used\n</code></pre></p> <p>Any negative values in the scalar quantity will be clamped to <code>0</code>. By default, values will be rescaled such that the largest corresponds to the size from the point radius option (thus, using any constant scalar quantity will make the radii identical to the default value with no radius set). This automatic scaling can be disabled by setting <code>autoScale=false</code> below.</p> <p>Reproducing radius in world units</p> <p>Remember that point clouds always have a per-structure <code>radius</code> parameter which sets a radius for all of the points in the point cloud (and can be adjusted via a slider in the GUI, or via <code>setPointRadius()</code>). This per-structure parameter makes things a little more complicated when also setting length via a scalar quantity as described here.</p> <p>By default, the structure radius parameter is still respected. The variable radius from the quantity first scaled such that the largest value is <code>1.</code>, and then is multiplied by the structure parameter to get the actual radius used for the points.</p> <p>This usually gives a reasonable visualization, but makes it difficult to set a precise radius in world units.  To properly reproduce a radius in world-coordinate units, you can circumvent autoscaling like <code>cloud-&gt;setPointRadiusQuantity(q, false)</code>. This will prevent the auto-scaling of the radii, and also ignore the structure\u2019s point radius parameter.</p> <code>void PointCloud::setPointRadiusQuantity(PointCloudScalarQuantity* quantity, bool autoScale = true)</code> <p>Set the point radius from a quantity.</p> <p>When using a radius which is a physical length in world coordinates, set <code>autoScale</code> to <code>false</code> to skip rescaling and ignore the structure\u2019s point radius parameter.</p> <code>void PointCloud::setPointRadiusQuantity(std::string name, bool autoScale = true)</code> <p>Set the point radius from a quantity by name. The quantity must be a point cloud scalar quantity add to this cloud.</p> <p>When using a radius which is a physical length in world coordinates, set <code>autoScale</code> to <code>false</code> to skip rescaling and ignore the structure\u2019s point radius parameter.</p> <code>void PointCloud::clearPointRadiusQuantity()</code> <p>Clear the point radius quantity and return to using the constant radius.</p>"},{"location":"structures/point_cloud/variable_transparency/","title":"Variable Transparency","text":"<p>You can set the transparency individually for each point in a point cloud by specifing an existing scalar quantity to serve as the transparency. This can also be set manually in the GUI via the point cloud <code>[Options] --&gt; [Variable Transparency]</code> setting.</p> <p>See the transparency section for more transparency-related options.</p> <p></p> <p>Example: <pre><code>#include \"polyscope/point_cloud.h\"\n\n// Populate a random scalar quantity\nstd::vector&lt;double&gt; xC(points.size());\nfor (size_t i = 0; i &lt; points.size(); i++) {\nxC[i] = points[i].x;\n}\n\n// Get a reference to some point cloud\nauto psCloud = polyscope::getPointCloud(/* your point cloud name */);\n\nauto q = psCloud-&gt;addScalarQuantity(\"xC\", xC); // add the quantity\npsCloud-&gt;setTransparencyQuantity(q); // set the quantity as the radius\n// psCloud-&gt;setTransparencyQuantity(\"xC\"); // equivalently, the name can be used\n</code></pre></p> <p>All values will be clamped into the <code>[0,1]</code> range. The transparency is multiplicative with any other transparency effects, such as setting the structure\u2019s global transparency value.</p> <code>void PointCloud::setTransparencyQuantity(PointCloudScalarQuantity* quantity)</code> <code>void PointCloud::setTransparencyQuantity(std::string name)</code> <p>Set the transparency quantity by name. All values will be clamped into the <code>[0,1]</code> range.</p> <p>If transparency is not already enabled, updates the transparency mode to be <code>Pretty</code>.</p> <code>void PointCloud::clearTransparencyQuantity()</code>"},{"location":"structures/point_cloud/variable_transparency/#set-transparency-quantity","title":"set transparency quantity","text":"<p>Set the transparency quantity. All values will be clamped into the <code>[0,1]</code> range.</p> <p>If transparency is not already enabled, updates the transparency mode to be <code>Pretty</code>.</p>"},{"location":"structures/point_cloud/variable_transparency/#clear-transparency-quantity","title":"clear transparency quantity","text":"<p>Clear the transparency quantity.</p>"},{"location":"structures/point_cloud/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the points of a point cloud.</p> <code>PointCloud::addVectorQuantity(std::string name, const T&amp; vectors, VectorType vectorType = VectorType::STANDARD)</code> <p>Add a vector quantity to the point cloud.</p> <ul> <li><code>vectors</code> is the array of vectors at points. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of points in the point cloud.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D point cloud), <code>addVectorQuantity2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/point_cloud/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>These options and behaviors are available for all types of vector quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes vector radius the radius vectors are drawn with <code>double getVectorRadius()</code> <code>setVectorRadius(double val, bool isRelative=true)</code> yes vector length vectors will be scaled so the longest is this long. ignored if <code>VectorType::Ambient</code> <code>double getVectorLengthScale()</code> <code>setVectorLengthScale(double val, bool isRelative=true)</code> yes vector color the color to draw the vectors with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/basics/","title":"Surface Meshes","text":"<p>Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/edges/etc of the mesh.</p> <p>Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold.  As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.</p> <p></p>"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","title":"Registering a surface mesh","text":"<p>Example: registering a surface mesh from libIGL <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n#include &lt;igl/readOBJ.h&gt;\n\n// Initialize Polyscope\npolyscope::init();\n\n// Read the mesh\nEigen::MatrixXd meshV;\nEigen::MatrixXi meshF;\nigl::readOBJ(filename, meshV, meshF);\n\n// Register the mesh with Polyscope\npolyscope::registerSurfaceMesh(\"input mesh\", meshV, meshF);\n\n// Show the GUI\npolyscope::show();\n</code></pre></p> <p>Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face.</p> <code>polyscope::registerSurfaceMesh(std::string name, const V&amp; vertexPositions, const F&amp; faceIndices)</code> <p>Add a new surface mesh structure to Polyscope.</p> <ul> <li> <p><code>vertexPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors; this allows many common types to be used as input, including <code>Eigen::MatrixXd</code> and <code>std::vector&lt;std::array&lt;double, 3&gt;&gt;</code>. The length will be the number of vertices.</p> </li> <li> <p><code>faceIndices</code> is the nested array of vertex indices for each face. The type should be adaptable to a nested array of <code>size_t</code>; this allows many common types to be used as input, including <code>Eigen::MatrixXi</code> and <code>std::vector&lt;std::array&lt;size_t, 3&gt;&gt;</code>. The outer length will be the number of faces. All indices should be valid 0-based indices in to the vertex list.</p> </li> </ul> <p>General nested lists can be used to create polygonal meshes of varying face degree, such as <code>std::vector&lt;std::vector&lt;size_t&gt;&gt;</code>. Also, passing a fixed-size 2D array of indices will work just fine, like <code>Eigen::MatrixXi</code> with <code>Fx3</code> dimensions for a triangle mesh, or <code>Fx4</code> for a quad mesh.</p> <p>Note: the inner vector type of the vertex positions must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to register a 2D surface mesh, <code>registerSurfaceMesh2D</code> exists with the same signature. See 2D data.</p> <p>Element ordering</p> <p>Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions.</p> <p>The default ordering is probably the same as yours for data on vertices, faces, and corners. However, data on edges and halfedges is much more likely to require setting an ordering.</p>"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","title":"Updating a mesh","text":"<p>The locations of the vertices in a mesh can be updated with the member function <code>updateVertexPositions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite).</p> <code>void SurfaceMesh::updateVertexPositions(const V&amp; newPositions)</code> <p>Update the vertex positions in a surface mesh structure.</p> <ul> <li><code>newPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors.  The length must be equal to the current number of vertices.</li> </ul> <p>Note: <code>updateVertexPositions2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/surface_mesh/basics/#picking","title":"Picking","text":"<p>\u201cPicking\u201d refers to selecting and inspecting elements by clicking on the object in the scene. By default only mesh vertices and faces can be selected. Edges, corners, and halfedges, become selectable only once they are used by some quantity, for instance once a per-corner quantity is registered, then it becomes possible to click on corners.</p> <p>If desired, you can manually override this behavior by calling <code>SurfaceMesh::markEdgesAsUsed()</code>, to make the structure act as if edges are in use and make the pickable, etc. The same goes for <code>SurfaceMesh::markCornersAsUsed()</code> and <code>SurfaceMesh::markHalfedgesAsUsed()</code>. If you mark edges or halfedges as used, you much also set their element ordering as described in the indexing conventions.</p>"},{"location":"structures/surface_mesh/basics/#back-face-policies","title":"Back face policies","text":"<p>The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how back faces are displayed.</p> <p></p> <ul> <li><code>BackFacePolicy::Identical</code> all faces are always rendered identically, whether viewed from the front or back</li> <li><code>BackFacePolicy::Different</code> back faces are shaded slightly darker, so they can be distinguished (this is the default)</li> <li><code>BackFacePolicy::Custom</code> back faces are shaded with a configurable color</li> <li><code>BackFacePolicy::Cull</code> back faces are culled, and not rendered at all</li> </ul> <p>The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via <code>[Options] -&gt; [Back Face Policy]</code> or programmatically with the function below.</p> <code>SurfaceMesh* SurfaceMesh::setBackFacePolicy(BackFacePolicy newPolicy)</code> <p>Set the policy for rendering oppositely-oriented back faces.</p> <ul> <li><code>newPolicy</code> is an enum giving the new policy, one of <code>BackFacePolicy::Identical</code>, <code>BackFacePolicy::Different</code>, <code>BackFacePolicy::Custom</code>, or <code>BackFacePolicy::Cull</code> as described above</li> </ul> <p>There is also a corresponding <code>getBackFacePolicy()</code>.</p> <code>SurfaceMesh* SurfaceMesh::setBackFaceColor(glm::vec3 val)</code> <p>Set the color to be used for custom back face coloring. Has no effect unless the back face policy is <code>BackFacePolicy::Custom</code>.</p> <p>There is also a corresponding <code>getBackFaceColor()</code>.</p>"},{"location":"structures/surface_mesh/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? shade smooth use smooth shading along faces or simple flat faces <code>bool isSmoothShade()</code> <code>setSmoothShade(bool isSmooth)</code> yes surface color the color of the mesh <code>glm::vec3 getSurfaceColor()</code> <code>setSurfaceColor(glm::vec3 val)</code> yes edge color the color of the edges of the mesh <code>glm::vec3 getEdgeColor()</code> <code>setEdgeColor(glm::vec3 val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>double getEdgeWidth()</code> <code>setEdgeWidth(double val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes back face policy what back face policy to use <code>BackFacePolicy getBackFacePolicy()</code> <code>setBackFacePolicy(BackFacePolicy newPolicy)</code> yes back face color back face color for the <code>Custom</code> policy <code>BackFacePolicy getBackFaceColor()</code> <code>setBackFaceColor(glm::vec3 val)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/surface_mesh/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the elements of a surface mesh.</p> <p>Example: visualizing random colors at faces <pre><code>#include \"polyscope/surface_mesh.h\"\n\n// Make some random colors\nstd::vector&lt;std::array&lt;double, 3&gt;&gt; fColor(nFaces);\nfor (size_t iF = 0; iF &lt; nFaces; iF++) {\nstd::vector&lt;size_t&gt;&amp; face = faceIndices[iF];\nfColor[iF] = {{polyscope::randomUnit(), polyscope::randomUnit(), polyscope::randomUnit()}};\n}\n\n// Visualize\npolyscope::getSurfaceMesh(\"name\")-&gt;addFaceColorQuantity(\"fColor\", fColor);\n</code></pre></p>"},{"location":"structures/surface_mesh/color_quantities/#add-colors-to-elements","title":"Add Colors to Elements","text":"<code>SurfaceMesh::addVertexColorQuantity(std::string name, const T&amp; values)</code> <p>Add a color quantity defined at the vertices of the mesh.</p> <ul> <li><code>values</code> is the array of colors at vertices. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <code>SurfaceMesh::addFaceColorQuantity(std::string name, const T&amp; values)</code> <p>Add a color quantity defined at the faces of the mesh.</p> <ul> <li><code>values</code> is the array of colors at faces. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of faces in the mesh.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p>"},{"location":"structures/surface_mesh/color_quantities/#color-texture-maps","title":"Color Texture Maps","text":"<p>Texture images define data by storing it an image grid, and using coordinates defined on the face-corners or vertices of a mesh to sample values from the image for each point on the surface.</p> <p>To visualize color data defined in texture maps, first add a Parameterization Quantity (aka UV map) defining the coordinates. Then, add a buffer of image data to be sampled from with the function below.</p> <p>Example <pre><code>polyscope::SurfaceMesh* psMesh = /* register a surface mesh */;\n\n// a UV map to use (here, dummy data)\nstd::vector&lt;glm::vec2&gt; vals(psMesh-&gt;nCorners(), {0.5, 0.6});\nauto qParam = psMesh-&gt;addParameterizationQuantity(\"param\", vals);\n\n// an image texture to use\n// (here, dummy data)\nsize_t dimX = 100;\nsize_t dimY = 150;\nstd::vector&lt;glm::vec3&gt; colorsTex(dimX * dimY, glm::vec3{.2, .3, .4});\npolyscope::SurfaceTextureColorQuantity* qColor =\npsMesh-&gt;addTextureColorQuantity(\"tColor\", *qParam, dimX, dimY, colorsTex, polyscope::ImageOrigin::UpperLeft);\nqColor-&gt;setEnabled(true);\n\npolyscope::show(3);\n</code></pre></p> <code>SurfaceTextureColorQuantity* addTextureColorQuantity(std::string name, SurfaceParameterizationQuantity&amp; param, size_t dimX, size_t dimY, const T&amp; colors, ImageOrigin imageOrigin)</code> <p>Add a color quantity defined in a texture map.</p> <ul> <li> <p><code>param</code> is a reference to a <code>SurfaceParameterizationQuantity</code>, with coordinates on <code>[0,1]</code> which will be used to sample from the image.</p> </li> <li> <p>the data, dimension, and origin arguments are the same as those used to define images. See there for details.</p> </li> </ul> <code>SurfaceTextureColorQuantity* addTextureColorQuantity(std::string name, std::string paramName, size_t dimX, size_t dimY, const T&amp; colors, ImageOrigin imageOrigin)</code> <p>Like above, but takes the reference to the parameterization quantity by name.</p>"},{"location":"structures/surface_mesh/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/distance_quantities/","title":"Distance quantities","text":"<p>Visualize distance-valued data at the elements of a surface mesh.</p> <p>Distance quantities are basicly scalars, but are visualized with alternating stripes to show distance contours.</p> <p>Example: visualizing exact geodesic distance computed via libIGL\u2019s wrappers around Kirsanov\u2019s MMP implementation. <pre><code>// Compute distance from vertex iVertexSource\nEigen::VectorXi VS, FS, VT, FT;\nVS.resize(1);\nVS &lt;&lt; iVertexSource;\nVT.setLinSpaced(meshV.rows(), 0, meshV.rows() - 1);\nEigen::VectorXd d;\nigl::exact_geodesic(meshV, meshF, VS, FS, VT, FT, d);\n\n// Add the distance quantity to the surface mesh\npolyscope::getSurfaceMesh(\"input mesh\")\n-&gt;addVertexDistanceQuantity(\n\"distance from vertex \" + std::to_string(iVertexSource), d);\n</code></pre></p>"},{"location":"structures/surface_mesh/distance_quantities/#add-distance-to-vertices","title":"Add distance to vertices","text":"<code>SurfaceMesh::addVertexDistanceQuantity(std::string name, const T&amp; values)</code> <p>Add a distance quantity defined at the vertices of the mesh.</p> <ul> <li><code>values</code> is the array of distances at vertices. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of vertices in the mesh.</li> </ul> <code>SurfaceMesh::addVertexDistanceQuantity(std::string name, const T&amp; values)</code> <p>Add a signed distance quantity defined at the vertices of the mesh.</p> <ul> <li><code>values</code> is the array of distances at vertices. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of vertices in the mesh.</li> </ul> <p>This quantity is very similar to <code>addVertexDistanceQuantity</code>, except the colormap is adjusted to scale symetrically for negative values.</p>"},{"location":"structures/surface_mesh/distance_quantities/#options","title":"Options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no stripe size the size of the stripes showing distance isolines <code>setStripeSize(double size, bool isRelative=true)</code> <code>double getStripeSize()</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/indexing_convention/","title":"Indexing Convention","text":""},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","title":"Default ordering","text":"<p>Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i\u2019th edge in a mesh?</p> <p>For vertices and faces, Polyscope only supports one order: the order of the elements used when you registered the mesh. However, for edges, halfedges, and corners it is more complicated. For these data, you should generally explicitly tell Polyscope what ordering/indexing you will be using for the data.</p> <p>The way it works is that Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d, and you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element, visualizations of data on that element will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements.</p> <p>This section describes the remedy: you can give the mesh a \u201cpermutation\u201d, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation <code>p</code> should be an array of integers, such that if <code>i</code> is the i^\\textrm{th} element in the default ordering, <code>p[i]</code> gives the index under your convention. Your data arrays will then be indexed as <code>data[p[i]]</code> when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as <code>data[p[i]]</code> is always a valid access; if the size of your index space is different, a size can also be passed in (in this case we abuse terminology: it is not technically a permutation).</p> <p>The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.</p>"},{"location":"structures/surface_mesh/indexing_convention/#vertices-and-faces","title":"Vertices and Faces","text":"<p>For vertices and faces, Polyscope only supports one order: the order of the elements used when you registered the mesh. This order is always used automatically.</p>"},{"location":"structures/surface_mesh/indexing_convention/#edges","title":"Edges","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\nsize_t vertex_B = face[ (i+1) % faceDegree ];\n\n// emit edge (vertex_A, vertex_B), if neither it nor the \n// equivalent edge (vertex_B, vertex_A) has been emitted already\n}\n}\n</code></pre> The default ordering of edges is the order in which they would be emitted by this loop.</p> <p>For edge-valued data, a permutation must be set. This is a sanity check to catch errors; for edges, it is highly unlikely that users happen to be storing their data in the same order.</p> <code>SurfaceMesh::setEdgePermutation(const T&amp; permArr, size_t expectedSize = 0)</code> <p>Set a non-standard ordering for edge-valued data on a mesh.</p> <p>The argument should be an array-like type which can be interpreted as an array integers, see input adaptors. One good choice is a <code>std::vector&lt;size_t&gt;</code>.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>permArr</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","title":"Halfedges","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face.  More formally, the ordering is equivalent to the following code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\nsize_t vertex_B = face[ (i+1) % faceDegree ];\n\n// emit halfedge (vertex_A, vertex_B)\n}\n}\n</code></pre> The default ordering of halfedges is the order in which they would be emitted by this loop.</p> <p>Arrays of halfedge-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below.</p> <code>SurfaceMesh::setHalfedgePermutation(const T&amp; permArr, size_t expectedSize = 0)</code> <p>Set a non-standard ordering for halfedge-valued data on a mesh.</p> <p>The argument should be an array-like type which can be interpreted as an array integers, see input adaptors. One good choice is a <code>std::vector&lt;size_t&gt;</code>.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>permArr</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#corners","title":"Corners","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face.  More formally, the ordering is equivalent to the following code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\n\n// emit corner in this face incident on vertex_A\n}\n}\n</code></pre> The default ordering of corners is the order in which they would be emitted by this loop.</p> <p>Arrays of corner-valued data passed for visualization will be interpted in that order, unless an alternate permutation is set as below.</p> <code>SurfaceMesh::setCornerPermutation(const T&amp; permArr, size_t expectedSize = 0)</code> <p>Set a non-standard ordering for corner-valued data on a mesh.</p> <p>The argument should be an array-like type which can be interpreted as an array integers, see input adaptors. One good choice is a <code>std::vector&lt;size_t&gt;</code>.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>permArr</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","title":"All at once","text":"<p>As a convenience, you can alternately define a single function which passes all permutations needed at the same time. This is useful because you can write a single helper function which defines any necessary permutations for the mesh convention in your codebase; see the geometry-central integration for an example.</p> <p>The permutations should be passed as a <code>std::array&lt;std::pair&lt;T,size_t&gt;,3&gt;</code>, where <code>T</code> is any type that could be used in the <code>set___Permutation()</code> functions above\u2014one good choice is a <code>std::array&lt;std::pair&lt;std::vector&lt;size_t&gt;, size_t&gt;, 3&gt;</code>.  Each entry of this array is one of the permutations listed above: [edges, halfedges, corners].  Any permutations which have <code>size() == 0</code> will be untouched. The second entry of the pair is the optional size of the target index space, as in <code>expectedSize</code> above.</p> <code>SurfaceMesh::setAllPermutations(const std::array&lt;std::pair&lt;T,size_t&gt;,3&gt;&amp; perms)</code> <p>Set all of the ordering permutations at once, as described above.</p> <p>The argument should be a <code>std::array&lt;&gt;</code> of an array-like type which can be interpreted as an array integers, see input adaptors. One good choice is a <code>std::array&lt;std::pair&lt;std::vector&lt;size_t&gt;, size_t&gt;, 3&gt;</code>.</p> <p>If the size of your index space is different from size of the default index space, the second component of each pair must give this new size. Otherwise, the second component of the pair may be set to zero, to infer the size of the index space from the maximum index given.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/misc_quantities/","title":"Misc Quantities","text":""},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","title":"Surface Graph Quantity","text":"<p>The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity.</p> <p>Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes.</p> <p>Example: drawing mesh\u2019s dual with geometry-central.</p> <p></p> <pre><code>#include \"polyscope/surface_mesh.h\"\n\n// geometry-central things\ngeom-&gt;requireFaceIndices();\n\nstd::vector&lt;Vector3&gt; positions;\nstd::vector&lt;std::array&lt;size_t, 2&gt;&gt; edgeInds;\n\n// Build the node positions\nfor (Face f : mesh-&gt;faces()) {\n\n// Compute center for face\nVector3 c = Vector3::zero();\nfor (Vertex v : f.adjacentVertices()) {\nc += geom-&gt;inputVertexPositions[v];\n}\nc /= f.degree();\n\npositions.push_back(c);\n}\n\n// Build the edge indices\nfor (Edge e : mesh-&gt;edges()) {\n\n// Connect the nodes from the two faces adjacent to each edge\nsize_t fa = geom-&gt;faceIndices[e.halfedge().face()];\nsize_t fb = geom-&gt;faceIndices[e.halfedge().twin().face()];\n\nedgeInds.push_back({fa, fb});\n}\n\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;\naddSurfaceGraphQuantity(\"dual graph\", positions, edgeInds);\n</code></pre> <code>SurfaceMesh::addSurfaceGraphQuantity(std::string name, const P&amp; nodes, const E&amp; edges)</code> <p>Add a new surface graph quantity to the structure.</p> <ul> <li><code>nodes</code> is the list of 3D positions for the graph nodes. The type should be adaptable to a list of <code>float</code>-valued 3-vectors.</li> <li><code>edges</code> is the list of edges for the graph, where each entry is two 0-based indices in to the <code>nodes</code> array. The type should be adaptable to a list of <code>size_t</code>-valued 2-vectors (aka pairs of indices).</li> </ul> <p>The resulting class has <code>color</code> and <code>radius</code> fields which can be set to adjust the appearance of the resulting graph.</p>"},{"location":"structures/surface_mesh/misc_quantities/#options","title":"Options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes radius the radius the graph is drawn with <code>double getRadius()</code> <code>setRadius(double val, bool isRelative=true)</code> yes color the color to draw the graph with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/parameterization_quantities/","title":"Parameterization Quantities","text":"<p>A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations.</p> <p><code>#include \"polyscope/surface_mesh.h\"</code></p> <p></p> <p>Example: visualizing an LSCM parameterization via libIGL <pre><code>using namespace Eigen;\nusing namespace std;\n\n// Fix two points on the boundary\nVectorXi bnd, b(2, 1);\nigl::boundary_loop(meshF, bnd);\n\nif (bnd.size() == 0) {\npolyscope::warning(\"mesh has no boundary, cannot parameterize\");\nreturn;\n}\n\nb(0) = bnd(0);\nb(1) = bnd(round(bnd.size() / 2));\nMatrixXd bc(2, 2);\nbc &lt;&lt; 0, 0, 1, 0;\n\n// LSCM parametrization\nEigen::MatrixXd V_uv;\nigl::lscm(meshV, meshF, b, bc, V_uv);\n\npolyscope::getSurfaceMesh(\"input mesh\")\n-&gt;addVertexParameterizationQuantity(\"LSCM parameterization\", V_uv);\n</code></pre></p>"},{"location":"structures/surface_mesh/parameterization_quantities/#adding","title":"Adding","text":"<code>SurfaceMesh::addParameterizationQuantity(std::string name, const T&amp; coords)</code> <p>Add a new parameterization quantity to the structure, defined at the corners of a mesh.</p> <ul> <li><code>coords</code> is the array of 2D UV coordinates at corners. The type should be adaptable to an array of <code>float</code>-valued 2-vectors. The length should be the number of corners in the mesh.</li> </ul> <code>SurfaceMesh::addVertexParameterizationQuantity(std::string name, const T&amp; coords)</code> <p>Add a new parameterization quantity to the structure, defined at the vertices of a mesh.</p> <ul> <li><code>coords</code> is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of <code>float</code>-valued 2-vectors. The length should be the number of vertices in the mesh.</li> </ul> <code>SurfaceMesh::addLocalParameterizationQuantity(std::string name, const T&amp; coords)</code> <p>Add a new parameterization quantity to the structure, defined at the vertices of a mesh. this is similar to <code>addVertexParameterizationQuantity</code>, but has preset settings for <code>style</code> and <code>type</code> which are suitable for local parameterizations about a point.</p> <ul> <li><code>coords</code> is the array of 2D UV coordinates at vertices. The type should be adaptable to an array of <code>float</code>-valued 2-vectors. The length should be the number of vertices in the mesh.</li> </ul>"},{"location":"structures/surface_mesh/parameterization_quantities/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>These options and behaviors are available for all types of parameterization quantities on any structure.</p>"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>enum class ParamVizStyle</code> has options for how parameterizations are visualized:</p> <ul> <li><code>CHECKER</code>: a two-color checker pattern</li> <li><code>GRID</code>: a grid with thin lines</li> <li><code>LOCAL_CHECK</code>: a checkboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>LOCAL_RAD</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul> <p>The function <code>SurfaceParameterizationQuantity::setStyle(ParamVizStyle newStyle)</code> can be used to programmatically change the style.</p>"},{"location":"structures/surface_mesh/parameterization_quantities/#types","title":"Types","text":"<p>The <code>enum class ParamCoordsType</code> has options that control how parameter coordinates are interpreted:</p> <ul> <li><code>UNIT</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>WORLD</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul> <p>These enums can be passed as an optional third argument when a parameterization is registered.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes style the visualization style (see above) <code>ParamVizStyle getStyle</code> <code>setStyle(ParamVizStyle style)</code> yes checker colors two colors to use for checkerboards <code>std::pair&lt;glm::vec3,glm::vec3&gt;getCheckerColors()</code> <code>setCheckerColors(std::pair&lt;glm::vec3, glm::vec3&gt; colors)</code> yes grid colors two colors to use for line and background of grid <code>std::pair&lt;glm::vec3,glm::vec3&gt;getGridColors()</code> <code>setGridColors(std::pair&lt;glm::vec3, glm::vec3&gt; colors)</code> yes checker size the width of checkers / stripes, always used as a relative value, unless the coord tpe is <code>UNIT</code> <code>double getCheckerSize()</code> <code>setCheckerSize(double val)</code> yes color map the color map to use for radial displays <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the elements of a surface mesh.</p> <p>Example: visualizing cotangent weights at edges with geometry-central <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\n// (external library, used as an example)\n#include \"geometrycentral/surface/vertex_position_geometry.h\"\nusing namespace geometrycentral::surface;\n\npolyscope::init();\n\n// Load mesh\nstd::unique_ptr&lt;HalfedgeMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geom;\n\nstd::tie(mesh, geom) = loadMesh(args::get(inputFilename));\ngeom-&gt;requireVertexPositions();\n\n\n// Register the geometry-central mesh\nauto psMesh = polyscope::registerSurfaceMesh(\"input mesh\", geom-&gt;vertexPositions, mesh-&gt;getFaceVertexList());\npsMesh-&gt;setAllPermutations(polyscopePermutations(*mesh)); // set permutations, \n// so edge data is meaningful\n\n// Build cotan weights for the mesh\ngeom-&gt;requireEdgeCotanWeights();\n\n// Visualize cotan weights\npsMesh-&gt;addEdgeScalarQuantity(\"edge cotan weights\", geom-&gt;edgeCotanWeights);\npolyscope::show();\n</code></pre></p>"},{"location":"structures/surface_mesh/scalar_quantities/#add-scalars-to-elements","title":"Add Scalars to Elements","text":"<code>SurfaceMesh::addVertexScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the vertices of the mesh.</p> <ul> <li><code>values</code> is the array of scalars at vertices. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of vertices in the mesh.</li> </ul> <code>SurfaceMesh::addFaceScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the faces of the mesh.</p> <ul> <li><code>values</code> is the array of scalars at faces. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of faces in the mesh.</li> </ul> <code>SurfaceMesh::addEdgeScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the edges of the mesh.</p> <ul> <li><code>values</code> is the array of scalars at edges. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of edges in the mesh.</li> </ul> <p>Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects.</p> <code>SurfaceMesh::addHalfedgeScalarQuantity(std::string name, const T&amp; values, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the halfedges of the mesh.</p> <ul> <li><code>values</code> is the array of scalars at halfedges. The type should be adaptable to a <code>float</code> scalar array. The length should be the number of halfedges in the mesh.</li> </ul> <p>Remember, before passing halfedge-valued data, be sure your indexing convention matches what Polyscope expects.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#scalar-texture-maps","title":"Scalar Texture Maps","text":"<p>Texture images define data by storing it an image grid, and using coordinates defined on the face-corners or vertices of a mesh to sample values from the image for each point on the surface.</p> <p>To visualize scalar data defined in texture maps, first add a Parameterization Quantity (aka UV map) defining the coordinates. Then, add a buffer of image data to be sampled from with the function below.</p> <p>The resulting scalar texture supports color mapping and all of the other usual scalar data features.</p> <p>Example <pre><code>polyscope::SurfaceMesh* psMesh = /* register a surface mesh */;\n\n// a UV map to use (here, dummy data)\nstd::vector&lt;glm::vec2&gt; vals(psMesh-&gt;nCorners(), {0.5, 0.6});\nauto qParam = psMesh-&gt;addParameterizationQuantity(\"param\", vals);\n\n// an image texture to use\n// (here, dummy data)\nsize_t dimX = 100;\nsize_t dimY = 150;\nstd::vector&lt;float&gt; valuesTex(dimX * dimY, 0.77);\npolyscope::SurfaceTextureScalarQuantity* qScalar =\npsMesh-&gt;addTextureScalarQuantity(\"tScalar\", *qParam, dimX, dimY, valuesTex, polyscope::ImageOrigin::UpperLeft);\nqScalar-&gt;setEnabled(true);\n\npolyscope::show(3);\n</code></pre></p> <code>SurfaceMesh::addTextureScalarQuantity(std::string name, SurfaceParameterizationQuantity&amp; param, size_t dimX, size_t dimY, const T&amp; data, ImageOrigin imageOrigin, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined in a texture map.</p> <ul> <li> <p><code>param</code> is a reference to a <code>SurfaceParameterizationQuantity</code>, with coordinates on <code>[0,1]</code> which will be used to sample from the image.</p> </li> <li> <p>the data, dimension, and origin arguments are the same as those used to define images. See there for details.</p> </li> </ul> <code>SurfaceMesh::addTextureScalarQuantity(std::string name, std::string paramName, size_t dimX, size_t dimY, const T&amp; data, ImageOrigin imageOrigin, DataType type = DataType::STANDARD)</code> <p>Like above, but takes the reference to the parameterization quantity by name.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/texture_map_quantities/","title":"Texture Map Quantities","text":"<p>Scalar and color texture maps can be used to define on surface meshes. See the relevant sections in the scalar and color quantity sections.</p> <ul> <li>Scalar texture maps</li> <li>Color texture maps</li> </ul>"},{"location":"structures/surface_mesh/variable_transparency/","title":"Variable Transparency","text":"<p>You can set the transparency individually for each element in a surface mesh by specifing an existing scalar quantity to serve as the transparency. This can also be set manually in the GUI via the point cloud <code>[Options] --&gt; [Variable Transparency]</code> setting.</p> <p>Per-vertex, per-face, and per-corner scalar quantities are supported for use as transparency values.</p> <p>See the transparency section for more transparency-related options.</p> <p></p> <p>All values will be clamped into the <code>[0,1]</code> range. The transparency is multiplicative with any other transparency effects, such as setting the structure\u2019s global transparency value.</p> <code>void SurfaceMesh::setTransparencyQuantity(SurfaceScalarQuantity* quantity)</code> <code>void SurfaceMesh::setTransparencyQuantity(std::string name)</code> <p>Set the transparency quantity by name. All values will be clamped into the <code>[0,1]</code> range.</p> <p>If transparency is not already enabled, updates the transparency mode to be <code>Pretty</code>.</p> <code>void SurfaceMesh::clearTransparencyQuantity()</code>"},{"location":"structures/surface_mesh/variable_transparency/#set-transparency-quantity","title":"set transparency quantity","text":"<p>Set the transparency quantity. All values will be clamped into the <code>[0,1]</code> range.</p> <p>If transparency is not already enabled, updates the transparency mode to be <code>Pretty</code>.</p>"},{"location":"structures/surface_mesh/variable_transparency/#clear-transparency-quantity","title":"clear transparency quantity","text":"<p>Clear the transparency quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the elements of a surface mesh.</p>"},{"location":"structures/surface_mesh/vector_quantities/#ambient-vectors","title":"Ambient vectors","text":"<p>Ambient vectors are \u201cstandard\u201d vectors, which have X-Y-Z vector coordinates in world space.</p> <p></p> <code>SurfaceMesh::addVertexVectorQuantity(std::string name, const T&amp; vectors, VectorType vectorType=VectorType::STANDARD)</code> <p>Add a vector quantity defined at the vertices of the mesh.</p> <ul> <li><code>vectors</code> is the array of vectors at vertices. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), <code>addVertexVectorQuantity2D</code> exists with the same signature. See 2D data.</p> <code>SurfaceMesh::addFaceVectorQuantity(std::string name, const T&amp; vectors)</code> <p>Add a vector quantity defined at the faces of the mesh.</p> <ul> <li><code>vectors</code> is the array of vectors at faces. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of faces in the mesh.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse. If you want to add 2D vectors (usually to a 2D mesh), <code>addFaceVectorQuantity2D</code> exists with the same signature. See 2D data.</p>"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","title":"Tangent vectors","text":"<p>Tangent vectors lie flat against the surface of a mesh. They are defined as 2D vector in a local 2D coordinate system at each vertex or face. We need to specify the vector itself as well as the basis vectors for the local coordinate systems.</p> <p>Example: visualizing tangent vectors with geometry-central <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\npolyscope::init();\n\n// Load mesh\nstd::unique_ptr&lt;HalfedgeMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Register the mesh with polyscope\npsMesh = polyscope::registerSurfaceMesh(\"mesh\",\ngeometry-&gt;inputVertexPositions, mesh-&gt;getFaceVertexList(),\npolyscopePermutations(*mesh));\n\n\n// Gather vertex tangent spaces\ngeometry-&gt;requireVertexTangentBasis();\nVertexData&lt;Vector3&gt; vBasisX(*mesh);\nVertexData&lt;Vector3&gt; vBasisY(*mesh);\nfor(Vertex v : mesh-&gt;vertices()) {\nvBasisX[v] = geometry-&gt;vertexTangentBasis[v][0];\nvBasisY[v] = geometry-&gt;vertexTangentBasis[v][1];\n}\n\n// Make a vector field\nVertexData&lt;Vector2&gt; vecField = /* some field */\n\n// Register the field\npolyscope::getSurfaceMesh(\"mesh\")-&gt;\naddVertexIntrinsicVectorQuantity(\"great vectors\", vecField, vBasisX, vBasisY);\n\npolyscope::show();\n</code></pre></p> <code>SurfaceMesh::addVertexTangentVectorQuantity(std::string name, const T&amp; vectors, const B1&amp; basisX, const B2&amp; basisY, int nSym=1, VectorType vectorType=VectorType::STANDARD)</code> <p>Add a tangent vector quantity defined at the vertices of the mesh.</p> <ul> <li><code>vectors</code> is the array of 2D vectors at vertices. The type should be adaptable to a 2-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> <li><code>basisX</code> is the array of 3D vectors at vertices defining the X vector of the tangent basis. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> <li><code>basisY</code> is the array of 3D vectors at vertices defining the Y vector of the tangent basis. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> <li><code>nSym</code> is a symmetry order, for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non-<code>1</code> value, nSym distinct vectors will be displayed at each element, by rotating the input vector 2*PI/nSym radians.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <code>SurfaceMesh::addFaceTangentVectorQuantity(std::string name, const T&amp; vectors, const B1&amp; basisX, const B2&amp; basisY, int nSym=1, VectorType vectorType=VectorType::STANDARD)</code> <p>Add a tangent vector quantity defined at the faces of the mesh.</p> <ul> <li><code>vectors</code> is the array of vectors at faces. The type should be adaptable to a 2-vector array of <code>float</code>s. The length should be the number of faces in the mesh.</li> <li><code>basisX</code> is the array of 3D vectors at faces defining the X vector of the tangent basis. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of faces in the mesh.</li> <li><code>basisY</code> is the array of 3D vectors at faces defining the Y vector of the tangent basis. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of faces in the mesh.</li> <li><code>nSym</code> is a symmetry order, for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non-<code>1</code> value, nSym distinct vectors will be displayed at each element, by rotating the input vector 2*PI/nSym radians.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul>"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","title":"One forms","text":"<p>One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices.</p> <code>SurfaceMesh::addOneFormTangentVectorQuantity(std::string name, const T&amp; data, const O&amp; orientations)</code> <p>Add a one-form quantity via a scalar at edges, which will be shown like a vector field.</p> <ul> <li><code>data</code> is the array of scalars at edges. The type should be adaptable to an array of <code>float</code>s. The length should be the number of edges in the mesh.</li> <li><code>orientations</code> 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. This input is an array of booleans at edges. The type should be adaptable to an array of <code>char</code>s (because <code>std::vector&lt;bool&gt;</code> is broken). The length should be the number of edges in the mesh. These booleans should be <code>true</code> if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise.</li> </ul> <p>Remember, before passing edge-valued data, be sure your indexing convention matches what Polyscope expects.</p>"},{"location":"structures/surface_mesh/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>These options and behaviors are available for all types of vector quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes vector radius the radius vectors are drawn with <code>double getVectorRadius()</code> <code>setVectorRadius(double val, bool isRelative=true)</code> yes vector length vectors will be scaled so the longest is this long. ignored if <code>VectorType::Ambient</code> <code>double getVectorLengthScale()</code> <code>setVectorLengthScale(double val, bool isRelative=true)</code> yes vector color the color to draw the vectors with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/volume_grid/basics/","title":"Volume Grids","text":"<p>Volume grid structures visualize data defined on an axis-aligned regularly-spaced 3D grid. </p> <p>As usual, first you register a volume grid, then add one or more quantities defined on that grid. Registering the grid itself just means specifying the locations of its extremal corners and the grid resolution. Then you can add data, such as scalar data as linearly-interpolated values per-node or as piecewise-constant values per-cell. Slice planes can also be used inspect the interior of the grid, isosurfaces can be extracted from scalar functions at nodes, and more. </p>    Your browser does not support the video tag.  <p>Example: registering a volume grid and adding a scalar quantity <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/volume_grid.h\"\n\npolyscope::init();\n\n// define the resolution and bounds of the grid\nuint32_t dimX = 20;\nuint32_t dimY = 20;\nuint32_t dimZ = 20;\nglm::vec3 bound_low{-3., -3., -3.};\nglm::vec3 bound_high{3., 3., 3.};\n\n// register the grid\npolyscope::VolumeGrid* psGrid = polyscope::registerVolumeGrid(\n\"sample grid\", {dimX, dimY, dimZ}, bound_low, bound_high);\n\n// add a scalar function on the grid\nuint32_t nData = dimX*dimY*dimZ;\nfloat* scalarVals = /* your dimX*dimY*dimZ buffer of data*/;\n\npolyscope::VolumeGridNodeScalarQuantity* scalarQ = psGrid-&gt;addNodeScalarQuantity(\"node scalar1\", std::make_tuple(scalarVals, nData));\nscalarQ-&gt;setEnabled(true);\n\npolyscope::show();\n</code></pre></p>"},{"location":"structures/volume_grid/basics/#registering-a-volume-grid","title":"Registering a volume grid","text":"<p>Specifying node vs. cells</p> <p>Volume grid dimensions and locations are always defined in terms of nodes (aka cell corners). The dimension is the number of nodes along each axis, and the location is defined by the extremal nodes.</p> <p>For dimensions, if you are instead thinking in terms of the number of cells (little cubical regions), add +1 to the number of cells along each dimension to get the equivalent number of nodes when registering the grid.</p> <p>For locations, the min/max bounds you specify when registering the grid are the locations up the minimum and maximum node (aka cell corner). If you are instead thinking in terms of cell center locations, shift them half-cell-width offset when registering the grid.</p> <code>polyscope::registerVolumeGrid(std::string name, glm::uvec3 gridNodeDim, glm::vec3 boundMin, glm::vec3 boundMax)</code> <p>Add a new volume grid structure to Polyscope.</p> <ul> <li><code>name</code> the name of the structure</li> <li><code>gridNodeDim</code> a <code>glm::uvec3</code> integer 3-vector giving the number of nodes in the grid along each dimension</li> <li><code>boundMin</code> a <code>glm::vec3</code> float 3-vector giving the xyz coordinates for the minimal node corner of the grid</li> <li><code>boundMax</code> a <code>glm::vec3</code> float 3-vector giving the xyz coordinates for the maximal node corner of the grid</li> </ul> <code>polyscope::registerVolumeGrid(std::string name, uint64_t gridNodeAxesDim, glm::vec3 boundMin, glm::vec3 boundMax)</code> <p>Same as above, but takes a single axis dimension which is used for all 3 axes.</p>"},{"location":"structures/volume_grid/basics/#slice-planes","title":"Slice planes","text":"<p>Slice planes are particularly useful for inspecting the internal structure of a volume grid, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.</p>"},{"location":"structures/volume_grid/basics/#picking","title":"Picking","text":"<p>\u201cPicking\u201d refers to selecting and inspecting elements by clicking on the object in the scene. Picking volume grid elements works a little differently from other structures. For most structures, each click selects an element of the structure. However for volume grids, clicking on the structure once initiates picking, then the UI continuously displays data for the location under your mouse cursor. You can always deselect the volume grid elements by clicking somewhere off the grid.</p> <p>By default, if you have only registered data defined on nodes, then only nodes can be picked (and vice-versa for cells). You can override this behavior by calling <code>VolumeGrid::markNodesAsUsed()</code>, to act as if a node quantity had been added, and likewise for <code>VolumeGrid::markCellsAsUsed()</code>.</p>"},{"location":"structures/volume_grid/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? color the color of the volume <code>glm::vec3 getColor()</code> <code>setColor(glm::vec3 val)</code> yes edge color the color of the grid edges <code>glm::vec3 getEdgeColor()</code> <code>setEdgeColor(glm::vec3 val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>double getEdgeWidth()</code> <code>setEdgeWidth(double val)</code> yes cube size factor shrink factor from 0-1 to draw gaps between cells, 0 is no shrink (default) <code>double getCubeSizeFactor()</code> <code>setCubeSizeFactor(double val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/volume_grid/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar-valued data at the nodes or cells of a volume grid.</p> <p></p> <p>Example: registering a volume grid and adding a scalar quantity <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/volume_grid.h\"\n\npolyscope::init();\n\n// define the resolution and bounds of the grid\nuint32_t dimX = 20;\nuint32_t dimY = 20;\nuint32_t dimZ = 20;\nglm::vec3 bound_low{-3., -3., -3.};\nglm::vec3 bound_high{3., 3., 3.};\n\n// register the grid\npolyscope::VolumeGrid* psGrid = polyscope::registerVolumeGrid(\n\"sample grid\", {dimX, dimY, dimZ}, bound_low, bound_high);\n\n// add a scalar function on the grid\nuint32_t nData = dimX*dimY*dimZ;\nfloat* scalarVals = /* your dimX*dimY*dimZ buffer of data*/;\n\npolyscope::VolumeGridNodeScalarQuantity* scalarQ = psGrid-&gt;addNodeScalarQuantity(\"node scalar1\", std::make_tuple(scalarVals, nData));\nscalarQ-&gt;setEnabled(true);\n\npolyscope::show();\n</code></pre></p>"},{"location":"structures/volume_grid/scalar_quantities/#add-scalars","title":"Add scalars","text":"<code>VolumeGridNodeScalarQuantity* VolumeGrid::addNodeScalarQuantity(std::string name, const T&amp; data, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the nodes of the grid.</p> <p>The data is passed as a flattened vector of length <code>nodeDimX*nodeDimY*nodeDimZ</code>, with data layout such that the X values are changing fastest. For example with 3D xyz indexing, the values would be laid out as <code>[data[0,0,0], data[1,0,0], data[2,0,0], ...]</code>, etc.</p> <ul> <li><code>data</code> is the (flattened) array of scalars at nodes. The type should be adaptable to a <code>float</code> scalar array; this includes may common types like <code>std::vector&lt;float&gt;</code> and <code>Eigen::VectorXd</code>. The length should be the number of nodes in the grid.</li> </ul> <code>VolumeGridCellScalarQuantity* VolumeMesh::addCellScalarQuantity(std::string name, const T&amp; data, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the cells of the grid.</p> <p>The data is passed as a flattened vector of length <code>cellDimX*cellDimY*cellDimZ</code>, with data layout such that the X values are changing fastest. For example with 3D xyz indexing, the values would be laid out as <code>[data[0,0,0], data[1,0,0], data[2,0,0], ...]</code>, etc.</p> <ul> <li><code>data</code> is the (flattened) array of scalars at cells. The type should be adaptable to a <code>float</code> scalar array; this includes may common types like <code>std::vector&lt;float&gt;</code> and <code>Eigen::VectorXd</code>. The length should be the number of cells in the grid.</li> </ul>"},{"location":"structures/volume_grid/scalar_quantities/#add-implicit-scalars","title":"Add implicit scalars","text":"<p>Implicit helpers</p> <p>Implicit helpers offer an easier way to interface your data with Polyscope. You define a callback function which can be called at an xyz coordinate to return a value, and pass that function as input. Polyscope then automatically takes care of calling the function at the appropriate locations to sample the function onto the grid.</p> <p>See Implicit Helpers for more details about implicit helpers, and the meaning of batch helpers.</p> <code>VolumeGridNodeScalarQuantity* VolumeGrid::addNodeScalarQuantityFromCallable(std::string name, Func&amp;&amp; func, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the nodes of the grid, sampling automatically via a callable function.</p> <ul> <li><code>func</code> is a function which takes a single <code>glm::vec3</code> world-space position as input, and returns the scalar value at that point</li> </ul> <code>VolumeGridCellScalarQuantity* VolumeGrid::addCellScalarQuantityFromCallable(std::string name, Func&amp;&amp; func, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the cells of the grid, sampling automatically via a callable function.</p> <ul> <li><code>func</code> is a function which takes a single <code>glm::vec3</code> world-space position as input, and returns the scalar value at that point</li> </ul> <code>VolumeGridNodeScalarQuantity* VolumeGrid::addNodeScalarQuantityFromBatchCallable(std::string name, Func&amp;&amp; func, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the nodes of the grid, sampling automatically via a callable function.</p> <ul> <li><code>func</code> is a function which performs a batch of evaluations of the implicit function. It should have a signature like <code>void(float* in_pos_ptr, float* out_val_ptr, size_t N)</code>. The first arg is a length-3N array of positions for queries, and the second is an (already-allocated) length-N output array of floats to write the result to. The last arg is the numbrer of queries <code>N</code>.</li> </ul> <code>VolumeGridCellScalarQuantity* VolumeGrid::addCellScalarQuantityFromBatchCallable(std::string name, Func&amp;&amp; func, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the cells of the grid, sampling automatically via a callable function.</p> <ul> <li><code>func</code> is a function which performs a batch of evaluations of the implicit function. It should have a signature like <code>void(float* in_pos_ptr, float* out_val_ptr, size_t N)</code>. The first arg is a length-3N array of positions for queries, and the second is an (already-allocated) length-N output array of floats to write the result to. The last arg is the numbrer of queries <code>N</code>.</li> </ul>"},{"location":"structures/volume_grid/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/volume_grid/scalar_quantities/#visualizing-isosurfaces","title":"Visualizing Isosurfaces","text":"<p>For a scalar values at nodes, we can additionally extract isosurfaces (aka levelsets) via the marching cubes algorithm, and visualize them as surface meshes.</p> <p></p> <p>Example: visualizing scalar isosurfaces <pre><code>/* continued after `scalarQ` has been added as in the first example above */\n\nscalarQ-&gt;setGridcubeVizEnabled(false); // hide the default grid viz\nscalarQ-&gt;setIsosurfaceLevel(0.5); // set which isosurface we will visualize\nscalarQ-&gt;setIsosurfaceVizEnabled(true); // extracts the isosurface\npolyscope::show();\n\n// add a slice plane to cut through the grid while leaving the isosurface\n// untouched, as in the screenshot above\nscalarQ-&gt;setGridcubeVizEnabled(true);\npolyscope::SlicePlane* p = polyscope::addSceneSlicePlane();\nscalarQ-&gt;setSlicePlanesAffectIsosurface(false); polyscope::show();\n\n// extract the isosurface as its own mesh structure\nscalarQ-&gt;registerIsosurfaceAsMesh(\"my isosurface mesh\");\n</code></pre></p> <p>The following settings on the <code>VolumeGridNodeScalarQuantity</code> class affect the behavior of isosurfaces. </p> <p>Note</p> <p>By default, the grid obscures the isosurface so it cannot be seen. You probably want to either:</p> <ul> <li>use a slice plane, along with the <code>setSlicePlanesAffectIsosurface(false)</code> option, or</li> <li>use <code>setGridcubeVizEnabled(false)</code> to disable the default grid visualization</li> </ul> Parameter Meaning Getter Setter Persistent? enabled is the isosurface enabled <code>bool getIsosurfaceVizEnabled()</code> <code>setIsosurfaceVizEnabled(bool)</code> yes level at what value to extract the isosurface (default: 0) <code>float getIsosurfaceLevel()</code> <code>setIsosurfaceLevel(float)</code> yes color the color of the isosurface mesh <code>glm::vec3 getIsosurfaceColor()</code> <code>setIsosurfaceColor(glm::vec3)</code> yes slice planes affect do slice planes affect the isosurface <code>bool getSlicePlanesAffectIsosurface()</code> <code>setSlicePlanesAffectIsosurface(bool)</code> yes gridcube viz enabled are the usual gridcubes rendered <code>bool getGridcubeVizEnabled()</code> <code>setGridcubeVizEnabled(bool)</code> yes <p>You can also register the isosurface as its own Polyscope surface mesh structure for further visualization.</p> <code>SurfaceMesh* VolumeGridNodeScalarQuantity::registerIsosurfaceAsMesh(std::string structureName = \"\")</code> <p>Extract the scalar function isosurface as described above, and register it as its own new <code>SurfaceMesh</code> structure.</p> <p><code></code>structureName` is the name of the newly created structure. If not given, a default name will be automatically generated.</p>"},{"location":"structures/volume_mesh/basics/","title":"Volume Meshes","text":"<p>Volumetric meshes, such as tetrahedral (tet) and hexahedral (hex, cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values.</p>    Your browser does not support the video tag."},{"location":"structures/volume_mesh/basics/#registering-a-volume-mesh","title":"Registering a volume mesh","text":"<p>Example: registering a tetrahedral mesh from libIGL <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/volume_mesh.h\"\n#include &lt;igl/readMESH.h&gt;\n\n// Initialize Polyscope\npolyscope::init();\n\n// Read mesh from file\nEigen::MatrixXd V; // vertex positions\nEigen::MatrixXi T; // tetrahedra\nEigen::MatrixXi F; // faces (we don't use these here)\nigl::readMESH(\"path/to/volume.mesh\", V, T, F);\n\n// Register the volume mesh with Polyscope\npolyscope::registerTetMesh(\"my mesh\", V, T);\n\n// Add a scalar quantity\nsize_t nVerts = V.rows();\nstd::vector&lt;double&gt; scalarV(nVerts);\nfor (size_t i = 0; i &lt; nVerts; i++) {\n// use the x-coordinate of vertex position as a test function\nscalarV[i] = V(i,0);\n}\npolyscope::getVolumeMesh(\"my mesh\")-&gt;addVertexScalarQuantity(\"scalar Q\", scalarV);\n\n// Show the GUI\npolyscope::show();\n</code></pre></p> <p>Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different variants to register meshes with tets, hexes, or a mix of the two. All of these register helpers return a pointer to a <code>polyscope::VolumeMesh</code> object which you can then add quantities to.</p> <p></p> <code>polyscope::registerTetMesh(std::string name, const V&amp; vertexPositions, const C&amp; tetIndices)</code> <p>Add a new volume mesh structure to Polyscope, with all tetrahedral elements.</p> <ul> <li> <p><code>vertexPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors; this allows many common types to be used as input, including <code>Eigen::MatrixXd</code> and <code>std::vector&lt;std::array&lt;double, 3&gt;&gt;</code>. The length will be the number of vertices.</p> </li> <li> <p><code>tetIndices</code> is the 2D array of vertex indices for each tetrahedral cell, with dimension <code>(C,4)</code> where <code>C</code> is the number of tets. The type should be adaptable to a nested array of <code>size_t</code>; this allows many common types to be used as input, including <code>Eigen::MatrixXi</code> and <code>std::vector&lt;std::array&lt;size_t, 4&gt;&gt;</code>. All indices should be valid 0-based indices in to the vertex list.</p> </li> </ul> <code>polyscope::registerHexMesh(std::string name, const V&amp; vertexPositions, const C&amp; hexIndices)</code> <p>Add a new volume mesh structure to Polyscope, with all hexahedral (cube-like) elements.</p> <ul> <li> <p><code>vertexPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors; this allows many common types to be used as input, including <code>Eigen::MatrixXd</code> and <code>std::vector&lt;std::array&lt;double, 3&gt;&gt;</code>. The length will be the number of vertices.</p> </li> <li> <p><code>hexIndices</code> is the 2D array of vertex indices for each hexahedral cell, with dimension <code>(C,8)</code> where <code>C</code> is the number of hexes. The type should be adaptable to a nested array of <code>size_t</code>; this allows many common types to be used as input, including <code>Eigen::MatrixXi</code> and <code>std::vector&lt;std::array&lt;size_t, 8&gt;&gt;</code>. All indices should be valid 0-based indices in to the vertex list.</p> </li> </ul> <code>polyscope::registerVolumeMesh(std::string name, const V&amp; vertexPositions, const C&amp; hexIndices)</code> <p>Add a new volume mesh structure to Polyscope, which may have a mix of cell types. This variant takes a rectangular array as input, where all cell rows have 8 entries, but cells with less than 8 vertices are padded with negative values.</p> <p>For instance, a row of the 2D array <code>hexIndices</code> which refers to a tet cell might hold <code>[12, 9, 22, 51, -1, -1, -1, -1]</code>.</p> <ul> <li> <p><code>vertexPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors; this allows many common types to be used as input, including <code>Eigen::MatrixXd</code> and <code>std::vector&lt;std::array&lt;double, 3&gt;&gt;</code>. The length will be the number of vertices.</p> </li> <li> <p><code>hexIndices</code> is the 2D array of vertex indices for each hexahedral cell, with dimension <code>(C,8)</code> where <code>C</code> is the number of tet/hexes. For tet elements, the rows of the array should be padded with negative indices, which will be ignored. The type should be adaptable to a nested array of <code>unsigned int</code>; this allows many common types to be used as input, including <code>Eigen::MatrixXi</code> and <code>std::vector&lt;std::array&lt;int, 8&gt;&gt;</code>. All indices should be valid 0-based indices in to the vertex list. Signed types should be used to support the negative element convention as described above.</p> </li> </ul> <code>polyscope::registerTetHexMesh(std::string name, const V&amp; vertexPositions, const Ct&amp; tetIndices, const Ct&amp; hexIndices)</code> <p>Add a new volume mesh structure to Polyscope. This variant takes a mix of tet and hex elements, where each are given in their own separate list.</p> <ul> <li> <p><code>vertexPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors; this allows many common types to be used as input, including <code>Eigen::MatrixXd</code> and <code>std::vector&lt;std::array&lt;double, 3&gt;&gt;</code>. The length will be the number of vertices.</p> </li> <li> <p><code>tetIndices</code> is the 2D array of vertex indices for each tetrahedral cell, with dimension <code>(C,4)</code> where <code>C</code> is the number of tets. The type should be adaptable to a nested array of <code>size_t</code>; this allows many common types to be used as input, including <code>Eigen::MatrixXi</code> and <code>std::vector&lt;std::array&lt;size_t, 4&gt;&gt;</code>. All indices should be valid 0-based indices in to the vertex list.</p> </li> <li> <p><code>hexIndices</code> is the 2D array of vertex indices for each hexahedral cell, with dimension <code>(C,8)</code> where <code>C</code> is the number of hexes. The type should be adaptable to a nested array of <code>size_t</code>; this allows many common types to be used as input, including <code>Eigen::MatrixXi</code> and <code>std::vector&lt;std::array&lt;size_t, 8&gt;&gt;</code>. All indices should be valid 0-based indices in to the vertex list.</p> </li> </ul> <p>For the purposes of element ordering, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells.</p> <p>No support for 2D</p> <p>Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data).</p>"},{"location":"structures/volume_mesh/basics/#updating-a-mesh","title":"Updating a mesh","text":"<p>The locations of the vertices in a mesh can be updated with the member function <code>updateVertexPositions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite).</p> <code>void VolumeMesh::updateVertexPositions(const V&amp; newPositions)</code> <p>Update the vertex positions in a volume mesh structure.</p> <ul> <li><code>newPositions</code> is the vector array of 3D vertex locations. The type should be adaptable to an array of <code>float</code>-valued 3-vectors.  The length must be equal to the current number of vertices.</li> </ul>"},{"location":"structures/volume_mesh/basics/#slice-planes","title":"Slice planes","text":"<p>Slice planes are particularly useful for inspecting the internal structure of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.</p> <p>Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.</p>"},{"location":"structures/volume_mesh/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? color the color of the outside of the volume <code>glm::vec3 getColor()</code> <code>setColor(glm::vec3 val)</code> yes interior color the color of the inside of the volume <code>glm::vec3 getInteriorColor()</code> <code>setInteriorColor(glm::vec3 val)</code> yes edge color the color of the edges of the mesh <code>glm::vec3 getEdgeColor()</code> <code>setEdgeColor(glm::vec3 val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>double getEdgeWidth()</code> <code>setEdgeWidth(double val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/volume_mesh/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing a color value at cells (here randomly generated data) <pre><code>/* ... initialization, create mesh ... */ // Register the volume mesh with Polyscope\npolyscope::registerTetMesh(\"my mesh\", verts, tets);\n\n// Add a color quantity\nsize_t nCells = tets.rows();\nstd::vector&lt;std::array&lt;double, 3&gt;&gt; randColor(nCells);\nfor (size_t i = 0; i &lt; nCells; i++) {\n// generate random colors \nrandColor[i] = {{polyscope::randomUnit(), polyscope::randomUnit(), polyscope::randomUnit()}};\n}\npolyscope::getVolumeMesh(\"my mesh\")-&gt;addCellColorQuantity(\"random color\", randColor);\n\n// Show the GUI\npolyscope::show();\n</code></pre></p>"},{"location":"structures/volume_mesh/color_quantities/#add-colors-to-elements","title":"Add colors to elements","text":"<code>VolumeMesh::addVertexColorQuantity(std::string name, const T&amp; data)</code> <p>Add a color quantity defined at the vertices of the mesh.</p> <ul> <li><code>data</code> is the array of colors at vertices. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <code>VolumeMesh::addCellColorQuantity(std::string name, const T&amp; data)</code> <p>Add a color quantity defined at the faces of the mesh.</p> <ul> <li><code>data</code> is the array of colors at faces. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of cells (tets, hexes, etc) in the mesh.</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p>"},{"location":"structures/volume_mesh/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>These options and behaviors are available for all types of color quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/volume_mesh/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing a scalar on vertices (here just one of the spatial coordinate functions) <pre><code>/* ... initialization, create mesh ... */ // Register the volume mesh with Polyscope\npolyscope::registerTetMesh(\"my mesh\", verts, tets);\n\n// Add a scalar quantity\nsize_t nVerts = verts.rows();\nstd::vector&lt;double&gt; scalarV(nVerts);\nfor (size_t i = 0; i &lt; nVerts; i++) {\n// use the x-coordinate of vertex position as a test function\nscalarV[i] = V(i,0);\n}\nauto scalarQ = polyscope::getVolumeMesh(\"my mesh\")-&gt;addVertexScalarQuantity(\"scalar Q\", scalarV);\n\n// Set some options\nscalarQ-&gt;setEnabled(true);       // initially enabled\nscalarQ-&gt;setMapRange({-1., 1.}); // colormap from [-1,1]\nscalarQ-&gt;setColorMap(\"blues\");   // use a blue colormap\n\n// Show the GUI\npolyscope::show();\n</code></pre></p>"},{"location":"structures/volume_mesh/scalar_quantities/#add-scalars-to-elements","title":"Add scalars to elements","text":"<code>VolumeMesh::addVertexScalarQuantity(std::string name, const T&amp; data, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the vertices of the mesh.</p> <ul> <li><code>data</code> is the array of scalars at vertices. The type should be adaptable to a <code>float</code> scalar array; this includes may common types like <code>std::vector&lt;float&gt;</code> and <code>Eigen::VectorXd</code>. The length should be the number of vertices in the mesh.</li> </ul> <code>VolumeMesh::addCellScalarQuantity(std::string name, const T&amp; data, DataType type = DataType::STANDARD)</code> <p>Add a scalar quantity defined at the cells of the mesh.</p> <ul> <li><code>data</code> is the array of scalars, with one value per cell. The type should be adaptable to a <code>float</code> scalar array; this includes may common types like <code>std::vector&lt;float&gt;</code> and <code>Eigen::VectorXd</code>. The length should be the number of cell in the mesh.</li> </ul>"},{"location":"structures/volume_mesh/scalar_quantities/#inspecting-with-slice-planes","title":"Inspecting with slice planes","text":"<p>Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.</p>"},{"location":"structures/volume_mesh/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>These options and behaviors are available for all types of scalar quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes color map the color map to use <code>std::string getColorMap()</code> <code>setColorMap(std::string newMap)</code> yes map range the lower and upper limits used when mapping the data in to the color map <code>std::pair&lt;double,double&gt; getMapRange()</code> <code>setMapRange(std::pair&lt;double,double&gt;)</code> and <code>resetMapRange()</code> no isolines enabled are isolines shaded (default=<code>false</code>) <code>bool getIsolinesEnabled()</code> <code>setIsolinesEnabled(bool newVal)</code> yes isoline width width of isoline stripes, in data units <code>float getIsolineWidth()</code> <code>setIsolineWidth(float newVal)</code> yes isoline darkness darkness of isoline stripes (default=<code>0.7</code>) <code>float getIsolineDarkness()</code> <code>setIsolineDarkness(float newVal)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/volume_mesh/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing vectors on vertices (here random vectors) <pre><code>/* ... initialization, create mesh ... */ // Register the volume mesh with Polyscope\npolyscope::registerTetMesh(\"my mesh\", verts, tets);\n\n// Add a vector quantity\nsize_t nVerts = V.rows();\nstd::vector&lt;std::array&lt;double, 3&gt;&gt; randVec(nVerts);\nfor (size_t i = 0; i &lt; nVerts; i++) {\n// use random vectors as test data\nrandVec[i] = {{polyscope::randomUnit() - .5, polyscope::randomUnit() - .5, polyscope::randomUnit() - .5}};\n}\nauto vectorQ = polyscope::getVolumeMesh(\"my mesh\")-&gt;addVertexVectorQuantity(\"random vec\", randVec);\n\n// Set some options\nvectorQ-&gt;setEnabled(true);           // initially enabled\nvectorQ-&gt;setVectorLengthScale(0.05); // make the vectors bigger\n\n// Show the GUI\npolyscope::show();\n</code></pre></p>"},{"location":"structures/volume_mesh/vector_quantities/#add-vectors-to-elements","title":"Add vectors to elements","text":"<code>VolumeMesh::addVertexVectorQuantity(std::string name, const T&amp; vectors, VectorType vectorType = VectorType::STANDARD)</code> <p>Add a vector quantity defined at the vertices of the mesh.</p> <ul> <li><code>vectors</code> is the array of vectors at vertices. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of vertices in the mesh.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse.</p> <code>VolumeMesh::addCellVectorQuantity(std::string name, const T&amp; vectors, VectorType vectorType = VectorType::STANDARD)</code> <p>Add a vector quantity defined at the cells of the mesh.</p> <ul> <li><code>vectors</code> is the array of vectors at cells. The type should be adaptable to a 3-vector array of <code>float</code>s. The length should be the number of cells in the mesh.</li> <li><code>vectorType</code> indicates how to interpret vector data. The default setting is as a freely-scaled value, which will be automatically scaled to be visible. Passing <code>VectorType::AMBIENT</code> ensures vectors have the proper world-space length.</li> </ul> <p>Note: the inner vector type of the input must be 3D dimensional, or you risk compiler errors, segfaults, or worse.</p>"},{"location":"structures/volume_mesh/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>These options and behaviors are available for all types of vector quantities on any structure.</p> Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes vector radius the radius vectors are drawn with <code>double getVectorRadius()</code> <code>setVectorRadius(double val, bool isRelative=true)</code> yes vector length vectors will be scaled so the longest is this long. ignored if <code>VectorType::Ambient</code> <code>double getVectorLengthScale()</code> <code>setVectorLengthScale(double val, bool isRelative=true)</code> yes vector color the color to draw the vectors with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes material what material to use <code>std::string getMaterial()</code> <code>setMaterial(std::string name)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"}]}