{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Polyscope is a C++/Python viewer and user interface for 3D data such as meshes and point clouds. It allows you to register your data and quickly generate informative and beautiful visualizations, either programmatically or via a dynamic GUI. Polyscope is designed to be lightweight\u2014it does not \u201ctake ownership\u201d over your entire program, and it is easy to integrate with existing codebases and popular libraries. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code.</p> <p>Polyscope uses a paradigm of structures and quantities. A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field.</p> <p>When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling visibility, color-mapping data and adjusting maps, \u201cpicking\u201d to click in the scene and query numerical quantities, etc.</p> <p>Note: There are two variants of this documentation, for C++ and Python. Use the buttons on the top bar to change language.</p> <p>A simple workflow for visualizing data in Polyscope looks like:</p> PythonC++ <pre><code>import polyscope as ps\n\n# Initialize polyscope\nps.init()\n\n### Register a point cloud\n# `my_points` is a Nx3 numpy array\nps.register_point_cloud(\"my points\", my_points)\n\n### Register a mesh\n# `verts` is a Nx3 numpy array of vertex positions\n# `faces` is a Fx3 array of indices, or a nested list\nps.register_surface_mesh(\"my mesh\", verts, faces, smooth_shade=True)\n\n# Add a scalar function and a vector function defined on the mesh\n# vertex_scalar is a length V numpy array of values\n# face_vectors is an Fx3 array of vectors per face\nps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"my_scalar\", \n        vertex_scalar, defined_on='vertices', cmap='blues')\nps.get_surface_mesh(\"my mesh\").add_vector_quantity(\"my_vector\", \n        face_vectors, defined_on='faces', color=(0.2, 0.5, 0.5))\n\n# View the point cloud and mesh we just registered in the 3D UI\nps.show()\n</code></pre> <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\n// Initialize polyscope\npolyscope::init();\n\n// Register a point cloud\n// `points` is a Nx3 array-like container of points\npolyscope::registerPointCloud(\"my points\", points)\n\n// Register a surface mesh structure\n// `meshVerts` is a Vx3 array-like container of vertex positions\n// `meshFaces` is a Fx3 array-like container of face indices  \npolyscope::registerSurfaceMesh(\"my mesh\", meshVerts, meshFaces);\n\n// Add a scalar and a vector function defined on the mesh\n// `scalarQuantity` is a length V array-like container of values\n// `vectorQuantity` is an Fx3 array-like container of vectors per face\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addVertexScalarQuantity(\"my_scalar\", scalarQuantity);\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addFaceVectorQuantity(\"my_vector\", vectorQuantity);\n\n// View the point cloud and mesh we just registered in the 3D UI\npolyscope::show();\n</code></pre> <p>Polyscope is designed to make your life easier. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing.</p> <p>Author: Nicholas Sharp</p> <p>If Polyscope contributes to an academic publication, cite it as: <pre><code>@misc{polyscope,\ntitle = {Polyscope},\nauthor = {Nicholas Sharp and others},\nnote = {www.polyscope.run},\nyear = {2019}\n}\n</code></pre></p> <p>Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.</p>"},{"location":"#_1","title":"Home","text":""},{"location":"FAQ/","title":"FAQ, Tips, and Tricks","text":"<ul> <li> <p>Interface</p> <ul> <li>Saving and restoring camera poses</li> <li>How do I take a screenshot / save an image?</li> <li>Positioning objects in the scene and reading back results</li> <li>Managing large numbers of structures and quantities</li> <li>How do I set up mouse click interactions and callbacks</li> </ul> </li> <li> <p>Appearance</p> <ul> <li>Visualizing colors as exact RGB values, without any shading or tonemapping</li> <li>Rendering figures for papers and presentations</li> </ul> </li> <li> <p>System</p> <ul> <li>How do I run Polyscope on a remote or headless server?</li> </ul> </li> </ul>"},{"location":"FAQ/#saving-and-restoring-camera-poses","title":"Saving and restoring camera poses","text":"<p>Use <code>look_at()</code> and other functions to manually specify the viewing camera pose. </p> <p>Or, you can interactively position the camera in the scene, copy it to your clipboard as a json string with <code>ctrl-c</code>, then restore it from the clipboard with <code>ctrl-v</code>. These strings can also be saved and restored programmatically.</p>"},{"location":"FAQ/#how-do-i-take-a-screenshot-save-an-image","title":"How do I take a screenshot / save an image?","text":"<p>See Screenshots. Call <code>screenshot()</code>, or click the <code>[screenshot]</code> button in the upper-left corner of the UI.</p>"},{"location":"FAQ/#positioning-objects-in-the-scene-and-reading-back-results","title":"Positioning objects in the scene and reading back results","text":"<p>See Transforms for various options and to set and get per-structure transformations. In the GUI, you can use the <code>[Options] --&gt; [Transform]</code> menu to enable a widget to interactively transform each object within the scene.</p>"},{"location":"FAQ/#managing-large-numbers-of-structures-and-quantities","title":"Managing large numbers of structures and quantities","text":"<p>Polyscope generally scales just fine with 100s or even 1000s of distinctly named structures in the scene. However, with this many structures, it may become difficult to select what you want in the UI. Polyscope has a few features which can help:</p> <p>Every structure has controls in its options UI menu under <code>Options --&gt; Structure Selection</code> and <code>Options --&gt; Quantity Selection</code> which can be used to enable/disable all structures and quantities, or isolate to viewing a single structure.</p> <p>Use Groups to group your structures in to categories which can be enabled/disabled all together. Notice the <code>hide descendants</code> and <code>show details</code> options on groups, which can totally hide structures from the UI while still offering some control via the group.</p> <p>You can always use the Custom UIs to create your own interface buttons and selectors which programmatically enable or disable registered objects or adjust their settings.</p>"},{"location":"FAQ/#how-do-i-set-up-mouse-click-interactions-and-callbacks","title":"How do I set up mouse click interactions and callbacks","text":"<p>See Mouse Interactions. There are no special callbacks for creating mouse events. Instead, you can implement almost any behavior you want via ImGui\u2019s built-in functions. There are also a few polyscope-specific functions to get information about scene at the location you clicked, such as constructing rays and querying depth.</p>"},{"location":"FAQ/#rendering-figures-for-papers-and-presentations","title":"Rendering figures for papers and presentations","text":"<p>Several settings can be customized to give a more polished appearance. Consider:</p> <ul> <li>Adjusting the ground plane to shadow-only for ground shadows </li> <li>Increasing antialiasing rate</li> <li>Saving screenshots with transparency for compositing</li> </ul>"},{"location":"FAQ/#visualizing-colors-as-exact-rgb-values-without-any-shading-or-tonemapping","title":"Visualizing colors as exact RGB values, without any shading or tonemapping","text":"<p>Normally, colors are shaded and tone-mapped for rendering, which means the colors and colormapped-values you specify are not exactly the colors Polyscope renders to the screen. Use the flat material to circumvent these effects, and ensure that colors are flat-shaded to the screen with exactly the RGB values specified.</p>"},{"location":"FAQ/#how-do-i-run-polyscope-on-a-remote-or-headless-server","title":"How do I run Polyscope on a remote or headless server?","text":"<p>It may not not be possible to use Polyscope on a remote headless machine which does not have a physical monitor. </p> <p>If the machine does have a display attached, there should be no problem. You can run and initialize Polyscope, and even if you are working remotely via script or SSH you can programmatically capture screenshots of the rendered scene. </p> <p>However, Polyscope will only work if it can create an operating system-level display window, which generally means having a physical monitor attached. Various virtual windowing systems and X-servers exist as a hypothetical workaround, however users have reported limited success with these tools, usually because they use software openGL renderers which do not support the openGL features required by Polyscope.</p> <p>In implementation terms, this limitation comes from needing to initialize an OpenGL 3.3 core-profile context using GLFW. Currently, GLFW can only create an openGL context when a display is present. If you find a good workaround for Polyscope on headless machines, please share! One day, we hope to implement an alternate EGL backend, which would support headless machines.</p>"},{"location":"about/bindings/","title":"Bindings","text":""},{"location":"about/bindings/#python-bindings","title":"Python bindings","text":"<p>Warning</p> <p>Python bindings are in the works! Check back soon.</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Polyscope is an open-source project, and you are encouraged to contribute! The core library is lives in this repository, with documentation here and Python bindings here.</p> <p>All contributions will be released under Polyscope\u2019s MIT license.</p> <p>How to make a great pull request:</p> <p> Implement a feature or fix a bug</p> <p> Write a new unit test and run tests</p> <p> Submit a PR and ensure automated tests pass</p> <p> Update the documentation </p> <p> Create any new Python bindings</p> <p>Of course, contributions that only do some of the above are still welcome and appreciated! But doing all of these steps means your pull request is most likely to be merged right away.</p> <p>The sections below go in to more detail on each of these steps.</p>"},{"location":"about/contributing/#c-implementation","title":"C++ implementation","text":"<p>C++ vs. Python contributions</p> <p>Polyscope is implemented as a C++ library, with a thin binding layer to Python.</p> <p>All functionality is implemented on the C++ side\u2014pull requests which implement new features solely on the Python side or using external Python dependencies generally will not be accepted. Please file an issue asking first if you are unsure! Of course, bugfixes and additions to the Python binding layer itself are an exception.</p> <p>Conversely, any new C++ features are strongly encouraged to add corresponding Python bindings! See below.</p> <p>A few general pointers:</p> <ul> <li> <p>The UI (menus, dialogs, buttons, etc) is managed using Dear ImGUI, which is very well-documented and has many resources available online.</p> </li> <li> <p>Core rendering logic and shaders are implemented in the <code>/render</code> subdirectory, particularly <code>engine.h</code>. The engine is written to abstract over rendering backends, but at the moment only openGL is supported. There is also a \u201cmock\u201d backend for testing; new rendering features should be mirrored in both <code>gl_engine.cpp</code> and <code>mock_gl_engine.cpp</code>.</p> </li> <li> <p>Polyscope shaders use a custom in-house shader builder, which performs string manipulation with a simple substitution language to build shaders at runtime which support optional features like slice planes, transparency, different quantity visualization policies, etc. The shaders themselves also explicitly track some metadata like what attributes and uniforms they require. Examples of base shaders can be found e.g. here, and substitution rules here. For any shader or rule to be available in Polyscope, it must be registered in <code>GLEngine::populateDefaultShadersAndRules()</code>, and also in the corresponding function of the mock engine for testing.</p> </li> <li> <p>If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See here for an example. Generally, this means functions which take user data should be templated, and the input then passed through <code>standardizeArray&lt;&gt;()</code> or <code>standardizeVectorArray&lt;&gt;()</code>, etc.</p> </li> <li> <p>If adding new options or parameters to a structure/quantity. Be sure to follow proper encapsulation principles (create getters &amp; setters), and use a persistent values. Check out <code>PointCloud::pointColor</code> for a good basic example.  Also, all length-valued quantities should use scaled values (as in <code>PointCloud::pointRadius</code>).</p> </li> </ul>"},{"location":"about/contributing/#unit-testing","title":"Unit testing","text":"<p>Whenever possible, add a unit test that somehow exercises any new functionality or verifies that the bug has been fixed.  Polyscope uses the googletest testing framework. See documentation there for test macros, executable options, etc.</p> <p>In a perfect world, we would actually test that the rendered output from Polyscope is pixel-perfect. However, this is hard for a lot of reasons, so instead most of our tests are just \u201csmoke tests\u201d that call functions with some dummy data and ensure no errors are thrown.</p> <p>In fact, these tests are often run on headless servers, where we cannot even initialize an openGL environment. For this reason, in addition to the usual <code>openGL</code> backend, we also have an <code>openGL_mock</code> backend (implemented here) for testing on headless servers. This backend cannot actually render anything, but still performs many rendering-related sanity checks.  If making changes to the rendering engine &amp; shaders, you may find that changes need to be mirrored in <code>mock_gl_engine.cpp</code>.</p> <p>To run unit tests locally on your own machine (here, via unix terminal commands), use</p> <pre><code>cd test\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake -j4 \n./bin/polyscope-test backend=openGL3_glfw\n</code></pre> <p>which should create a window onscreen and run tests for a few seconds.</p> <p>Additionally, run the tests again like</p> <pre><code>./bin/polyscope-test </code></pre> <p>which will use the <code>openGL_mock</code> backend (you will not see anything onscreen). This is how testing will be performed on the headless CI servers. If both sets of tests pass without errors, you are good to go.</p>"},{"location":"about/contributing/#prs-automated-tests","title":"PRs &amp; automated tests","text":"<p>Once your feature seems ready and unit tests are passing, submit a pull request to the main repository. This will trigger continuous integration (CI) tests via Github Actions to automatically compile the code on a collection of windows/mac/linux machines with various compilers, and verify that tests pass. If there are any issues, a failed \u201ccheck\u201d will show on the pull request page which you can click to learn more.</p> <p>If this is your first contribution to Polyscope, a maintainer will need to manually approve the CI run (this is a github restriction).</p> <p>You are welcome to reach out in the PR chat to sort out any problems. We may request changes! If a PR ever goes more than a few days without a response feel free to ping @nmwsharp.</p>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is hosted in its own separate repository. Polyscope docs use the mkdocs documentation engine, with the mkdocs-material theme (this theme is quite large and adds significant functionality beyond base mkdocs). The documentation is written in a large collection of markdown files; it is not automatically scraped from the code, or code comments, etc, so we must manually keep it up to date.</p> <p>There are two duplicate copies of all the docs for C++ and Python, stored in parallel directories <code>/cpp</code> and <code>/py</code>. A few shared files and assets are stored in the <code>/shared</code> directory, or symlinked from the <code>/py</code> subdirectory to point to a file the <code>/cpp</code> directory. We try to keep these two parallel versions in sync as much as possible, only differing where necessary between C++ and Python.</p> <p>To preview the documentation while editing, first install the necessary packages with <code>pip install mkdocs mkdocs-material==6.2.8 mkdocs-macros-plugin pygments</code>. Then run <code>python3 -m mkdocs serve</code> (run this command from the <code>/cpp</code> directory to view C++ docs, and likewise for <code>/py</code>). A local address will be printed to your terminal, which you can navigate to in-browser to see the docs.</p> <p>Hopefully editing the docs markdown files should be self-evident, you can mainly copy existing content &amp; formatting. Any new files need to be added the manifests in <code>mkdocs.yml</code>.  Don\u2019t forget to add a blurb to the release notes! </p> <p>If you are not able to build the docs for any reason, it is fine to just edit the markdown files and submit a docs PR with that.</p> <p>To actually update the hosted documentation files online at polyscope.run, the documentation site needs to be recompiled and committed to the to the <code>/docs</code> subdirectory. The <code>build_commit_push.sh</code> script can handle this for you, rebuilding both C++ &amp; Python docs and committing the result to the <code>/docs</code> subdirectory:</p> <pre><code>sh build_commit_push.sh\n</code></pre> <p>If you include these built docs changes in your PR, the webpage will automatically update when it is merged. Otherwise the maintainers (usually @nmwsharp) will need to run this command and commit the update after accepting your PR.</p>"},{"location":"about/contributing/#python-bindings","title":"Python bindings","text":"<p>Python bindings for Polyscope are stored in their own separate repository. We use pybind11 to generate bindings. These bindings are kept as thin wrappers as much as possible, just doing a minimal translation between the C++ interface and typical Python calling conventions.</p> <p>The bindings are actually managed internally as two separate Python packages: <code>polyscope_bindings</code> (which contains the raw bindings generated by our pybind11 code), and the higher-level <code>polyscope</code> (which contains the actual, nice user-facing Python functions). The separation is because there is no way to write additional Python code in the pybind11-generated package, but we often want to do some translation and error checking on the Python side before invoking the bindings. As such, adding a binding generally means writing code in two places:</p> <ol> <li>Add a new pybind11 C++ binding, like those here</li> <li>Add a new Python wrapper function which calls the generated binding, like the ones here</li> </ol> <p>Note that a few stylistic conventions between Python and C++. In particular, we do not expose classes for quantities, but set options via optional keyword arguments when the quantity is added. The pybind11 C++ bindings take Eigen arrays as arguments, because pybind11 performs automatic translation between Eigen/numpy.</p> <p>Python binding unit tests are stored in <code>/test/polyscope_test.py</code>. As with C++, these are mainly just simple \u201csmoke tests\u201d which call the functions with dummy data and ensure no errors are thrown. All new bindings functions need a test! To build and test the bindings, first compile the bindings from the <code>polyscope-py</code> root directory like <pre><code>mkdir build\ncd build\ncmake ..\nmake -j8\n</code></pre> the run <code>python polyscope_test.py</code>. As you write code, these bindings must be recompiled to reflect any changes to the pybind11 C++. When testing, make sure there is not another copy of Polyscope for Python installed in your system, which might unintentionally be used instead of the development version! Also, the adjacent <code>demo_app.py</code> can be used for simple testing.</p> <p>Don\u2019t forget, the Python bindings have a parallel set of docs in the <code>/py</code> directory. Updates to Python should be reflected there.</p> <p>When all your tests are passing, create a pull request! As with C++, submitting a pull request to the Python bindings will trigger a cloud build and some automated checks.</p> <p>Actually deploying a new Python version to <code>pip</code> and <code>conda</code> package managers is a somewhat significant process, so we typically group together updates before cutting a new version.  Ping @nmwsharp to get a new version deployed.  Major and minor versions of the Python library are kept in-sync with the C++ library versions, whereas patch versions (<code>1.2.4</code> \u2013&gt; <code>1.2.5</code>) are used for new updates to the Python bindings only.</p>"},{"location":"about/dependencies/","title":"Dependencies","text":"<p>Polyscope stands on the shoulders of many outstanding open-source projects. These dependencies are all permissively licensed, and bundled with the project; we just list them here to give due credit!</p> Name Purpose Link GLFW Window and input management with openGL glfw.org Dear ImGui GUI interface (buttons, text boxes, etc) github.com/ocornut/imgui glad OpenGL loader (used on Windows/Linux) github.com/Dav1dde/glad glm Vector math and glsl utilities glm.g-truc.net stb Header-only libraries, esp. image loading github.com/nothings/stb json Read/write json text github.com/nlohmann/json MC.h adapted for marching cubes github.com/aparis69/MarchingCubeCpp mkdocs Doc generation mkdocs.org mkdocs-material Doc generation squidfunk.github.io/mkdocs-material/ googletest Unit testing github.com/google/googletest pybind11 (Python only) Python bindings github.com/pybind/pybind11 Eigen (Python only) numpy interop for bindings eigen.tuxfamily.org <p>Additionally, Polyscope includes a few public-domain / permissively licensed assets. Some of the built-in matcaps are from the Blender project, and others were rendered using Blender.  The built-in colormaps come from several sources as detailed on the colormap page, including Smith et. al., cmocean, and matplotlib.  The concrete texture on the ground is from cc0textures.com. Thank you, artists!</p>"},{"location":"about/license/","title":"License","text":"<p>The core Polyscope C++ library is released under an MIT license, and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain).</p> <p>These Python bindings are also released under an MIT license. The python bindings are generated using pybind11, which is under a BSD 3-clause license, and Eigen, which is licensed under MPL2; again, these are permissive licenses.</p> <p>Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works.</p> <pre><code>@misc{polyscope,\ntitle = {Polyscope},\nauthor = {Nicholas Sharp and others},\nnote = {www.polyscope.run},\nyear = {2019}\n}\n</code></pre>"},{"location":"about/release_notes/","title":"Release notes","text":"<ul> <li> <p>Version 2.0.0 Dec 2023  Backlog of many changes. Large backend rewrite, several new structures and features.</p> <ul> <li>Add a Camera View structure for displaying images and rendered views of a scene</li> <li>Add a Volume Grid structure for values defined on regular grids</li> <li>Add helpers for directly visualizing implicit functions</li> <li>Add support for visualizing images (and the concept of Floating Quantities)</li> <li>Add <code>frameTick()</code> as an alternate method for basic control flow</li> <li>Add texture map support for surface meshes</li> <li>Add support for true-color rendering with the <code>flat</code> material</li> <li>More helpers for manipulating views and mouse clicks</li> <li>Write the backed to use a new <code>ManagedBuffer</code> abstraction to generalize data management, avoid duplicate buffers on the GPU</li> <li>Add a shader cache</li> <li>Add <code>view::setFrontDir</code> to set the default front-facing camera view direction. Change the default to be +Z front.</li> <li>Breaking: Rename <code>intrinsic</code> vector quantities to <code>tangent</code>. Change interpretation of symmetric data. Track bases per-quantity rather than per-structure.</li> <li>Breaking: Remove ability to set vertex- and face- permutations for surface meshes.</li> <li>Breaking: Remove poorly-supported surface mesh quantities: surface graph (superseded by Curve Network), count quantity, subset quantity</li> </ul> </li> <li> <p>v1.3.0 Dec 1, 2021 Adds callbacks in Python and imgui bindings, high-performance mode for big point clouds, volume mesh inspection with slice planes, more slice plane config options, better control of structure transformations and scene extents, orthographic view, back face coloring options, advanced options for customizing ImGui, support for shared linking, and bug fixes.</p> </li> <li>v1.2.0 July 29, 2021: Update to latest cpp version, moving forward major and minor version will be synced between the core cpp library and these bindings. Add volume meshes, slice planes, and transparent rendering. Support soft ground shadows, point clouds with variable radius, and back face culling options for surface meshes. Better programmatic camera controls. Generalize isoline support for all scalar quantities. Change the font.  Overhaul to a more flexible shader system, internally, change default screenshot format back to <code>png</code>, fix size validation bugs with surface mesh, require explicit tangent spaces.</li> <li>v0.1.1 Sept 27, 2020: Update to latest cpp. Bind reset camera function. Bindings at cpp version <code>v1.1.1</code>.</li> <li>v0.1.0 Apr 11, 2020: Initial release of Python bindings. Bindings at cpp version <code>v1.1</code>.</li> </ul>"},{"location":"basics/camera_controls/","title":"Camera Controls & Parameters","text":"<p>These settings affect the 3D camera view in polyscope. It is often convenient to set them just before calling <code>polyscope.init()</code>, but they may generally be set anywhere.</p> <pre><code>import polyscope as ps\nimport numpy as np\n\nps.set_up_dir(\"z_up\")\nps.set_front_dir(\"neg_y_front\")\nps.set_navigation_style(\"free\")\n\n# initialize\nps.init()\n\n# set the camera pose explicitly\nps.look_at((0., 0., 5.), (1., 1., 1.))\n\n# (alternately, use numpy vectors)\nps.look_at(np.array((0., 0., 5.)), np.array((1., 1., 1.)))\n\n# show the GUI\nps.show()\n</code></pre>"},{"location":"basics/camera_controls/#options","title":"Options","text":"<code>set_navigation_style(s)</code> <code>get_navigation_style()</code> <p>Get the current navigation style (see explanation in the setter above). Returns a string.</p> <code>set_up_dir(s)</code> <code>get_up_dir()</code> <p>Get the current up direction (see explanation in the setter above). Returns a string.</p> <code>set_front_dir(s)</code> <code>get_front_dir()</code> <p>Get the current front direction (see explanation in the setter above). Returns a string.</p> <code>look_at(camera_location, target, fly_to=False)</code> <code>look_at_dir(camera_location, target, up_dir, fly_to=False)</code> <p>Set the camera to be located at the 3D position <code>camera_location</code> and looking at the 3D position <code>target</code>, oriented with the up direction <code>up_dir</code>, all in world coordinates. If <code>fly_to=True</code>, the camera will smoothly animate to the new configuration.</p> <p>Note that setting the up direction for the camera view with this function is separate from the scene\u2019s up direction with <code>set_up_dir()</code>, which affects things like ground plane placement, and manual view manipulation.</p> <p>The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p> <p>Example: <pre><code>polyscope.look_at_dir((0., 0., 5.), (1., 1., 1.), (-1., -1., 0.))\n</code></pre></p> <code>reset_camera_to_home_view()</code>"},{"location":"basics/camera_controls/#navigation-style","title":"navigation style","text":"<p>The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, pass a string for the following settings:</p> <ul> <li><code>'turntable'</code> The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions.</li> <li><code>'free'</code> The camera is free to take any orientation, rotation is always about relative to the current camera.</li> <li><code>'planar'</code> The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data).</li> </ul> <p>Default: <code>'turntable'</code>.</p> <p>Example: ```python import polyscope as ps ps.set_navigation_style(\u201cfree\u201d)</p>"},{"location":"basics/camera_controls/#up-direction","title":"up direction","text":"<p>Set the default \u201cup\u201d direction for the scene. This setting affects default orientation of the view, the behavior of some navigation styles (esp. <code>Turntable</code>), and the orientation of the ground plane.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the setting strings are:</p> <ul> <li><code>'x_up'</code> The positive X-axis is up.</li> <li><code>'neg_x_up'</code> The negative X-axis is up.</li> <li><code>'y_up'</code> The positive Y-axis is up.</li> <li><code>'neg_y_up'</code> The negative Y-axis is up.</li> <li><code>'z_up'</code> The positive Z-axis is up.</li> <li><code>'neg_z_up'</code> The negative Z-axis is up.</li> </ul> <p>Default: <code>'y_up'</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_up_dir(\"z_up\")\n</code></pre></p>"},{"location":"basics/camera_controls/#front-direction","title":"front direction","text":"<p>Set the default \u201cfront\u201d direction for the scene. This setting affects default orientation of the view; the starting camera looks at the front of the data.</p> <p>This value is interpeted as if the scene were a cube, and you are specifying which face of the cube is the \u2018front\u2019. So <code>z_front</code> means the +Z face of the cube is the front face, and thus our camera initially points down the -Z axis to look at it.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the setting strings are:</p> <ul> <li><code>'x_front'</code> The positive X-axis is the front.</li> <li><code>'neg_x_front'</code> The negative X-axis is the front.</li> <li><code>'y_front'</code> The positive Y-axis is the front.</li> <li><code>'neg_y_front'</code> The negative Y-axis is the front.</li> <li><code>'z_front'</code> The positive Z-axis is the front.</li> <li><code>'neg_z_front'</code> The negative Z-axis is the front.</li> </ul> <p>Default: <code>z_front</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_front_dir(\"z_front\")\n</code></pre></p>"},{"location":"basics/camera_controls/#look-at","title":"look at","text":"<p>Set the camera to be located at the 3D position <code>camera_location</code> and looking at the 3D position <code>target</code>, both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If <code>fly_to=True</code>, the camera will smoothly animate to the new configuration.</p> <p>The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p> <p>Example: <pre><code>polyscope.look_at((0., 0., 5.), (1., 1., 1.))\n</code></pre></p>"},{"location":"basics/camera_controls/#reset-camera-to-home-view","title":"reset camera to home view","text":"<p>Reset the camera view to the home view (a reasonable default view scaled to the scene).</p> <p>Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data.</p> <p>Example: <pre><code>ps.reset_camera_to_home_view()\n</code></pre></p>"},{"location":"basics/camera_controls/#orthographic-view","title":"Orthographic view","text":"<p>By default, Polyscope\u2019s view uses perspective projection. Perspective projections roughly correspond to how images are usually perceived by our eyes and cameras.</p> <p>Alternately orthographic projection is also supported. Orthographic projections are common in engineering and architecture, because they have the property that distances are preserved in the projected image, regardless of whether the object is near or far from the camera.</p> <p></p> <p>In perspective mode, zooming (for instance, by manually scrolling the mouse) translates the camera forward in space. In orthographic mode, it instead adjusts the field of view without moving the camera. This is because counter-intuitively, translating the camera forward does not actually change the view in an orthographic projection!</p> <code>set_view_projection_mode(mode_name)</code>"},{"location":"basics/camera_controls/#set-projection-mode","title":"set projection mode","text":"<p>Set the camera view projection to be either orthographic or perspective (default).</p> <p>Example: <pre><code># Enable the orthographic view\nps.set_view_projection_mode(\"orthographic\")\n\n# Go back to default perspective projection\nps.set_view_projection_mode(\"perspective\")\n</code></pre></p>"},{"location":"basics/camera_controls/#savingrestoring-views","title":"Saving/restoring views","text":"<p>The current camera view (location, direction, camera parameters, and window size) can be saved or loaded from a json string. This is useful for quickly setting up repeatable visualizations.</p> <p>Also, in the Polyscope GUI, this string can be copied to the clipboard at any time via the \u201ccopy\u201d hotkey (ctrl-C or cmd-C), or loaded from your current clipboard using the \u201cpaste\u201d hotkey (ctrl-V or cmd-V).</p> <code>get_view_as_json()</code> <p>Get the current view parameters specified as a json string. Returns a string.</p> <p>Example: <pre><code>import polyscope as ps\nmy_str = ps.get_view_as_json()\n</code></pre></p> <code>void set_view_from_json(json_str)</code> <p>Set the current view to match the parameters specified in the json string.</p> <p>Example: <pre><code>ps.set_view_from_json(my_str);\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-parameters","title":"Camera Parameters","text":"<p><code>CameraParameters</code> objects describe a camera view in Polyscope, including its intrinsics (the field of view and aspect ratio), and extrinsics (the location and orientation). These parameters are used both for manipulations of the interactive viewport, as well as creating Camera View structures which are visualized as part of the content in your scene.</p> <p>Example: <pre><code>import polyscope as ps\n\n# construct camera parameters\nintrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\nparams = ps.CameraParameters(intrinsics, extrinsics)\n\n# set the viewport view to those parameters\nps.set_view_camera_parameters(params)\n\n# or, use the parameters to create a camera view\ncam = ps.register_camera_view(\"cam1\", params)\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-intrinsics","title":"Camera Intrinsics","text":"<p>A <code>CameraIntrinsics</code> object describes the field of view and aspect ratio of a camera. It does not describe a \u201cpixel resolution\u201d for a camera\u2014you could have many images of different resolutions all associated with the same camera, as long as the aspect ratios are right.</p> <p>Camera intrinsics can be created by specifying any pair of vertical field of view, horizontal field of view, and aspect ratio.</p> <code>CameraIntrinsics(fov_vertical_deg=None, fov_horizontal_deg=None, aspect=None)</code> <p>Construct camera intrinsics. You must specify exactly two of the following parameters</p> <ul> <li><code>fov_vertical_deg</code> vertical field of view in degrees</li> <li><code>fov_horizontal_deg</code> horizontal field of view in degrees</li> <li><code>aspect</code> aspect ratio, as <code>width / height</code></li> </ul> <p>Example: <pre><code>intrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-extrinsics","title":"Camera Extrinsics","text":"<p>A <code>CameraExtrinsics</code> object describes the location and orientation of a camera. It can be defined by the forward/up/right axes of the camera in world coordinates, or via an extrinsic matrix, typically denoted <code>E</code>, which maps points in world coordinates to points in the camera\u2019s local coordinate system. Polyscope uses openGL conventions for camera space, such that the camera points toward the -Z axis, with +Y pointing up and +X pointing right.</p> <p>Camera extrinsics can be created by specifying frame axes or an extrinsic matrix.</p> <code>CameraExtrinsics(root=None, look_dir=None, up_dir=None, mat=None)</code> <p>Construct camera extrinsics.</p> <p>You must specify either all three of:</p> <ul> <li><code>root</code> the world-space position of the camera</li> <li><code>look_dir</code> a world-space unit vector along which the camera looks</li> <li><code>up_dir</code> a world-space unit vector defining the up axis for the camera</li> </ul> <p>Or specify: - <code>mat</code> a 4x4 matrix mapping points in world-space to local camera space. Polyscope\u2019s camera space uses openGL convention.</p> <p>All vectors and matrices should be numpy arrays, or something which a numpy array can be constructed from (like a tuple of floats).</p> <p>Example: <pre><code>extrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-parameters_1","title":"Camera Parameters","text":"<p>The <code>CameraParameters</code> object combines a set of intrinsics and extrinsics to fully define a camera.</p> <code>CameraParameters(intrinsics, extrinsics)</code> <p>Construct camera parameters from intrinsics and extrinsics.</p> <p>Example: <pre><code>intrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\nparams = ps.CameraParameters(intrinsics, extrinsics)\n</code></pre></p> <p>Various getters access the intrinsic and extrinsic properties of the parameters object. <pre><code># intrinsics\nCameraParameters.get_fov_vertical_deg()\nCameraParameters.get_aspect()\n\n# extrinsics\nCameraParameters.get_T()\nCameraParameters.get_R()\nCameraParameters.get_view_mat()     # synonym for get_E()\nCameraParameters.get_E()\nCameraParameters.get_position()\nCameraParameters.get_look_dir()\nCameraParameters.get_up_dir()\nCameraParameters.get_right_dir()\nCameraParameters.get_camera_frame() # &lt;look, up, right&gt; world-space vectors\n</code></pre></p>"},{"location":"basics/camera_controls/#generating-pixel-rays","title":"Generating pixel rays","text":"<p>It is often necessary to generate the world-space ray corresponding to each pixel of an image in a camera view. The base point for these rays is easy, it is just <code>params.get_position()</code>. However the ray directions vary-per pixel; the <code>CameraParameters</code> object has two helpers to automatically construct these rays.</p> <code>CameraParameters.generate_camera_rays(dims, image_origin='upper_left')</code> <p>Generate an array of rays corresponding to an image with the given resolution <code>dims=(dimX,dimY)</code>. The result is a <code>[dimX,dimY,3]</code> numpy buffer. Ray origins are all implicitly given by <code>params.get_position()</code>.</p> <p>Example: <pre><code>rays = params.generate_camera_rays((300,200))\n</code></pre></p> <code>CameraParameters.generate_camera_ray_corners()</code> <p>Generate the rays corresponding to the [upperleft, upperright, lowerleft, lowerright] corners of the camera\u2019s view. </p> <p>This method is useful because the caller can easily linearly interpolate the normalize get ray directions for all pixels in an image, but this method just needs to return a small amount of data. This makes it easy to e.g. generate rays for a real-time renderer on a GPU, without transferring a whole buffer of ray directions for each frame.</p>"},{"location":"basics/flow/","title":"Basic Flow","text":"<p>This page describes the basic control flow to initialize Polyscope and invoke it from you program. See the structures and quantities sections on the left for the various kinds of data you can add to Polyscope.</p> <p>Polyscope needs to be initialized exactly once by calling <code>init()</code>, typically near the beginning of your program. You can then register structures to the scene, and show the window using either of two methods.</p>"},{"location":"basics/flow/#program-structure","title":"Program Structure","text":"<p>There are two separate ways to structure your program\u2019s control flow with polyscope.</p> <p>Option 1: show() The simpler, and more-common approach is to call <code>show()</code>, which will run Polyscope\u2019s window continuously. The <code>show()</code> function will not return until the window is closed. If you want to execute your own code while the Polyscope window is active, you must do so via the <code>user_callback</code>.</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# ... your code ...\n# ... add visualizations to Polyscope, etc ...\n\n# if desired, set up a user_callback to execute your code each\n# frame and add ImGui UI elements\n\nps.show() # shows the UI, blocks until the UI exits\n\n# If desired, add more visualizations, then show the UI again.\n# Data is preserved between calls to show() unless explicitly removed.\n# ... your code ...\nps.show()\n</code></pre> <p>Option 2: frame_tick() An alternate approach is to manually call <code>frame_tick()</code> in a tight loop to run the UI. This is useful to quickly integrate Polyscope into existing programs which already have a main loop. The <code>user_callback</code> is still necessary to add ImGui UI elements.</p> <pre><code>import polyscope as ps\n\n# if desired, set up a user_callback to add ImGui UI elements\n\nwhile(continue_program):\n\n    #  ... your code ...\n    #  ... add visualizations to Polyscope, etc ...\n\n    ps.frame_tick() # renders one UI frame, returns immediately\n</code></pre> <p>Either way, <code>init()</code> must be called before you do anything with Polyscope.</p> <p>Where to make ImGui calls</p> <p>Polyscope includes ImGui, allowing you to build custom UI elements like buttons and fields. </p> <p>Regardless of which control flow method you use, ImGui calls can only be make within the <code>user_callback</code> function. Making ImGui calls elsewhere will lead to errors and crashes.</p>"},{"location":"basics/flow/#functions","title":"Functions","text":"<code>init(backend=\"\")</code> <code>show()</code> <code>unshow()</code> <code>frame_tick()</code>"},{"location":"basics/flow/#init","title":"init()","text":"<p>Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization.</p> <p>Performs one-time work like setting up openGL and creating a window.</p> <p><code>backend</code> is an optional specifier for which rendering backend to use, passing <code>\"\"</code> selects a reasonable default backend. Generally, you should not need to manually set the backend.</p>"},{"location":"basics/flow/#show","title":"show()","text":"<p>Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.</p> <p>This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to <code>frame_ticK()</code> and <code>show()</code>.</p> <p>You can even nest calls to <code>show()</code>\u2014for instance, if the user clicks a button in your callback which executes some function, you can invoke <code>show()</code> again within that function for immediate debugging. Closing the nested window will then \u201cpop back\u201d to continue displaying the previously shown GUI.</p> <p>If desired, register a <code>user_callback</code> which will be internally executed by Polyscope within each frame, you may not make ImGui calls arbitrarily throughout your code.</p> <p>Several options are available which affect the behavior of <code>show()</code>, such as whether the window is automatically brought to the front and given focus. See the options listing for details.</p>"},{"location":"basics/flow/#unshow","title":"unshow()","text":"<p>The opposite of <code>show()</code>. If <code>show()</code> is currently active, this closes the window and causes the call to <code>show()</code> to return. This is equivalent to manually closing the Polyscope window by clicking the window manager\u2019s close button.</p> <p>Generally it is not necessary to call this function; the user can exit by closing the window. However, <code>unshow()</code> may be useful to programmatically close the window when a condition is met, or via a custom ImGui element.</p> <p><code>unshow()</code> does not deinitialize Polyscope. You can still call <code>show()</code> again after.</p>"},{"location":"basics/flow/#frame_tick","title":"frame_tick()","text":"<p>Render one frame of the polyscope UI. This function needs to be called in a tight loop by your code, like:</p> <pre><code>ps.init()\n\nwhile(continue_program):\n\n    # \n    # ... your code ...\n    # \n\n    ps.frame_tick()\n</code></pre> <p>If <code>frame_tick()</code> is not called often enough, the interface will be unresponsive.</p> <p>This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to <code>frame_ticK()</code> and <code>show()</code>.</p> <p>If any ImGui UI elements are to be created, they must be created inside of a <code>user_callback()</code> (which will be internally executed by Polyscope within each <code>frame_tick()</code>, you may not make ImGui calls arbitrarily throughout your code.</p> <p>The <code>frame_tick()</code> function can be called anywhere within your program\u2019s control flow, including from multiple call sites. You may also interleave or nest calls to <code>frame_tick()</code> and <code>show()</code> to use both kinds of control flow within a program.</p>"},{"location":"basics/parameters/","title":"Parameters","text":"<p>Many structures and quantities in Polyscope have optional values which can be set to control their appearance or behavior, such as the radius of points in a point cloud or the color of a mesh. These values can generally be manually adjusted in the GUI, or set programmatically in code.</p> <p>This page documents special features in Polyscope which provide extra functionality while setting these parameters.</p>"},{"location":"basics/parameters/#persistent-values","title":"Persistent values","text":"<p>In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values.</p> <p>Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match.</p> <p>Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. <pre><code>ps_cloud = ps.get_point_cloud(\"my cloud\")\nps_cloud.set_color((0.5, 0.5, 0.5))\n# the persistent value is recorded in the cache\n\n# ... later ...\n\nnew_cloud = ps.register_point_cloud(\"my cloud\", new_points);\n# new_cloud will automatically pick up the pointColor we set above, \n# since this point cloud has the same name\n</code></pre> Note that this persistence behavior applies even when variables are manually manipulated in the GUI.</p>"},{"location":"basics/parameters/#scaled-values","title":"Scaled values","text":"<p>Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. Many Polyscope parameters take a <code>relative</code> option, which is usually <code>True</code> by default, to set lengths relatively.</p> <pre><code>ps_cloud = ps.get_point_cloud(\"my cloud\")\n\n# radius will be 0.05 * lengthScale when used\nps_cloud.set_radius(0.05); \nps_cloud.set_radius(0.05, relative=True); # same as previous (default is True)\n</code></pre> <p>However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use.</p> <pre><code># radius will be 1.6 when used\nps_cloud.set_radius(1.6, relative=False)\n</code></pre> <p>Note that scaled values can be (and often are) used as persistent values, as described above; the two concepts are complementary. </p>"},{"location":"basics/program_options/","title":"Program Options","text":"<p>These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling <code>polyscope.init()</code>, but they may generally be set anywhere.</p> <pre><code>import polyscope as ps\n\n# a few options\nps.set_program_name(\"important app\")\nps.set_verbosity(0)\nps.set_use_prefs_file(False)\n\n# initialize\nps.init()\n</code></pre>"},{"location":"basics/program_options/#options","title":"Options","text":"<code>set_program_name(name)</code> <code>set_verbosity(v)</code> <code>set_print_prefix(p)</code> <code>set_errors_throw_exceptions(b)</code> <code>set_enable_render_error_checks(b)</code> <code>set_SSAA_factor(n)</code> <code>set_max_fps(f)</code> <code>set_use_prefs_file(b)</code> <code>set_always_redraw(b)</code> <code>set_build_gui(b)</code> <code>set_open_imgui_window_for_user_callback(b)</code> <code>set_invoke_user_callback_for_nested_show(b)</code> <code>set_give_focus_on_show(b)</code>"},{"location":"basics/program_options/#program-name","title":"program name","text":"<p>A general name to use when referring to the program in window headings, etc. Default: <code>Polyscope</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_program_name(\"important app\")\n</code></pre></p>"},{"location":"basics/program_options/#verbosity","title":"verbosity","text":"<p>How much useful info should polyscope print to stdout? Default: <code>1</code>.</p> <ul> <li><code>0</code> print nothing</li> <li><code>1</code> print occasionally</li> <li><code>&gt;= 2</code> print a lot</li> </ul> <p>Example: <pre><code>import polyscope as ps\nps.set_verbosity(0)\n</code></pre></p>"},{"location":"basics/program_options/#print-prefix","title":"print prefix","text":"<p>A string used as a prefix for all messages printed to the terminal by polyscope.  Default: <code>[polyscope]</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_print_prefix(\"[MYAPP] \");\n# prints now look like \"[MYAPP] loaded openGL\"\n</code></pre></p>"},{"location":"basics/program_options/#errors-throw-execptions","title":"errors throw execptions","text":"<p>If true, errors in polyscope raise execptions. If false, a polyscope error is shown in the UI, but processing attempts to continue. Default: <code>False</code>.</p>"},{"location":"basics/program_options/#render-error-checks","title":"render error checks","text":"<p>If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems.</p> <p>Default: <code>True</code> when compiled in <code>Debug</code> mode, <code>False</code> in <code>Release</code> mode (this python library is generally compiled in release mode)</p>"},{"location":"basics/program_options/#ssaa-anti-aliasing-factor","title":"SSAA anti-aliasing factor","text":"<p>Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. </p> <p>Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range <code>1</code> to <code>4</code>. Using <code>2</code> is generally sufficient for anti-aliasing.</p> <p>Default: <code>1</code> (no anti-aliasing)</p>"},{"location":"basics/program_options/#max-fps","title":"max fps","text":"<p>The main loop will not run at more than <code>maxFPS</code> iterations per second. <code>-1</code> disables, running the loop as fast as possible. Default: <code>60</code>.</p>"},{"location":"basics/program_options/#use-prefs-file","title":"use prefs file","text":"<p>Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a <code>json</code>-formatted plaintext file called <code>.polyscope.ini</code>.</p> <p>This option controls the use of the preferences file. If <code>False</code>, if will be neither written nor read. Default: <code>True</code>.</p>"},{"location":"basics/program_options/#always-redraw","title":"always redraw","text":"<p>Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities.</p> <p>If this option is <code>True</code>, the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: <code>False</code>.</p>"},{"location":"basics/program_options/#build-gui","title":"build gui","text":"<p>This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope.</p> <p>If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs.</p> <p>Default: <code>True</code>.</p>"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","title":"open imgui window for user callback","text":"<p>If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like <code>polyscope.imgui.Button(\"do stuff\")</code>. </p> <p>If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any).</p> <p>Default: <code>True</code>.</p>"},{"location":"basics/program_options/#invoke-user-callback-for-nested-show","title":"invoke user callback for nested show","text":"<p>Suppose you call <code>polyscope.show()</code>, and within your callback, another instance of <code>polyscope.show()</code> is called\u2014this is a nested show.</p> <p>Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option.</p> <p>If true, your callback will be executed as normal for every main loop iteration, even in nested show windows.</p> <p>If false, your callback will only be executed for initial, outermost calls to <code>polyscope.show()</code>.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/program_options/#give-focus-on-show","title":"give focus on show","text":"<p>If true, the Polyscope window will request focus from the window manager whenever <code>show()</code> is called. If false, the focus state will be left unchanged.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/scene_options/","title":"Scene Options","text":"<p>These are settings which affect the visual display of the scene.  It is often convenient to set them just before calling <code>polyscope.init()</code>, but they may generally be set anywhere.</p> <pre><code>import polyscope as ps\n\n# enable auto centering and scaling\nps.set_autocenter_structures(True)\nps.set_autoscale_structures(True)\n\n# initialize\nps.init()\n</code></pre> <code>set_autocenter_structures(b)</code> <code>set_autoscale_structures(b)</code>"},{"location":"basics/scene_options/#autocenter-structures","title":"autocenter structures","text":"<p>If true, all structures will have their transform set to center their bounding box immediately after being registered.</p> <p>This centers the content nicely in view, but obscures any important absolute world positions.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/scene_options/#autoscale-structures","title":"autoscale structures","text":"<p>If true, all structures will have their transform set to rescale their length to 1 immediately after being registered.</p> <p>This scales the content nicely in view, but obscures any important absolute world positions.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/scene_options/#extents","title":"Extents","text":"<p>By default, Polyscope computes a bounding box and length scale for the structures in the scene, and uses them to adjust the rendered view. For instance, the camera view is initially pointed at the center of the bounding box, and the length scale is used to set reasonable values for the radii of points, curves, and vectors.</p> <p>However, sometimes it important to fix these extents rather than automatically computing them from data. One such case is producing precisely consistent visualizations across many inputs which might have slightly different extents. Another is when outlier data makes the automatically-computed extents egregiously large. The settings below can be used to manually adjust these extents.</p> <p>These parameters can be adjust in the UI under <code>[View] --&gt; [Scene Extents]</code>.</p> <p>Example:  fix the length scale to the unit bounding box <pre><code>import polyscope as ps\n\nps.init()\nps.set_automatically_compute_scene_extents(False)\nps.set_length_scale(1.)\nlow = np.array((-1, -1., -1.)) \nhigh = np.array((1., 1., 1.))\nps.set_bounding_box(low, high)\n</code></pre></p> <code>get_length_scale()</code> <p>Get the current representative length scale for the scene. Returns a float.</p> <code>set_length_scale(s)</code> <p>Set a representative length scale for the scene. Takes a float.</p> <p>When Polyscope automatically computes this, most structures simply use the length of the diagonal of the bounding box.</p> <code>get_bounding_box()</code> <p>Get the current bounding box for the scene, in world coordinates. Returns a tuple of length-3 numpy vectors. The first and second elements of the tuple are the lower and upper corners of the bounding box, respectively.</p> <code>set_bounding_box(low, high)</code> <p>Set a bounding box for the scene, in world coordinates. Takes two length-3 numpy vectors, which are the lower and upper corners of the bounding box, respectively.</p> <code>set_automatically_compute_scene_extents(b)</code> <p>If true, the length scale and bounding box parameters will be automatically computed from the registered structures, and updated whenever a a structure is added or changed.</p> <p>If false, these parameters will be left unchanged.  If set to false before the first structure is registered, you are required to set the bounding box and length scale manually.</p> <p>Takes a boolean.  Default: <code>true</code>.</p>"},{"location":"basics/scene_options/#other-options","title":"Other Options","text":"<code>set_background_color(new_color)</code>"},{"location":"basics/scene_options/#background-color","title":"background color","text":"<p>Set the background color of the rendered scne.</p> <p>The input should be a 3-tuple RGB or a 4-tuple RGBA of floats, with values on on <code>[0,1]</code>.</p> <p>Default: <code>{1., 1., 1., 1.}</code>.</p>"},{"location":"common/color_quantity/","title":"Color quantity","text":""},{"location":"common/color_quantity/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"common/parameterization_quantity/","title":"Parameterization quantity","text":""},{"location":"common/parameterization_quantity/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>viz_style</code> option determines how parameterizations are visualized:</p> <ul> <li><code>checker</code>: a two-color checker pattern</li> <li><code>grid</code>: a two-color grid with thin lines</li> <li><code>local_check</code>: a checkerboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>local_rad</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul>"},{"location":"common/parameterization_quantity/#types","title":"Types","text":"<p>The <code>coords_type</code> options determines how parameter coordinates are interpreted for scaling:</p> <ul> <li><code>unit</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>world</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul>"},{"location":"common/parameterization_quantity/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>When adding a parameterization quantity, the following keyword options can be set. These are available for all kinds of parameterization quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>coords_type</code> string, one of <code>'unit'</code>, <code>'world'</code>  (see above)</li> <li><code>viz_style</code> string, one of <code>'checker'</code>, <code>'grid'</code>, <code>'local_check'</code>, <code>'local_rad'</code> (see above)</li> <li><code>grid_colors</code> 2-tuple of rgb colors, used to color the grid visualization</li> <li><code>checker_colors</code> 2-tuple of rgb colors, used to color the checkerboard visualization</li> <li><code>checker_size</code> float, the size of checkers/grid/stripes</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"common/scalar_quantity/","title":"Scalar quantity","text":""},{"location":"common/scalar_quantity/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"common/vector_quantity/","title":"Vector quantity","text":""},{"location":"common/vector_quantity/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"features/2D_data/","title":"2D Data","text":"<p>Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so.</p>"},{"location":"features/2D_data/#adding-2d-data","title":"Adding 2D data","text":"<p>Functions which accept 3D positions (or vectors) as input can alternately takes 2D positions, and append a 0 z-coordinate.  In Python (unlike the C++ api), we can use 2D data by simply passing it as the argument of a function which would otherwise take 3D data. For instance, <code>register_point_cloud(name, data)</code> normally expects <code>data</code> to be a <code>Nx3</code> array of 3D positions, but passing an <code>Nx2</code> array also works just fine.  Any other functions which don\u2019t take 3D positions can be used as normal, like <code>add_scalar_quantity()</code>.</p>"},{"location":"features/2D_data/#planar-camera-mode","title":"Planar camera mode","text":"<p>The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to <code>Planar</code>. In the UI, this option is in the main Polyscope window, set to <code>Turntable</code> by default. Setting the camera mode to <code>Planar</code> will also hide the ground plane.</p> <p></p> <p>To set this option programmatically, use: <pre><code>ps.set_navigation_style(\"planar\")\n</code></pre></p>"},{"location":"features/callbacks_and_UIs/","title":"Callbacks & Custom UIs","text":"<p>When <code>polyscope.show()</code> has been called, Polyscope will optionally invoke user-supplied callback function as each frame of the interface is redrawn. This callback can be used to build a program-specific GUI, update an animation, perform computation, etc.</p>"},{"location":"features/callbacks_and_UIs/#setting-a-per-frame-callback","title":"Setting a per-frame callback","text":"<p>Pass in a Python function (with no arguments and no return value), and Polyscope will execute it as each frame of the interface is drawn.</p> <p>Example: <pre><code>import polyscope as ps\n\nps.init()\n\ndef callback():\n    # Executed every frame\n    # Do computation here, define custom UIs, etc.\n    print(\"executing callback\")\n\nps.set_user_callback(callback)\n\nps.show()\n\nps.clear_user_callback()\n</code></pre></p> <code>set_user_callback(func)</code> <code>clear_user_callback()</code>"},{"location":"features/callbacks_and_UIs/#set_user_callback","title":"set_user_callback","text":"<p>Set a function which will be called by polyscope on every UI draw iteration. The argument should be a Python function, which takes no arguments.</p>"},{"location":"features/callbacks_and_UIs/#clear_user_callback","title":"clear_user_callback","text":"<p>Clear the callback function.</p>"},{"location":"features/callbacks_and_UIs/#creating-custom-uis","title":"Creating custom UIs","text":"<p>One of the most important uses of the per-frame callback is to define custom UIs. You can use these UIs to add buttons which execute custom functions, adjust the value of parameters, display information, etc.</p> <p>Polyscope uses Dear ImGui as an immediate-mode UI framework. Please see the documentation there to understand the basic paradigm and capabilities. The Polyscope python package includes bindings to a significant subset of ImGui in the <code>polyscope.imgui</code> submodule. </p> <p>These bindings are not yet exhaustively documented, but they follow the naming conventions of ImGui as closely as possible for simplicity. Documentation of ImGui functions and parameters lives here, and  you can find the list of bound functions, types, and enums here. Common usage should be covered by the example below.</p> <p>Example: Create the following UI in a Python callback</p> <p></p> <pre><code>import polyscope as ps\nimport polyscope.imgui as psim\n\n# A bunch of parameters which we will manipulate via the UI defined below.\n# There is nothing special about these variables, you could manipulate any other \n# kind of Python values the same way, such as entries in a dict, or class members.\nis_true1 = False\nis_true2 = True\nui_int = 7\nui_float1 = -3.2\nui_float2 = 0.8\nui_color3 = (1., 0.5, 0.5)\nui_color4 = (0.3, 0.5, 0.5, 0.8)\nui_angle_rad = 0.2\nui_text = \"some input text\"\nui_options = [\"option A\", \"option B\", \"option C\"]\nui_options_selected = ui_options[1]\n\ndef my_function():\n    # ... do something important here ...\n    print(\"executing function\")\n\n# Define our callback function, which Polyscope will repeatedly execute while running the UI.\n# We can write any code we want here, but in particular it is an opportunity to create ImGui \n# interface elements and define a custom UI.\ndef callback():\n\n    # If we want to use local variables &amp; assign to them in the UI code below, \n    # we need to mark them as nonlocal. This is because of how Python scoping \n    # rules work, not anything particular about Polyscope or ImGui.\n    # Of course, you can also use any other kind of python variable as a controllable \n    # value in the UI, such as a value from a dictionary, or a class member. Just be \n    # sure to assign the result of the ImGui call to the value, as in the examples below.\n    # \n    # If these variables are defined at the top level of a Python script file (i.e., not\n    # inside any method), you will need to use the `global` keyword instead of `nonlocal`.\n    nonlocal is_true1, is_true2, ui_int, ui_float1, ui_float2, ui_color3, ui_color4, ui_text, ui_options_selected, ui_angle_rad\n\n\n    # == Settings\n\n    # Use settings like this to change the UI appearance.\n    # Note that it is a push/pop pair, with the matching pop() below.\n    psim.PushItemWidth(150)\n\n\n    # == Show text in the UI\n\n    psim.TextUnformatted(\"Some sample text\")\n    psim.TextUnformatted(\"An important value: {}\".format(42))\n    psim.Separator()\n\n\n    # == Buttons\n\n    if(psim.Button(\"A button\")):\n        # This code is executed when the button is pressed\n        print(\"Hello\")\n\n    # By default, each element goes on a new line. Use this \n    # to put the next element on the _same_ line.\n    psim.SameLine() \n\n    if(psim.Button(\"Another button\")):\n        # This code is executed when the button is pressed\n        my_function()\n\n\n    # == Set parameters\n\n    # These commands allow the user to adjust the value of variables.\n    # It is important that we assign the return result to the variable to\n    # update it. \n    # For most elements, the return is actually a tuple `(changed, newval)`, \n    # where `changed` indicates whether the setting was modified on this \n    # frame, and `newval` gives the new value of the variable (or the same \n    # old value if unchanged).\n    #\n    # For numeric inputs, ctrl-click on the box to type in a value.\n\n    # Checkbox\n    changed, is_true1 = psim.Checkbox(\"flag1\", is_true1) \n    if(changed): # optionally, use this conditional to take action on the new value\n        pass \n    psim.SameLine() \n    changed, is_true2 = psim.Checkbox(\"flag2\", is_true2) \n\n    # Input ints\n    changed, ui_int = psim.InputInt(\"ui_int\", ui_int, step=1, step_fast=10) \n\n    # Input floats using two different styles of widget\n    changed, ui_float1 = psim.InputFloat(\"ui_float1\", ui_float1) \n    psim.SameLine() \n    changed, ui_float2 = psim.SliderFloat(\"ui_float2\", ui_float2, v_min=-5, v_max=5)\n\n    # Input colors\n    changed, ui_color3 = psim.ColorEdit3(\"ui_color3\", ui_color3)\n    psim.SameLine() \n    changed, ui_color4 = psim.ColorEdit4(\"ui_color4\", ui_color4)\n\n    # Input text\n    changed, ui_text = psim.InputText(\"enter text\", ui_text)\n\n    # Combo box to choose from options\n    # There, the options are a list of strings in `ui_options`,\n    # and the currently selected element is stored in `ui_options_selected`.\n    psim.PushItemWidth(200)\n    changed = psim.BeginCombo(\"Pick one\", ui_options_selected)\n    if changed:\n        for val in ui_options:\n            _, selected = psim.Selectable(val, ui_options_selected==val)\n            if selected:\n                ui_options_selected = val\n        psim.EndCombo()\n    psim.PopItemWidth()\n\n\n    # Use tree headers to logically group options\n\n    # This a stateful option to set the tree node below to be open initially.\n    # The second argument is a flag, which works like a bitmask.\n    # Many ImGui elements accept flags to modify their behavior.\n    psim.SetNextItemOpen(True, psim.ImGuiCond_FirstUseEver)\n\n    # The body is executed only when the sub-menu is open. Note the push/pop pair!\n    if(psim.TreeNode(\"Collapsible sub-menu\")):\n\n        psim.TextUnformatted(\"Detailed information\")\n\n        if(psim.Button(\"sub-button\")):\n            print(\"hello\")\n\n        # There are many different UI elements offered by ImGui, many of which\n        # are bound in python by Polyscope. See ImGui's documentation in `imgui.h`,\n        # or the polyscope bindings in `polyscope/src/cpp/imgui.cpp`.\n        changed, ui_angle_rad = psim.SliderAngle(\"ui_float2\", ui_angle_rad, \n                v_degrees_min=-90, v_degrees_max=90)\n\n        psim.TreePop()\n\n    psim.PopItemWidth()\n\n\nps.init() \nps.set_user_callback(callback)\nps.show()\n</code></pre>"},{"location":"features/callbacks_and_UIs/#options","title":"Options","text":"<code>set_build_gui(b)</code> <code>set_open_imgui_window_for_user_callback(b)</code> <code>set_invoke_user_callback_for_nested_show(b)</code> <code>set_give_focus_on_show(b)</code>"},{"location":"features/callbacks_and_UIs/#build-gui","title":"build gui","text":"<p>This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope.</p> <p>If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs.</p> <p>Default: <code>True</code>.</p>"},{"location":"features/callbacks_and_UIs/#open-imgui-window-for-user-callback","title":"open imgui window for user callback","text":"<p>If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like <code>polyscope.imgui.Button(\"do stuff\")</code>. </p> <p>If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any).</p> <p>Default: <code>True</code>.</p>"},{"location":"features/callbacks_and_UIs/#invoke-user-callback-for-nested-show","title":"invoke user callback for nested show","text":"<p>Suppose you call <code>polyscope.show()</code>, and within your callback, another instance of <code>polyscope.show()</code> is called\u2014this is a nested show.</p> <p>Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option.</p> <p>If true, your callback will be executed as normal for every main loop iteration, even in nested show windows.</p> <p>If false, your callback will only be executed for initial, outermost calls to <code>polyscope.show()</code>.</p> <p>Default: <code>False</code>.</p>"},{"location":"features/callbacks_and_UIs/#give-focus-on-show","title":"give focus on show","text":"<p>If true, the Polyscope window will request focus from the window manager whenever <code>show()</code> is called. If false, the focus state will be left unchanged.</p> <p>Default: <code>False</code>.</p>"},{"location":"features/callbacks_and_UIs/#mouse-interactions","title":"Mouse Interactions","text":"<p>You can implement custom mouse behaviors on clicks and other actions within your per-frame callback function. Generally, you can use the mouse-related functions available via <code>ImGui</code> to implement a wide variety of behaviors.</p> <p>Example: print a variety of info about a mouse click <pre><code>import polyscope as ps\nimport polyscope.imgui as psim\n\nio = psim.GetIO()\nif io.MouseClicked[0]:\n    screen_coords = io.MousePos\n    world_ray = polyscope.screen_coords_to_world_ray(screen_coords)\n    world_pos = polyscope.screen_coords_to_world_position(screen_coords)\n\n    print(f\"Click coords: {screen_coords}\")\n    print(f\"  world ray: {world_ray}\")\n    print(f\"  world pos: {world_pos}\")\n</code></pre></p> <code>screen_coords_to_world_ray(screen_coords)</code> <code>screen_coords_to_world_position(screen_coords)</code>"},{"location":"features/callbacks_and_UIs/#screen-coords-to-world-ray","title":"screen coords to world ray","text":"<p>Convert a click location to a ray in world-space.</p>"},{"location":"features/callbacks_and_UIs/#screen-coords-to-world-position","title":"screen coords to world position","text":"<p>Convert a click location to a location in world-space, by reading from the scene\u2019s depth buffer.</p>"},{"location":"features/color_maps/","title":"Color Maps","text":""},{"location":"features/color_maps/#built-in-color-maps","title":"Built-in color maps","text":"<p>Different color maps are appropriate for different situations:</p> <ul> <li>sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below).</li> <li>diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases <code>0</code> semantially means \u201cnothing\u201d, and the endpoints have opposite meaning.</li> <li>cyclic maps data defined on the circle, like an angle</li> <li>decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes</li> </ul> <p>Polyscope supports the following built-in color maps:</p> Name Type String Key viridis sequential <code>viridis</code> blues sequential <code>blues</code> reds sequential <code>reds</code> coolwarm diverging <code>coolwarm</code> pink-green diverging <code>pink-green</code> phase cyclic <code>phase</code> spectral decorative <code>spectral</code> rainbow decorative <code>rainbow</code> jet decorative <code>jet</code> turbo decorative <code>turbo</code>"},{"location":"features/color_maps/#loading-custom-color-maps","title":"Loading custom color maps","text":"<p>Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from <code>[Appearance] --&gt; [Color maps] --&gt; [Load color map]</code>, or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting <code>stb_image</code> can read).</p> <p></p> <code>load_color_map(cmap_name, filename)</code> <ol> <li> <p>Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9</p> </li> <li> <p>Phase is from the <code>cmocean</code> package. link \u21a9</p> </li> <li> <p>Turbo is by Anton Mikhailov and others at Google. link \u21a9</p> </li> <li> <p>The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib.\u00a0\u21a9</p> </li> </ol>"},{"location":"features/color_maps/#load_color_map","title":"load_color_map","text":"<p>Load a new colormap from the image file <code>filename</code>, which will be assigned the name <code>cmap_name</code>.</p> <p>Example: <pre><code>import polyscope as ps\n\nps.load_color_map(\"fancy cmap\", \"my_cmap.png\")\n</code></pre></p>"},{"location":"features/ground_and_shadows/","title":"Ground and Shadows","text":"<p>The Polyscope scene view includes a ground plane which optionally supports reflection and soft-shadow effects. This section outlines the various modes and options available for the ground plane.</p> <p></p>"},{"location":"features/ground_and_shadows/#ground-plane-and-shadow-modes","title":"Ground plane and shadow modes","text":"<ul> <li><code>none</code> no ground plane, nor reflection/shadows are shown</li> <li><code>tile</code> a tiled ground plane </li> <li><code>tile_reflection</code> a tiled ground plane with a reflection of the scene (default)</li> <li><code>shadow_only</code> a transparent ground plane with a soft vertical shadow of the scene</li> </ul> <p>The ground plane and shadow settings can also be manually adjusted in the GUI under the <code>[Appearance] --&gt; [Ground Plane]</code> menu.</p> <p>Example: adjust the ground plane &amp; shadow appearance</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# set soft shadows on the ground\nps.set_ground_plane_mode(\"shadow_only\")  # set +Z as up direction\nps.set_ground_plane_height_factor(-0.25) # adjust the plane height\nps.set_shadow_darkness(0.1)              # lighter shadows\n\n\n# ... load your mesh, point cloud, etc ...\n\n# take screenshot from the current camera view, which will have transparent shadows\nps.screenshot(\"test_image.png\", True);\n\n# open the GUI\nps.show(3)\n</code></pre> <code>set_ground_plane_mode(mode_str)</code> <p>Set the mode used for the ground plane, as described above. Should be one of <code>none</code>, <code>tile</code>, <code>tile_reflection</code>, or <code>shadow_only</code>.</p> <p>Default: <code>tile_reflection</code>.</p> <p>Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set <code>alpha = shadow_darkness</code> values for shadowed areas, and set <code>alpha=0</code> for unshadowed parts of the ground plane.</p> <p>The <code>shadow_blur_iters</code> and <code>shadow_darkness</code> parameters below adjust the visual appearance of soft shadows for the ground plane mode <code>shadow_only</code>.</p> <code>set_shadow_blur_iters(i)</code> <p>The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy.</p> <p>Default: <code>2</code>. </p> <code>set_shadow_darkness(val)</code> <p>How dark the shadows are. <code>0</code> is totally transparent (white), and <code>1</code> is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions.</p> <p>Default: <code>.25</code>. </p>"},{"location":"features/ground_and_shadows/#ground-plane-positioning","title":"Ground plane positioning","text":"<p>The orientation of the ground plane is determined by the up direction for the scene, which can be set along any of the coordinate directions such as <code>+X</code>, <code>-Z</code>, etc.</p> <p>The height of the ground plane is set by default from the bounding box of the scene. The <code>options::groundPlaneHeightFactor</code> can be set to adjust the relative offset of the ground plane from the bounding box.</p> <code>set_ground_plane_height_factor(x, is_relative=True)</code> <p>The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down.</p> <p>This parameter is a scaled value. By default, values will be interpreted relative to the scene length scale, whereas calling <code>set_ground_plane_height_factor(0.1, is_relative=False)</code> will specify a value in absolute units.</p> <p>Default: <code>0</code>. </p>"},{"location":"features/groups/","title":"Groups","text":"<p>To manage large numbers of structures, or manage structures which are related to each other, you can gather them in groups. A group is a collection of structures which can be enabled/disabled together and hidden from the UI if needed. A structure can be in 0, 1, or many groups. Groups can also hold other groups, allowing nested organization.</p>    Your browser does not support the video tag.  <p>Example: Basic usage of groups</p> <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# make a point cloud\npts = np.zeros((300,3))\npsCloud = ps.register_point_cloud(\"my cloud\", pts)\n\n# make a curve network\nnodes = np.zeros((4,3))\nedges = np.array([ [1, 3], [3, 0], [1, 0], [0, 2] ])\npsCurve = ps.register_curve_network(\"my network\", nodes, edges)\n\n# create a group for these two objects\ngroup = ps.create_group(\"my group\")\npsCurve.add_to_group(group) # you also say psCurve.add_to_group(\"my group\")\npsCloud.add_to_group(group)\n\n# toggle the enabled state for everything in the group\ngroup.set_enabled(False)\n\n# hide items in group from displaying in the UI\n# (useful if you are registering huge numbers of structures you don't always need to see)\ngroup.set_hide_descendants_from_structure_lists(True)\ngroup.set_show_child_details(False)\n\n# nest groups inside of other groups\nsuper_group = ps.create_group(\"py parent group\")\nsuper_group.add_child_group(group)\n\nps.show(3)\n</code></pre>"},{"location":"features/groups/#create-get-and-remove-groups","title":"Create, get, and remove groups","text":"<code>create_group(name)</code> <code>get_group(name)</code> <code>remove_group(group, error_if_absent=true)</code> <code>removeAllGroups()</code>"},{"location":"features/groups/#create-group","title":"create group","text":"<p>Create a new group and return it. Group name must be a unique string (no other group may have that name).</p> <p>Returns the new group object.</p>"},{"location":"features/groups/#get-group","title":"get group","text":"<p>Get an existing group by name. </p> <p>Returns the group object.</p>"},{"location":"features/groups/#remove-group","title":"remove group","text":"<p>Remove an existing group. </p> <p>The <code>group</code> argument can be either a group object or a group name string.</p>"},{"location":"features/groups/#remove-all-groups","title":"remove all groups","text":"<p>Removes all existing groups.</p>"},{"location":"features/groups/#group-membership","title":"Group membership","text":"<code>Structure.add_to_group(group)</code> <code>Group.add_child_structure(newChild)</code> <code>Group.remove_child_structure(child)</code> <code>Group.add_child_group(newChild)</code> <code>Group.remove_child_group(child)</code>"},{"location":"features/groups/#add-structure-to-group","title":"add structure to group","text":"<p>Add a structure as a member of a group.</p> <p>The <code>group</code> argument can be either a group object or a group name string.</p> <p>Note that this is a member function of a structure object, like <code>pointCloud.add_to_group(group)</code>.</p>"},{"location":"features/groups/#add-child-structure","title":"add child structure","text":"<p>Add a structure as a member of this group</p>"},{"location":"features/groups/#remove-child-structure","title":"remove child structure","text":"<p>Remove a structure as a member of this group</p>"},{"location":"features/groups/#add-child-group","title":"add child group","text":"<p>Add a group as a (nested) member of this group</p> <p>The <code>group</code> argument can be either a group object or a group name string.</p>"},{"location":"features/groups/#remove-child-group","title":"remove child group","text":"<p>Remove a group as a (nested) member of this group</p> <p>The <code>group</code> argument can be either a group object or a group name string.</p>"},{"location":"features/groups/#group-settings","title":"Group settings","text":"<code>Group.set_enabled(newVal)</code> <code>Group.set_show_child_details(newVal)</code> <code>Group.set_hide_descendants_from_structure_lists(newVal)</code>"},{"location":"features/groups/#set-enabled","title":"set enabled","text":"<p>Set all descendants of a group to be enabled or disabled (applies to direct members of a group, as well as recursively to all members-of-members for nested groups).</p> <p>The <code>newVal</code> argument is a bool.</p>"},{"location":"features/groups/#show-ui-details","title":"show UI details","text":"<p>If true, the Groups section of the ImGui UI panel will show each childs structure info as a submenu under the group. If false, only the group name and toggle checkbox will be shown.</p> <p>The <code>newVal</code> argument is a bool.</p> <p>(Default: true)</p>"},{"location":"features/groups/#hide-from-structure-list","title":"hide from structure list","text":"<p>If true, the structures which are members of this group (or descendants in any nested groups) will be hidden from the ImGui UI panel structure list.</p> <p>The <code>newVal</code> argument is a bool.</p> <p>(Default: false)</p>"},{"location":"features/implicit_helpers/","title":"Implicit Helpers","text":"<p>Implicit functions take an xyz position as input, and return a value. Polyscope contains several helper features to directly visualize implicit functions by taking a callable as input and automatically invoking it as needed. This can be a much easier way to interface with volumetric and inherently implicit data. In particular, Polyscope contains a built-in renderer to render images of levelsets of implicit functions.</p> <p>Batch Evaluation</p> <p>In principle, an implicit function takes a single xyz position as input, and returns a single value. However, Polyscope might need to invoke the callback function millions of times, which can introduce excessive performance overhead, especially if the underlying function is being evaluated on a GPU, or due to cross-language binding overhead. For this reason, we use batch evaluation, to perform many evaluations with each invocation and amortize the overhead.</p> <p>Implict helpers expect you to pass a callback function which takes as input an <code>(N,3)</code> numpy array of query positions, and returns an <code>(N,)</code> array of evaluated values (or returns <code>(N,3)</code> array of colors for color functions). <code>N</code> is the number of queries, which will be determined as-needed internally by Polyscope.</p>"},{"location":"features/implicit_helpers/#directly-rendering-implicit-isosurfaces","title":"Directly Rendering Implicit Isosurfaces","text":"<p>Polyscope can directly render images of an isosurface of an implicit function in space, from the current viewport or from a defined camera view. The resulting renders are added as Render Images, which support material shading, colormapping, transparency, and depth-compositing with other content in the scene.</p> <p></p> <p>Not a Fast Renderer</p> <p>There is a long history of highly efficient real-time implicit shaders and ray marchers in computer graphics. Polyscope\u2019s built-in implicit ray marching renderer is not fast, and it never will be! It should be viewed as a debugging tool, not a real-time renderer. Its design fundamentally prioritizes ease-of-use over speed; for instance even if your function is defined on the GPU, Polyscope will perform many expensive CPU round-trips to render it, doing multiple evaluations of the given implicit function.</p> <p>If you want real-time implicit rendering, you will need to perform that rendering outside of Polyscope. However, the resulting renders can still be added to Polyscope as a Render Image to take advantage of Polyscope\u2019s functionality. You can even use direct GPU interop (beta feature!) to do so with minimal realtime overhead.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# define some implicit functions\ndef sphere_sdf(pts): # takes [N,3] query pos array, returns [N,] SDF values\n    res = np.linalg.norm(pts, axis=-1) - 1.\n    return res\ndef color_func(pts): # takes [N,3] query pos array, returns [N,3] color values\n    A = np.ones_like(pts) * 0.3\n    A[:,0] = np.cos(3*pts[:,0])**2\n    return A\n\n# render from the current view\nps.render_implicit_surface(\"sphere sdf\", sphere_sdf, \n                           mode='sphere_march', enabled=True)\nps.render_implicit_surface_color(\"sphere sdf\", sphere_sdf, color_func, \n                                 mode='sphere_march', enabled=True)\n\nps.show()\n</code></pre></p>"},{"location":"features/implicit_helpers/#implicit-render-options","title":"Implicit Render Options","text":"<p>The most important option to set the <code>mode</code> for the renderer. There are two choices:</p> <ul> <li><code>mode='sphere_march'</code> should be used if your implicit function is a Signed Distance Function (SDF). That is, its magnitude gives the distance to the surface, or at least a conservative bound on the distance. This allows the renderer to take large steps based on the SDF value.</li> <li><code>mdoe='fixed_step</code> must be used if your implicit function is not necessarily an SDF. This forces to renderer to take many small steps, which is inefficient but always works for sufficiently small step size.</li> </ul> <p>The following options can be set as additional keywords arguments to any render function</p> <ul> <li><code>camera_view</code> a <code>CameraView</code> structure (or the string name of one). If given, the render will be performed from the viewpoint of that camera, and the resulting render image will be added to the camera</li> <li><code>camera_parameters</code> a <code>CameraParameters</code> object defining the view to render from. If is not passed, then the current viewport will be used, unless the <code>camera_view</code> arg is set, in which case that camera will be used instead</li> <li><code>dim</code> 2-tuple of ints giving the dimension to render at (if rendering from the current view, this may be omitted, and the viewport resolution will be used)</li> <li><code>subsample_factor</code> int, if <code>dim</code> is being set automatically, downscale it by this factor (e.g. <code>subsample_factor=2</code> means use <code>dimX/2</code> and <code>dimY/2</code>)</li> <li><code>miss_dist</code> float, an absolute value for how far a ray must go to be considered a miss</li> <li><code>miss_dist_relative</code> float, a relative value for how far a ray must go to be considered a miss (default: 20.)</li> <li><code>hit_dist</code> float, an absolute value for how close a ray must go to be considered a hit</li> <li><code>hit_dist_relative</code> float, a relative value for how close a ray must go to be considered a hit (default: 1e-4)</li> <li><code>step_factor</code> float, a small tolerance factor applied to step sizes (default: 0.99)</li> <li><code>normal_sample_eps</code> float, a relative numerical parameter for finite differences normals (default: 1e-3)</li> <li><code>step_size</code> float, the absolute step size to used for <code>fixed_step</code> marching</li> <li><code>step_size_relative</code> float, the relative step size to used for <code>fixed_step</code> marching (default: 1e-2)</li> <li><code>n_max_steps</code> int, the maximum number of steps to take (default: 1024)</li> </ul> <p>For options which have an absolute and relative version, you may specify either but not both. Relative values are defined with respect to the scene length scale.</p>"},{"location":"features/implicit_helpers/#render-depth-images","title":"Render Depth Images","text":"<p>Render a depth Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting.</p> <code>render_implicit_surface(name, func, mode, color=None, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-scalar-images","title":"Render Scalar Images","text":"<p>Render a scalar Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting. An additional implicit function defines a scalar value which will be shaded with colormapping on the isosurface.</p> <code>render_implicit_surface_scalar(name, func, func_scalar, mode, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>func_scalar</code> another batch callable defining a scalar function which will be evaluated on the isosurface and displayed with color mapping</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-color-images","title":"Render Color Images","text":"<p>Render a color Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting. An additional implicit function defines a color value which will be shaded with colormapping on the isosurface.</p> <code>render_implicit_surface_color(name, func, func_color, mode, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>func_color</code> another batch callable defining a color function which will be evaluated on the isosurface and displayed with color mapping</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-raw-color-images","title":"Render Raw Color Images","text":"<p>Render a raw color Render Image of the 0 isosurface of a function. An additional implicit function defines a color value which will be used on the isosurface. The difference between color and raw color images is that plain <code>Color</code> rendered images apply lighting and material shading to the colors (like a <code>SurfaceMesh</code> would), whereas <code>RawColor</code> images really just directly display the given color as the pixel values.</p> <code>render_implicit_surface_raw_color(name, func, func_color, mode, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>func_color</code> another batch callable defining a color function which will be evaluated on the isosurface</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#implicit-volumes","title":"Implicit Volumes","text":"<p>In addition rendering isosurfaces, Polyscope can automatically register the implicit function as a volumetric grid of values. See the volume grid scalar quantity for details.</p>"},{"location":"features/materials/","title":"Materials","text":"<p>Polyscope uses matcaps to render the appearance of objects in the scene, as opposed to more traditional configurations of lights and shading models, etc. A matcap is a small image of a material, which is sampled by the renderer to query the materials\u2019 appearance from a some angle. Scene information like lighting is implicitly baked in to the matcap image.</p> <p>Most objects in Polyscope (surface meshes, point clouds, vectors, etc) expose a <code>material='matname'</code> option to choose a material for the object\u2019s appearance. Additionally, materials can generally be set in the UI from <code>[Options] --&gt; [Material]</code>.</p>"},{"location":"features/materials/#blended-materials","title":"Blended materials","text":"<p>In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities).  Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps.</p> How it works <p>Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components.</p> <p> </p> <p>At runtime, to generate a color from a triple of <code>rgb</code> values each in the range <code>[0,1]</code>, we sample the images like:</p> <pre><code>outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k\n</code></pre> <p>Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color.  Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space.</p> <p>Materials which which support this blending are denoted by <code>(rgb)</code> in the options menu.  Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options.</p>"},{"location":"features/materials/#preserving-colors-with-the-flat-material","title":"Preserving colors with the flat material","text":"<p>Generally, Polyscope applies material shading and tone-mapping to render 3D content. However, this means that data such as colors and tonemapped scalars will be a somewhat different color on-screen compared to what is in the data.</p> <p>The <code>flat</code> material is special: it not only applies flat coloring with no shading effects, but furthermore cancels-out tonemapping and other effects to ensure that the color you see onscreen is exactly the same as the data specified.</p> <p>Use the <code>flat</code> material any time you need exact color reproduction.</p>"},{"location":"features/materials/#built-in-materials","title":"Built-in materials","text":"<p>Polyscope supports the following built-in materials:</p> Name String Key Blendable Image clay <code>clay</code> yes wax <code>wax</code> yes candy <code>candy</code> yes flat <code>flat</code> yes mud1 <code>mud</code> no ceramic1 <code>ceramic</code> no jade1 <code>jade</code> no normal1 <code>normal</code> no"},{"location":"features/materials/#loading-custom-materials","title":"Loading custom materials","text":"<p>Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from <code>[Appearance] --&gt; [Materials] --&gt; [Load material]</code>, or programatically using the function below. For blendable matcaps, if the single filename <code>mat.hdr</code> is given, Polyscope will try to load <code>mat_r.hdr</code>, <code>mat_g.hdr</code>, etc.</p> <p>Ideally, matcap images should be linear <code>.hdr</code> images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with <code>intensity=1</code> and <code>gamma=2.2</code> before use.  Most common image formats are accepted (anything <code>stb_image</code> can read).</p> <code>load_static_material(mat_name, filename)</code> <code>load_blendable_material(mat_name, filenames=None, filename_base=None, filename_ext=None)</code> <ol> <li> <p>The matcaps are from the Blender matcap repository, available under a CC0/public domain license. Thanks to the Blender community for contributing them!\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"features/materials/#load_static_material","title":"load_static_material","text":"<p>Load a new static (non-blendable) material from a single image file <code>filename</code>. The new material will be called <code>mat_nam</code>.</p> <p>Example: <pre><code>import polyscope as ps\n\nps.load_static_material(\"fancy mat\", \"my_image.png\")\n</code></pre></p>"},{"location":"features/materials/#load_blendable_material","title":"load_blendable_material","text":"<p>Load a new blendable material, which will be called <code>matName</code>.</p> <p>There are two different ways to specify which files to load the material images from:</p> <ul> <li>Specify <code>filenames</code>, a tuple of four string filenames corresponding to red, green, blue, and black basis materials</li> <li>Specify <code>filename_base</code>, and <code>filename_ext</code>, to generate the four filenames as <code>filename_base + \"_r\" + filename_ext</code>, etc.</li> </ul> <p>Example: <pre><code>import polyscope as ps\n\nps.load_blendable_material(\"fancy blendable mat\", filenames = (\n                            \"my_image_r.png\",\n                            \"my_image_g.png\",\n                            \"my_image_b.png\",\n                            \"my_image_k.png\"\n                          ))\n\n# OR\n\nps.load_blendable_material(\"fancy blendable mat\", filename_base=\"my_image\", filename_ext=\".png\")\n</code></pre></p>"},{"location":"features/messages/","title":"Messages","text":""},{"location":"features/messages/#using-messages","title":"Using messages","text":"<p>We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging.  Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way.</p> <p>There are a few levels of messages available:</p> <ul> <li>error A very bad error; immediately shows and blocks the UI for user response.</li> <li>warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program.</li> <li>info A low-priority message, which is just printed to <code>stdout</code>.</li> </ul> <p>Messages can be dismissed by clicking the button in dialog box, or pressing <code>[space]</code>.</p> <p></p> <p>Example: <pre><code>import polyscope as ps\nps.init()\n\n# Generate a single warning.\n# Has no effect on the GUI until polyscope gets control flow\n# back, which happens here in the show() call below.\nps.warning(\"Something went slightly wrong\")\n\n# Generate a lot of warnings. Becase all of these warnings \n# have the same base message (the first string), they will \n# be batched together and only shown as one dialog. The detail \n# message for the first such warning will also be shown.\nfor i in range(5000):\n  ps.warning(\"Some problems come in groups\", \"some details: \" + str(i))\n\n# The previous warnings would be displayed here\nps.show()\n\n# Generating an error.\n# The UI will block and show this error immediately. After \n# the error is dismissed, the call will return.\nps.error(\"Resistance is futile.\");\n</code></pre></p>"},{"location":"features/messages/#messages","title":"Messages","text":"<code>info(message)</code> <code>warning(message, detail=\"\")</code> <code>error(message)</code>"},{"location":"features/messages/#info","title":"info","text":"<p>Simply logs a message to <code>stdout</code>.</p>"},{"location":"features/messages/#warning","title":"warning","text":"<p>Create a warning message, to be displayed the next time the UI gets flow control. </p> <p>When issuing a one-off warning, the <code>detail</code> field need not be used.  However, if issuing warnings in a loop, warnings with the same base <code>message</code> are batched together, so the UI doesn\u2019t get completely overwhelmed (see example above).</p>"},{"location":"features/messages/#error","title":"error","text":"<p>Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.</p>"},{"location":"features/screenshots/","title":"Screenshots","text":"<p>Polyscope includes simple functionality for saving screenshots from the current camera view to disk. The ImGUI interface windows will be automatically hidden when taking a screenshot.</p> <p>Screenshots can be taken manually by pressing the <code>[screenshot]</code> button in the options GUI window, or programmatically using the functions below. Clicking the GUI button generates a numbered screenshot file in the current directory; the arrow to the side of the button can be used to adjust file format and transparency settings for these screenshots.</p> <p>It is not necessary to call <code>show()</code> before taking screenshots. You can set up you scene and programmatically configure the camera view, then call <code>screenshot()</code> to save a rendered image to disk, all without any user interaction.</p> <p>Example: Register a mesh, position the camera, and take a screenshot <pre><code>import polyscope as ps\n\n# Initialize\nps.init()\n\n# Register a mesh\nverts = # ... your data ...\nfaces = # ... your data ...\nps_mesh = ps.register_surface_mesh(\"my mesh\", verts, faces)\n\n# Position the camera\nps.look_at((0., 0., 5.), (1., 1., 1.))\n\n# Adjust some screenshot default settings if you'd like\nps.set_screenshot_extension(\".jpg\");\n\n# Take a screenshot\n# It will be written to your current directory as screenshot_000000.jpg, etc\nps.screenshot()\n</code></pre></p> <code>screenshot(filename=None, transparent_bg=True)</code> <p>Saves a screenshot to the path given as <code>filename</code>, with format inferred from the file extension. </p> <p>The extension should be one of <code>.png</code>, or <code>.jpg</code>.</p> <p>If no name is is given, screenshots are saved to the current directory, with file named like <code>screenshot_000000.png</code> numbered automatically in increasing order. The numbering is reset to <code>0</code> for each run of the program; existing files will be silently overwritten.</p> <p>If <code>transparent_bg</code> is <code>true</code>, the background will be rendered as transparent, and set as transparency alpha in the saved image if the file format supports it.</p> <code>set_screenshot_extension(ext)</code>"},{"location":"features/screenshots/#screenshot-extension","title":"screenshot extension","text":"<p>Set the extension used when taking automatically-numbered screenshots, either with <code>screenshot()</code> or by clicking the GUI button.</p> <p>The extension should be <code>.png</code>, or <code>.jpg</code>.</p>"},{"location":"features/slice_planes/","title":"Slice Planes","text":"<p>Geometric data often has complex internal structures. Slice planes can be added to the scene to cull away parts of an object and inspect its interior. These planes can be manipulated either programmatically or manually in the GUI.</p>    Your browser does not support the video tag.  <p>Example: sweep a slice plane through the scene to produce the animation above</p> <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# Read &amp; register the mesh\nvertices = # your vertices\nfaces = # your faces\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# Add a slice plane\nps_plane = ps.add_scene_slice_plane()\nps_plane.set_draw_plane(True) # render the semi-transparent gridded plane\nps_plane.set_draw_widget(True)\n\n# Animate the plane sliding along the scene\nfor t in np.linspace(0., 2*np.pi, 120):\n    pos = np.cos(t) * .8 + .2\n    ps_plane.set_pose((0., 0., pos), (0., 0., -1.))\n\n    # Take a screenshot at each frame\n    ps.screenshot(transparent_bg=False)\n</code></pre> <p>Slice planes can also be manipulated in the GUI under <code>[View] --&gt; [Slice Planes]</code>, where you can add and remove slice planes and control whether they are active and widgets are visible. When a plane is active in the scene, you can drag the 3D widget to adjust its pose. Additionally, for each structure, <code>[Options] --&gt; [Slice Planes]</code> allows you to toggle whether the slice plane effects that structure.</p>"},{"location":"features/slice_planes/#creating-and-modifying-slice-planes","title":"Creating and modifying slice planes","text":"<code>SlicePlane add_scene_slice_plane()</code> <code>remove_last_scene_slice_plane()</code> <code>SlicePlane.get_name()</code> <code>SlicePlane.set_pose(plane_position, plane_normal)</code> <code>SlicePlane.set_active(val)</code> <code>SlicePlane.get_active()</code> <p>Test whether the slice plane is active.</p> <code>SlicePlane.set_draw_plane(val)</code> <code>SlicePlane.get_draw_plane()</code> <p>Test whether the slice plane is drawing its plane.</p> <code>SlicePlane.set_draw_widget(val)</code> <code>SlicePlane.get_draw_widget()</code> <p>Test whether the slice plane is drawing its widget.</p>"},{"location":"features/slice_planes/#add-slice-plane","title":"add slice plane","text":"<p>Add a new slice plane to the scene and return it. An arbitrary number of slices planes may be added.</p>"},{"location":"features/slice_planes/#remove-slice-plane","title":"remove slice plane","text":"<p>Remove the most recently created slice plane.</p>"},{"location":"features/slice_planes/#name","title":"name","text":"<p>Get the unique name of the slice plane.</p>"},{"location":"features/slice_planes/#set-pose","title":"set pose","text":"<p>Set the position and orientation of the slice plane.</p> <ul> <li><code>plane_position</code> is any 3D position which the plane touches (the center of the plane)</li> <li><code>plane_normal</code> is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled</li> </ul> <p>These input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p>"},{"location":"features/slice_planes/#active","title":"active","text":"<p>Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view.</p>"},{"location":"features/slice_planes/#draw-plane","title":"draw plane","text":"<p>Set the slice plane to draw its plane (as a colored, semi-transparent grid). If <code>False</code> the slice plane will still slice objects, but the plane itself will not be rendered.</p>"},{"location":"features/slice_planes/#draw-widget","title":"draw widget","text":"<p>Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If <code>False</code> the slice plane will still slice objects, but the widget will not be rendered.</p> <p>Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes.</p>"},{"location":"features/slice_planes/#per-structure-ignore-slice-planes","title":"Per-structure ignore slice planes","text":"<p>By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under <code>[Options] --&gt; [Slice Planes]</code>, or programatically with the function below.</p> <pre><code>ps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps_plane = ps.add_scene_slice_plane()\nps_mesh.set_ignore_slice_plane(ps_plane, True)\n</code></pre> <code>Structure.set_ignore_slice_plane(plane, val)</code> <code>Structure.get_ignore_slice_plane(plane)</code> <p>Test if a slice plane is currently being ignored by the structure.</p> <p><code>plane</code> can be passed as a plane object or as a string giving the name of a plane.</p>"},{"location":"features/slice_planes/#ignore-plane","title":"ignore plane","text":"<p>Set a slice plane to be ignored by the structure. If <code>val</code> is <code>True</code> the slice plane will be ignored, and if <code>False</code> it will be respected.</p> <p><code>plane</code> can be passed as a plane object or as a string giving the name of a plane.</p>"},{"location":"features/slice_planes/#cull-whole-elements","title":"Cull whole elements","text":"<p>For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element.  This option can be set in the GUI for each structure under <code>[Options] --&gt; [Slice Planes]</code>, or programatically with the function below.</p> <p></p> <pre><code>ps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps_plane = ps.add_scene_slice_plane()\nps_mesh.set_cull_whole_elements(False)\n</code></pre> <code>Structure.set_cull_whole_elements(val)</code> <code>Structure.get_cull_whole_elements()</code> <p>Test whether the cull whole elements setting is applied.</p>"},{"location":"features/slice_planes/#set-cull-whole-elements","title":"set cull whole elements","text":"<p>If <code>True</code>, slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements.</p> <p>Note that not all structures may support culling whole elements. If not supported, this setting will do nothing.</p>"},{"location":"features/slice_planes/#inspecting-volume-meshes","title":"Inspecting volume meshes","text":"<p>Slice planes can also inspect volume meshes, rendering a surface where the structure is cut by the plane. Not only does this help to visualize the interior of the shape, but scalar and color quantities can be drawn along the plane to better inspect values on the interior of the mesh.</p> <p>This can also be set in the UI under <code>[View] --&gt; [Slice Planes] --&gt; [Inspect]</code>. This option will only be available when there is at least one volume mesh in the scene.</p> <p>If the volume mesh has a vertex scalar or vertex color quantity enabled, it will be automatically drawn on the inspecting slice plane.</p> <code>SlicePlane.set_volume_mesh_to_inspect(meshNameStr)</code> <p>Give the name of a volume mesh to inspect. Pass the empty string <code>\"\"</code> to clear the inspection.</p> <code>SlicePlane.get_volume_mesh_to_inspect()</code> <p>Get the volume mesh being inspected. Returns a string.</p>"},{"location":"features/transparency/","title":"Transparency","text":"<p>The Polyscope rendering framework supports transparency to visualize complicated data with nested internal structures.</p> <p></p> <p>Example: register a surface mesh and render it with transparency</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# Add a mesh with transparency\n# ... load verts and faces ...\nps_mesh = ps.register_surface_mesh(\"mesh\", verts, faces, \n                                    transparency=0.7)\n\n# As soon as any structure has transparency set, the transparency mode\n# is automatically changed to 'pretty' (depth peeling). It can be further\n# changed like:\nps.set_transparency_mode('simple')\n\n# take screenshot from the current camera view, \n# which will have transparency according to the structure\nps.screenshot(\"test_image.png\", True);\n\n# open the GUI\nps.show(3)\n</code></pre>"},{"location":"features/transparency/#transparency-modes","title":"Transparency modes","text":"<p>In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering:</p> <ul> <li><code>'none'</code> is the default, which does not use any transparency and ignores any related settings.</li> <li><code>'simple'</code> uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use).</li> <li><code>'pretty'</code> implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling, which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter configured with <code>set_transparency_render_passes()</code> controls the number passes performed (default: <code>8</code>); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes.</li> </ul> <p>The modes are set via <code>set_transparency_mode</code>. Initially, the transparency mode is set to <code>'none'</code>. However, if the transparency of any object is modified while the mode is <code>'none'</code>, the mode will be automatically updated to <code>'pretty'</code> so that the effect is visible.</p> <p>Any ground plane reflections are disabled when using transparency.</p> <p>The transparency mode can also be changed in the GUI in the <code>[Appearance] --&gt; [Transparency]</code> menu.</p> <code>set_transparency_mode(mode_str)</code> <p>Set the mode used for transparent rendering. One of <code>'none'</code>, <code>'simple'</code>, or <code>'pretty'</code> (see above for explanation).</p> <p>Default: <code>'none'</code>. Automatically updated when a transparency value is set for some structure.</p> <code>set_transparency_render_passes(n)</code> <p>The number of passes used for <code>'pretty'</code> mode. Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes.</p> <p>Default: <code>8</code>. </p>"},{"location":"features/transparency/#setting-structure-transparency","title":"Setting structure transparency","text":"<p>Transparency is controlled via a real-valued parameter from <code>0</code> to <code>1</code>, commonly called \u201calpha\u201d. Setting transparency to <code>1</code> means completely opaque (the default), whereas <code>0</code> means completely transparent.  This parameter is specified on a per-structure basis via <code>Structure.set_transparency(val)</code>, or by using a <code>transparency</code> keyword argument when registering the structure.  Transparency for each structure can also be modified in the GUI by selecting <code>[Options] --&gt; [Transparency]</code> for the structure.</p> <code>Structure.set_transparency(val)</code> <p>Set the transparency for a structure, <code>1</code> means completely opaque (the default), whereas <code>0</code> means completely transparent.</p> <p>Example: <pre><code>ps_mesh = polyscope.register_surface_mesh(\"mesh\", verts, faces)\nps_mesh.set_transparency(0.5)\n</code></pre></p>"},{"location":"installing/","title":"Installing","text":"<p>Polyscope supports Python 3.5-3.9 with prebuilt binaries on all major operating systems. At runtime, your environment must support OpenGL &gt;= <code>3.3 core</code>, and have the ability to open windows in a display. This includes nearly all modern desktop/laptop computers, but not all headless servers and virtual machines.</p>"},{"location":"installing/#installing-from-pypi-with-pip","title":"Installing from PyPi with pip","text":"<p><pre><code>python -m pip install polyscope\n# or maybe\npython3 -m pip install polyscope\n</code></pre> Using <code>python -m pip install</code> rather than just <code>pip install</code> helps when your system has multiple version of Python installed, ensuring the correct <code>pip</code> is used. Just be sure <code>python</code> refers to the install of Python you intend to use.</p> <p>Ideally, this install will resolve to a precompiled wheel for your platform\u2014see troubleshooting if not. Otherwise, the setup script will compile the Polyscope C++ library from source, which may take a few minutes, and requires a suitable C++ toolchain (see building from source).</p>"},{"location":"installing/#troubleshooting","title":"Troubleshooting","text":"<p>On common platforms, <code>pip</code> should always be able to install from a binary <code>.whl</code> file. If it fails to select a binary wheel, it will try to compile from source, leading to long install times or compilation errors if your toolchain is not configured.</p> <p>Here are some common fixes: </p> <ul> <li>Ensure you\u2019re targeting the latest Polyscope <code>python -m pip install polyscope --upgrade</code></li> <li>Very old versions of <code>pip</code> may not be able to use the precompiled wheels. Upgrade <code>pip</code> with <code>python -m pip install pip --upgrade</code>.</li> <li>Precompiled wheels are available on pip for Python 3.5-3.9 (aka most common versions), check yours with <code>python --version</code>, and update your Python install if needed.</li> </ul>"},{"location":"installing/#source-installs-with-pypi","title":"Source installs with PyPI","text":"<p>Despite our best efforts, the precompiled binaries still may not work on some platforms. You can intentionally instruct <code>pip</code> to build the library from source using: <pre><code>python -m pip install polyscope --no-binary polyscope\n</code></pre> This may take a few minutes, and requires a suitable C++ toolchain (see building from source).</p>"},{"location":"installing/#installing-from-conda","title":"Installing from Conda","text":"<pre><code>conda install -c conda-forge polyscope\n</code></pre>"},{"location":"installing/#installing-manually","title":"Installing manually","text":"<p>To manually download the sources:</p> <pre><code>git clone --recursive https://github.com/nmwsharp/polyscope-py.git\ncd polyscope-py\n</code></pre> <p>Polyscope can then by installed with pip as <pre><code>python -m pip install .\n</code></pre></p> <p>Or manually installed with the setup script using <pre><code>python setup.py install\n</code></pre></p>"},{"location":"installing/#building-from-source","title":"Building from source","text":"<p>If a pre-compiled wheel is not available, the setup scripts (either run automatically via <code>pip</code> or manually with <code>setup.py</code>) will need to compile the underlying C++ library. Your system must have a suitable C++ compiler available to build Polyscope, as well as build tools like CMake installed. The Polyscope C++ repository has a few more details about compiling. Polyscope is a 3D graphics program, so it may be difficult to build on servers without graphics support, or extremely old machines. In particular, OpenGL &gt;= <code>3.3 core</code> is a strict requirement.</p>"},{"location":"installing/#development-builds","title":"Development builds","text":"<p>To compile Polyscope locally without <code>setup.py</code> (e.g., if you are developing the library) use</p> <pre><code>git clone --recursive https://github.com/nmwsharp/polyscope-py.git\ncd polyscope-py\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j4\n</code></pre> <p>this will generate a file something like <code>polyscope_bindings.cpython-36m-x86_64-linux-gnu.so</code> (the particular name depends on your platform), which contains the low-level bindings to C++ Polyscope. This is a pybind11 build; it can be further customized using any pybind11 CMake options, for instance to choose which version of Python is used.</p> <p>The actual Polyscope python library lives in <code>src/polyscope</code>, which is a wrapper around these low-level bindings. You are now ready to <code>import polyscope</code>, so long as both the compiled bindings and <code>src/polyscope</code> can be found on your <code>PYTHONPATH</code>.</p>"},{"location":"structures/structure_management/","title":"Structure Management","text":"<p>A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields.</p> <p>Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: <pre><code>ps.register_surface_mesh(\"my mesh\", vertices, faces)\n</code></pre> Then, in a distant part of your code, add a scalar function to it with: <pre><code>ps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"some values\", values)\n</code></pre> This avoids the need to pass a reference to the structure you created around your entire codebase. Alternately, one can directly use the handle returned by <code>register_surface_mesh()</code>, instead of keying on a name string.</p>"},{"location":"structures/structure_management/#registering-structures","title":"Registering structures","text":"<p>Each structure offers a <code>register___(name, ...)</code> function (like <code>register_point_cloud()</code>) which accepts the name of the structure and the data necessary to construct it. These functions will return a structure object which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions.</p>"},{"location":"structures/structure_management/#accessing-structures","title":"Accessing structures","text":"<p>Polyscope offers two patterns for calling methods on a registered structure: you can either use the handle returned after structure creation, or refer to the structure by name.</p> <p><pre><code>import polyscope as ps\n\n# register a structure\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# access with the handle\nps_mesh.add_scalar_quantity(\"some values\", values)\n\n# access by name\nps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"some values\", values)\n</code></pre> The former is concise and programmatic, while the latter avoids the need to keep track of a variable.</p> <p>As before, each structure offers a <code>get___(name)</code> method, like <code>get_surface_mesh(name)</code> which can be used to get a handle to the structure of that type by name.</p>"},{"location":"structures/structure_management/#removing-structures","title":"Removing structures","text":"<p>If no longer needed, structures can be removed by name or by handle. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities.</p> <pre><code>import polyscope as ps\n\n# register a structure and some data\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps_mesh.add_scalar_quantity(\"some values\", values)\n\n# look at it\nps.show()\n# (user exits ui)\n\n\n# remove the structure\n# (these two forms are equivalent, choose one) \nps_mesh.remove()\nps.remove_surface_mesh(\"my_mesh\")\n\n\n# actually, just remove everything\nps.remove_all_structures()\n</code></pre>"},{"location":"structures/structure_management/#structure-options","title":"Structure options","text":"<p>These basic options are shared by all structures.  Structure options are managed as persistent values, and thus will persist if a new structure is registered with the same name.</p>"},{"location":"structures/structure_management/#enabled","title":"Enabled","text":"<p>If a structure is disabled, it will be hidden from view, along with any quantities associated with that structure.</p> <code>Structure.is_enabled()</code> <p>Is the structure enabled? Returns a boolean.</p> <code>Structure.set_enabled(newVal=True)</code> <p>Set the structure to be enabled or disabled. Takes a boolean.</p> <p>Can also be set when registering, like <code>register_point_cloud(..., enabled=True)</code>.</p>"},{"location":"structures/structure_management/#transparency","title":"Transparency","text":"<p>Set the transparency parameter for the structure. <code>1</code> is fully opaque (the default), and <code>0</code> is fully transparent. When the first structure has transparency applied, transparent rendering will be automatically enabled.</p> <p>Transparency can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Transparency]</code> menu.</p> <code>Structure.get_transparency()</code> <p>Get the transparency parameter for the structure. Returns a float</p> <code>Structure.set_transparency(alpha)</code> <p>Set the transparancy for the structure. Takes a float.</p> <p>Can also be set when registering, like <code>register_point_cloud(..., transparency=0.5)</code>.</p>"},{"location":"structures/structure_management/#transforms","title":"Transforms","text":"<p>Each structure has an associated spatial transform applied to it for display in the scene. The transform encodes a translation, rotation, and scaling represented as a 4x4 homogeneous matrix. Initially this transformation is just the identity transform (it does nothing), but it can be adjusted to position the structures in your scene.</p> <p>The transform can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Transform]</code> menu.</p> <code>Structure.center_bounding_box()</code> <p>Set the transformation such that the structure\u2019s bounding box is centered at the world origin.</p> <code>Structure.rescale_to_unit()</code> <p>Set the transformation scaling such that the structure has length scale 1. This makes all structures roughly the same size.</p> <code>Structure.reset_transform()</code> <p>Reset the structure\u2019s transform to be the identity transform (i.e. to do nothing).</p> <code>Structure.set_transparency(transform)</code> <p>Set a particular transform matrix. Takes a 4x4 numpy array.</p> <code>Structure.set_position(vec)</code> <p>Set the transformation matrix such that structure is transformed to the position <code>vec</code>. Takes a length-3 numpy vector.</p> <code>Structure.translate(vec)</code> <p>Translate the transformation matrix by offset <code>vec</code>. Takes a length-3 numpy vector.</p> <code>Structure.get_transform()</code> <p>Get the current transformation matrix. Returns a 4x4 numpy matrix.</p> <code>Structure.get_position()</code> <p>Get the translation component of the transformation matrix, the position to which the structure\u2019s origin is translated. Returns a length-3 numpy vector.</p>"},{"location":"structures/structure_management/#slice-planes","title":"Slice planes","text":"<p>Options relating to slice planes which may be present in the scene.</p> <p>Slice plane options can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Slice Planes]</code> menu.</p> <code>Structure.set_cull_whole_elements(newVal)</code> <p>If <code>true</code>, slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Takes a boolean.</p> <p>Note that not all structures may support culling whole elements. If not supported, this setting will do nothing.</p> <p>Default: false.</p> <code>Structure.get_cull_whole_elements()</code> <p>Get whether the cull whole elements setting is applied. Returns a boolean.</p> <code>Structure.set_ignore_slice_plane(name, newValue)</code> <p>Set a slice plane to be ignored by the structure. If <code>newValue</code> is <code>true</code> the slice plane will be ignored, and if <code>false</code> it will be respected. Takes a string and a boolean.</p> <code>Structure.get_ignore_slice_plane(name)</code> <p>Get if a slice plane is currently being ignored by the structure. Takes a string, returns a boolean.</p>"},{"location":"structures/camera_view/basics/","title":"Camera Views","text":"<p>Use camera view structures to represent pinhole cameras in a 3D scene. Given camera locations, orientations, and field of view (intrinsics + extrinsics), Polyscope will draw a camera frame on the scene. Images quantities can be associated with the cameras and displayed on the camera frame. You can even align the interactive viewport with a selected camera.</p>    Your browser does not support the video tag.  <p>Add an Image Quantity!</p> <p>Camera views structures on their own are not so interesting; they are simplify displayed as a wireframe camera widget in the viewport.</p> <p>Try adding an Image Quantitiy to the camera view. When image quantities are added to camera view structures, they gain the additional ability to be displayed in the camera\u2019s frame.</p> <p>Example:</p> <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# Create a camera view from parameters\nintrinsics = ps.CameraIntrinsics(fov_vertical_deg=60, aspect=2)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., -1.,-1.), up_dir=(0.,1.,0.))\nparams = ps.CameraParameters(intrinsics, extrinsics)\ncam = ps.register_camera_view(\"cam\", params)\n\n# Set some options for the camera view\n# these can also be set as keyword args in register_camera_view()\ncam.set_widget_focal_length(0.75)          # size of displayed widget (relative value)\ncam.set_widget_thickness(0.25)             # thickness of widget lines\ncam.set_widget_color((0.25, 0.25, 0.25))   # color of widget lines\n\n\n# Add an image to be displayed in the camera frame\ndimX = 600\ndimY = 300\ncam.add_scalar_image_quantity(\"scalar_img\", np.zeros((dimX, dimY)),\n                              enabled=True, show_in_camera_billboard=True)\n\nps.show(3)\n</code></pre>"},{"location":"structures/camera_view/basics/#registering-a-camera-view","title":"Registering a Camera View","text":"<p>Camera views are created from Camera Parameters.</p> <p>Note that we do not specify an image resolution for the camera view. It can hold images of any resolution, as long as the aspect ratio is right.</p> <code>register_camera_view(name, params, **kwargs)</code> <p>Add a new camera view structure to Polyscope.</p> <ul> <li><code>params</code> is a Camera Parameters.</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>widget_focal_length</code> float, size of displayed widget (relative value)</li> <li><code>widget_thickness</code> float, thickness of widget lines</li> <li><code>widget_color</code> float 3-tuple, color of widget lines</li> </ul> <p>As with all structures, there is also <code>get_camera_view(\"name\")</code>, <code>has_camera_view(\"name\")</code>, and <code>remove_camera_view(\"name\")</code>.</p>"},{"location":"structures/camera_view/basics/#updating-a-camera-view","title":"Updating a Camera View","text":"<p>You can update the parameters associated with a camera view to move it within the scene after creation.</p> <code>CameraView.update_camera_parameters(new_params)</code> <p>Update camera parameters.</p> <ul> <li><code>params</code> is a Camera Parameters.</li> </ul>"},{"location":"structures/camera_view/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? focal length size of rendered widget <code>get_widget_focal_length()</code> <code>set_widget_focal_length(newVal, relative=true)</code> yes thickness rendered widget line thickness <code>get_widget_thickness()</code> <code>set_widget_thickness(newVal)</code> yes color widget color <code>get_widget_color()</code> <code>set_widget_color(newVal)</code> yes"},{"location":"structures/curve_network/basics/","title":"Curve Networks","text":"<p>Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network.</p> <p>Try clicking on a node or edge to see the data associated with that point!</p> <p></p>"},{"location":"structures/curve_network/basics/#registering-a-curve-network","title":"Registering a curve network","text":"<p>Curve network structures can be registered with Polyscope by passing the node position and edge indices. Polyscope also makes it easy to automatically construct lines and loops by just passing <code>edges='line'</code> or <code>edges='loop'</code>.</p> <p>Example: a network of random curves  <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# generate some random nodes and edges between them\nnodes = np.random.rand(100, 3)\nedges = np.random.randint(0, 100, size=(250,2))\n\n# visualize!\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\nps.show()\n</code></pre></p> <code>register_curve_network(name, nodes, edges, enabled=None, radius=None, color=None, material=None)</code> <p>Add a new curve network structure to Polyscope.</p> <ul> <li><code>name</code> string, a name for the structure</li> <li><code>nodes</code>, an <code>Nx3</code> numpy float array of node locations (or <code>Nx2</code> for 2D)</li> <li><code>edges</code>, an <code>Ex2</code> numpy integer array of edge connections, as 0-based indices in to the nodes array, OR the string <code>line</code>/<code>loop</code>,  to generate node connectivity as a line or loop, respectively.</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>radius</code> float, a size for the nodes and edges relative to the scene length scale (use <code>set_radius(val, relative=False)</code> for absolute units)</li> <li><code>color</code> float 3-tuple, default color values for the network as rgb in [0,1]</li> <li><code>material</code> string, name of material to use for network </li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>2D node positions are also supported, see 2D data.</p>"},{"location":"structures/curve_network/basics/#updating-a-curve-network","title":"Updating a curve network","text":"<p>The locations of the nodes in a curve network can be updated with the member function <code>update_node_positions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite).</p> <code>CurveNetwork.update_node_positions(newPos)</code> <p>Update the node positions in a curve network structure. <code>newPos</code> must be valid input as to initially construct the nodes of the network, with the same number of nodes as the network curently has.</p>"},{"location":"structures/curve_network/basics/#options","title":"Options","text":"<p>Options control the appearance of the curve network. These options can also be passed as keyword arguments to the initial <code>register_curve_network()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? radius size of rendered nodes/edges <code>get_radius()</code> <code>set_radius(newVal, relative=True)</code> yes color default color for the network <code>get_color()</code> <code>set_color(newVal)</code> yes material material for structure <code>get_material()</code> <code>set_material(newVal)</code> yes <p>Example: set options which affect the appearance of the curve network <pre><code>network = polyscope.register_curve_network(\"my net\", nodes, edges)\n\nnetwork.set_enabled(False) # disable\nnetwork.set_enabled() # default is true\n\nnetwork.set_radius(0.02) # radius is relative to a scene length scale by default\nnetwork.set_radius(1.7, relative=False) # radius in absolute world units\n\nnetwork.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\nnetwork.set_material(\"candy\")\nnetwork.set_transparency(0.5)\n\n# alternately:\nps.register_curve_network(\"my net 2\", nodes, edges, enabled=False, \n                           material='candy', radius=0.02, color=(1., 0., 0.),\n                           transparency=0.5)\n</code></pre></p>"},{"location":"structures/curve_network/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the nodes or edges of a curve network.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a curve network \nN_node = 100\nN_edge = 250\nnodes = np.random.rand(N_node, 3)\nedges = np.random.randint(0, N_node, size=(N_edge,2))\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\n\n# visualize some random colors per-node\nvals_node = np.random.rand(N_node, 3)\nps_net.add_color_quantity(\"rand vals\", vals_node, enabled=True)\n\n# visualize some random colors per-edge\nvals_edge = np.random.rand(N_edge, 3)\nps_net.add_color_quantity(\"rand vals2\", vals_edge, defined_on='edges')\n\n\n# view the network with all of these quantities\nps.show() \n</code></pre></p> <code>CurveNetwork.add_color_quantity(name, values, defined_on='nodes', enabled=None)</code> <p>Add a scalar quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at nodes/edges</li> <li><code>defined_on</code> string, one of <code>\"nodes\"</code> or <code>\"edges\"</code>, is this data a color per-node or a value per-edge?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/curve_network/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/curve_network/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar valued data at the nodes or edges of a curve network.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a curve network \nN_node = 100\nN_edge = 250\nnodes = np.random.rand(N_node, 3)\nedges = np.random.randint(0, N_node, size=(N_edge,2))\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\n\n# visualize some random data per-node\nvals_node = np.random.rand(N_node)\nps_net.add_scalar_quantity(\"rand vals\", vals_node, enabled=True)\n\n# visualize some random data per-edge\nvals_edge = np.random.rand(N_edge)\nps_net.add_scalar_quantity(\"rand vals2\", vals_edge, defined_on='edges')\n\n# as always, we can customize the initial appearance\nps_net.add_scalar_quantity(\"rand vals2 opt\", vals_edge, defined_on='edges', \n                           enabled=True, vminmax=(-3., 3.), cmap='reds')\n\n\n# view the network with all of these quantities\nps.show() \n</code></pre></p> <code>CurveNetwork.add_scalar_quantity(name, values, defined_on='nodes', enabled=None, datatype=\"standard\", vminmax=None, cmap=None)</code> <p>Add a scalar quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at nodes/edges</li> <li><code>defined_on</code> string, one of <code>\"nodes\"</code> or <code>\"edges\"</code>, is this data a value per-node or a value per-edge?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/curve_network/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/curve_network/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the nodes or edges of a curve network.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a curve network \nN_node = 100\nN_edge = 250\nnodes = np.random.rand(N_node, 3)\nedges = np.random.randint(0, N_node, size=(N_edge,2))\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\n\n# visualize some random vectors per-node\nvecs_node = np.random.rand(N_node, 3)\nps_net.add_vector_quantity(\"rand vecs\", vecs_node, enabled=True)\n\n# visualize some random vectors per-edge\nvecs_edge = np.random.rand(N_edge, 3)\nps_net.add_vector_quantity(\"rand vecs edge\", vecs_edge, defined_on='edges')\n\n# set radius/length/color of the vectors\nps_net.add_vector_quantity(\"rand vecs opt\", vecs_node, radius=0.001, length=0.005, color=(0.2, 0.5, 0.5))\n\n# ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space\nps_net.add_vector_quantity(\"vecs ambient\", vecs_node, vectortype='ambient')\n\n# view the network with all of these quantities\nps.show() \n</code></pre></p> <code>CurveNetwork.add_vector_quantity(name, values, defined_on='nodes', enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at nodes/edges (or <code>Nx2</code> for 2D data)</li> <li><code>defined_on</code> string, one of <code>nodes</code> or <code>edges</code>, is this data a vector per-node or a vector per-edge?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/curve_network/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/basics/","title":"Basics","text":"<p>Most quantities in Polyscope are associated with a particular structure, such as a <code>PointCloudScalarQuantity</code> on a <code>PointCloud</code>. In contrast, Floating Quantities are generic quantities which can be added to any and all kinds of structures. You can also add them to the root level of the scene, not associated with any structure. </p> <p>One example of a floating quantity is an Images Quantity. You might want to visualize a single image, not specific to any structure, by adding it to the scene at the root level. Or, you might have an image associated with a particular mesh, in which case you could add the image quantity to that <code>SurfaceMesh</code> structure.</p> <p>TL;DR What are floating quantities?</p> <p>Floating quantities are quantities that are general and not specific to any kind of structure.</p> <p>You have two options for how to add them:</p> <ul> <li>Add them as standalone quantities in the scene at the root level, like <code>polyscope.add_image_quantity(...)</code>.</li> <li>Add them to any structure of any type, like <code>pointCloud.add_image_quantity(...)</code>. This can be useful to associate the quantity with a structure.</li> </ul> <p>The sub-menus to the left give the various floating quantities available.</p>"},{"location":"structures/floating_quantities/images/","title":"Images","text":"<p>Images are rectangular grids of pixel values.</p> <p>Sample: An image quantity of a majestic cat, shown here in the ImGui window display mode.</p> <p></p> <p>Floating Quantities</p> <p>Images are floating quantities, which means they can be added to the scene at the root level, or added to any kind of structure.</p> <p>See the floating quantity introduction for more info.</p> <p>Example:</p> <pre><code>import polyscope as ps\nps.init()\n\n# Your image data, must be populated somehow\ndimX = 1024\ndimY = 768\n\n# == Add images at the root level of the scene\n# try out a few of the options while we're at it\n\nps.add_color_image_quantity(\"color_img\", np.zeros((dimX, dimY, 3)), enabled=True, \n                            show_fullscreen=True, show_in_camera_billboard=False, transparency=0.5)\n\nps.add_color_alpha_image_quantity(\"color_alpha_img\", np.zeros((dimX, dimY, 4)), enabled=True, \n                                  show_in_imgui_window=True, show_in_camera_billboard=False,\n                                  is_premultiplied=True, image_origin='lower_left')\n\nps.add_scalar_image_quantity(\"scalar_img\", np.zeros((dimX, dimY)), enabled=True, \n                             image_origin='lower_left', \n                             datatype='symmetric', vminmax=(-3.,.3), cmap='reds')\n\n\n# == Add images associated with a structure\n# Here, a camera view, you could also use a point cloud, or a mesh, etc\ncam = ps.get_camera_view(\"my view\"); # some structure you previously registered\n\ncam.add_color_image_quantity(\"color_img\", np.zeros((dimX, dimY, 3)), enabled=True,\n                             show_in_camera_billboard=True)\n                             # when adding an image to a camera view, we can display it\n                             # in the camera billboard\n\nps.show()\n</code></pre> <p>Images vs. Render Images</p> <p>If your image happens to represent a rendering of the scene from the user\u2019s viewport (for example, from custom renderer code), check out the Render Image quantity, which offers additional functionality for view-rendered images such as depth-compositing them into the scene to layer and blend with other content.</p> <p>Camera Views</p> <p>Image quantities get special functionality when added to <code>CameraView</code> structures: they can additionally be displayed in the camera frame, aligned with the view of the scene.</p>"},{"location":"structures/floating_quantities/images/#image-origin","title":"Image Origin","text":"<p>When registering an image quantity, you can also specify whether the image should be interpreted such that the first row is the \u201ctop\u201d row of the image (<code>'upper_left'</code>), or the first row is the \u201cbottom\u201d row of the image (<code>'lower_left'</code>). This is a confusing issue, as there are many overlapping conventions of coordinate systems and buffer layouts for images.</p> <p>Most of the time, <code>'upper_left'</code> (the default) is the right choice.</p>"},{"location":"structures/floating_quantities/images/#scalar-image-quantity","title":"Scalar Image Quantity","text":"<p>These can be called at the root level, like <code>ps.add_scalar_image_quantity()</code>, or on a structure, like <code>cam_view.add_scalar_image_quantity()</code>.</p> <code>add_scalar_image_quantity(name, values, **kwargs)</code> <p>Add an image of scalar values</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>WxH</code> numpy array, with scalar values</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/images/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/images/#color-image-quantity","title":"Color Image Quantity","text":"<p>These can be called at the root level, like <code>ps.add_color_image_quantity()</code>, or on a structure, like <code>cam_view.add_color_image_quantity()</code>.</p> <code>add_color_image_quantity(name, values_rgb, **kwargs)</code> <p>Add an image of rgb color values</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values_rgb</code> an <code>WxHx3</code> numpy array, with color values</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <code>add_color_alpha_image_quantity(name, values_rgba, **kwargs)</code> <p>Add an image of rgb color values</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values_rgba</code> an <code>WxHx4</code> numpy array, with color values</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>By default, alpha values are interpreted to be non-premultiplied. Use the keyword argument <code>is_premultiplied=True</code> to directly pass premultiplied alpha images.</p>"},{"location":"structures/floating_quantities/images/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/images/#image-options","title":"Image Options","text":"<p>These options are common to all images</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>transparency</code> float, an opacity to apply to the image</li> <li><code>image_origin</code> string, either <code>upper_left</code> (default) or <code>lower_left</code> to give the row layout convention</li> <li><code>show_fullscreen</code> boolean, if enabled the image will be shown fullscreen in the Polyscope window</li> <li><code>show_in_imgui_window</code> boolean, if enabled the image will be shown in an ImGui window</li> <li><code>show_in_camera_billboard</code> boolean, if this image was added to a camera view structure, show it in the camera frame</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/render_images/","title":"Render Images","text":"<p>Render images are special images which are renderings of scene through the Polyscope viewport. These are useful when using Polyscope to visualize renders from your own custom renderers, such as ray tracers, SDF-field implicit tracers, or neural field renderers.</p> <p>Render images always show the image in fullscreen viewport. Additional, depth and transparency allow the image to be composited with other scene content, so that you can still see your usual Polyscope meshes and point clouds in the scene along with the outputs of your renderer.</p> <p>Sample: A colored box and scalar torus, displayed as render images from a user\u2019s custom implicit surface renderer.</p> <p></p> <p>Floating Quantities</p> <p>Render images are floating quantities, which means they can be added to the scene at the root level, or added to any kind of structure.</p> <p>It is most common to add render image quantities at the root level. However, it might still be useful to add render images to structures, to associate the rendering with a particular structure, e.g. as a separate rendering of each point cloud in the scene.</p> <p>See the floating quantity introduction for more info.</p>"},{"location":"structures/floating_quantities/render_images/#image-origin","title":"Image Origin","text":"<p>When registering an image quantity, you can also specify whether the image should be interpreted such that the first row is the \u201ctop\u201d row of the image (<code>'upper_left'</code>), or the first row is the \u201cbottom\u201d row of the image (<code>'lower_left'</code>). This is a confusing issue, as there are many overlapping conventions of coordinate systems and buffer layouts for images.</p> <p>Most of the time, <code>'upper_left'</code> (the default) is the right choice.</p>"},{"location":"structures/floating_quantities/render_images/#depth-render-image-quantity","title":"Depth Render Image Quantity","text":"<p>A depth render image quantity takes a depth value per-pixel, and (optionally) a world-space normal per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\ndimX = 1024\ndimY = 768\ndepths = np.zeros((dimX, dimY))\nnormals = np.ones((dimX, dimY, 3))\n\nps.add_depth_render_image_quantity(\"render_img\", depths, normals, \n                                   enabled=True, image_origin='upper_left', \n                                   color=(0., 1., 0.), material='wax', transparency=0.7,\n                                   allow_fullscreen_compositing=True)\n\npolyscope::show(3);\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <code>add_depth_render_image_quantity(name, depths, normals, **kwargs)</code> <p>Add a depth render image.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>WxH</code> numpy array, with scalar depth values</li> <li><code>normals</code> an <code>WxHx3</code> numpy array, with world-space normals values, or <code>None</code> to automatically compute normals</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#color-render-image-quantity","title":"Color Render Image Quantity","text":"<p>A color render image quantity takes a depth value per-pixel, (optionally) a world-space normal per-pixel, and a color value per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials, colored according to the given color.</p> <p>Color vs. Raw Color Render Images</p> <p>A color render image applies materials shading and lighting to the image, just like Polyscope usually does for meshes and other objects. A raw color render image does not do any additional shading, and simply displays the given colors directly onto the screen.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\ndimX = 1024\ndimY = 768\ndepths = np.zeros((dimX, dimY))\nnormals = np.ones((dimX, dimY, 3))\ncolors = np.ones((dimX, dimY, 3))\n\nps.add_color_render_image_quantity(\"render_img\", depths, normals, colors, \n                                   enabled=True, image_origin='upper_left', \n                                   material='wax', transparency=0.7, )\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <code>add_color_render_image_quantity(name, depths, normals, colors, **kwargs)</code> <p>Add a depth render image, annotated with additional color values per-pixel.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>WxH</code> numpy array, with scalar depth values</li> <li><code>normals</code> an <code>WxHx3</code> numpy array, with world-space normals values, or <code>None</code> to automatically compute normals</li> <li><code>colors</code> an <code>WxHx3</code> numpy array, with colors</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/render_images/#scalar-render-image-quantity","title":"Scalar Render Image Quantity","text":"<p>A scalar render image quantity takes a depth value per-pixel, (optionally) a world-space normal per-pixel, and a scalar value per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials, with the scalar value shaded and colormapped as a scalar quantity.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\ndimX = 1024\ndimY = 768\ndepths = np.zeros((dimX, dimY))\nnormals = np.ones((dimX, dimY, 3))\nscalars = np.ones((dimX, dimY))\n\nps.add_scalar_render_image_quantity(\"render_img3\", depths, normals, scalars, \n                                     enabled=True, image_origin='upper_left', \n                                     vminmax=(-3.,.3), cmap='reds')\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <code>ps.add_scalar_render_image_quantity(name, depths, normals, scalars, **kwargs)</code> <p>Add a depth render image, annotated with additional scalar values per-pixel.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>WxH</code> numpy array, with scalar depth values</li> <li><code>normals</code> an <code>WxHx3</code> numpy array, with world-space normals values, or <code>None</code> to automatically compute normals</li> <li><code>scalars</code> an <code>WxH</code> numpy array, with scalar values</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/render_images/#raw-color-render-image-quantity","title":"Raw Color Render Image Quantity","text":"<p>A raw color render image quantity takes a depth value per-pixel and a color value per-pixel. The colors will be directly displayed onscreen, with depth compositing into the scene.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\ndimX = 1024\ndimY = 768\ndepths = np.zeros((dimX, dimY))\ncolors = np.ones((dimX, dimY, 3))\n\nps.add_raw_color_render_image_quantity(\"render_img3\", depths, colors, \n                                       enabled=True, allow_fullscreen_compositing=True)\n</code></pre></p> <p>Color vs. Raw Color Render Images</p> <p>A color render image applies materials shading and lighting to the image, just like Polyscope usually does for meshes and other objects. A raw color render image does not do any additional shading, and simply displays the given colors directly onto the screen.</p> <code>add_raw_color_render_image_quantity(name, depths, colors, **kwargs)</code> <p>Add a raw color render image described by pixel color and depth.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>WxH</code> numpy array, with scalar depth values</li> <li><code>colors</code> an <code>WxHx3</code> numpy array, with colors</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#raw-color-alpha-render-image-quantity","title":"Raw Color Alpha Render Image Quantity","text":"<p>Just like the above <code>ColorRenderImageQuantity</code>, but with an additional alpha channel which gets alpha-composited onto the scene.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\ndimX = 1024\ndimY = 768\ndepths = np.zeros((dimX, dimY))\ncolor_alphas = np.ones((dimX, dimY, 4))\n\nps.add_raw_color_alpha_render_image_quantity(\"render_img3\", depths, color_alphas, \n                                             enabled=True, image_origin='upper_left', \n                                             is_premultiplied=True)\n</code></pre></p> <code>add_raw_color_alpha_render_image_quantity(name, depths, color_alphas, **kwargs)</code> <p>Add a raw color render image described by RGBA pixel color and depth.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>WxH</code> numpy array, with scalar depth values</li> <li><code>colors_alphas</code> an <code>WxHx4</code> numpy array, with colors</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p> <p>By default, alpha values are interpreted to be non-premultiplied. Use <code>is_premultiplied=True</code> to directly pass premultiplied alpha images.</p>"},{"location":"structures/floating_quantities/render_images/#render-image-options","title":"Render Image Options","text":"<p>These options are common to all render images</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled </li> <li><code>transparency</code> float, an opacity to apply to the image</li> <li><code>image_origin</code> string, either <code>upper_left</code> (default) or <code>lower_left</code> to give the row layout convention</li> <li><code>material</code> string, material name for the surface rendering</li> <li><code>allow_fullscreen_compositing</code>, boolean, if <code>False</code> only one render image is displayed at a time (default), if <code>True</code>, multiple can be displayed and will layer on top of each other, although the render order is arbitrary</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>Raw color render images ignore material-related settings.</p>"},{"location":"structures/point_cloud/basics/","title":"Point Clouds","text":"<p>Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points.</p> <p>As always, try clicking on a point to see the data associated with that point.</p> <p></p>"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","title":"Registering a point cloud","text":"<p>Example: a point cloud of random points <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# generate some points\npoints = np.random.rand(100, 3)\n\n# visualize!\nps_cloud = ps.register_point_cloud(\"my points\", points)\nps.show()\n\n# with some options\nps_cloud_opt = ps.register_point_cloud(\"my points\", points, \n                                       radius=0.02, point_render_mode='quad')\nps.show()\n</code></pre></p> <code>register_point_cloud(name, points, enabled=None, radius=None, point_render_mode=None, color=None, material=None)</code> <p>Add a new point cloud structure to Polyscope.</p> <ul> <li><code>name</code> is the name for the structure, as a string</li> <li><code>points</code> is an <code>N x 3</code> numpy array of point locations</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>radius</code> float, a size for the points relative to the scene length scale (use <code>set_radius(val, relative=False)</code> for absolute units)</li> <li><code>color</code> float 3-tuple, default color values for the points as rgb in [0,1]</li> <li><code>material</code> string, name of material to use for cloud</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>2D point clouds are also supported, see 2D data.</p> <p>As with all structures, there is also <code>get_point_cloud(\"name\")</code>, <code>has_point_cloud(\"name\")</code>, and <code>remove_point_cloud(\"name\")</code>.</p>"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","title":"Updating a point cloud","text":"<p>The locations of the points in a point cloud can be updated with the member function <code>update_point_positions(newPositions)</code>. All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one).</p> <p>Example: update positions (continued from above) <pre><code>new_pos = np.random.rand(100, 3)\nps_cloud.update_point_positions(new_pos)\nps.show()\n</code></pre></p> <code>PointCloud.update_point_positions(newPos)</code> <p>Update the point positions in a point cloud structure. <code>newPos</code> must be valid input as to initially construct a point cloud, with the same number of points.</p>"},{"location":"structures/point_cloud/basics/#point-render-mode","title":"Point render mode","text":"<p>By default, Polyscope renders point clouds with a sphere for each point. However, for large point clouds (for instance, &gt; 500,000 points, or on low-end hardware), this sphere rendering may become prohibitively expensive and lead to a laggy interface. As an alternative, points can be rendered as a small quad per-point, which is more efficient (for instance, it renders in real-time with 20,000,000+ points on my mid-range GPU).</p> <p></p> <p>The point render mode setting specifies which style is used:</p> <ul> <li><code>sphere</code> a small sphere is drawn for each point (default)</li> <li><code>quad</code> a small quad is drawn for each point</li> </ul> <code>PointCloud.set_point_render_mode(newVal)</code> <p>Set the the rendering method used to draw each point. Pass the string name of the style to use. One of <code>'sphere'</code> (default) or <code>'quad'</code>.</p> <p>As usual, this can also be set as a keyword argument when the point cloud is registered, like <code>register_point_cloud('my points', data, point_render_mode='quad')</code>.</p> <p>There is also a corresponding <code>get_point_render_mode()</code>.</p>"},{"location":"structures/point_cloud/basics/#options","title":"Options","text":"<p>Options control the appearance of the cloud. These options can also be passed as keyword arguments to the initial <code>register_point_cloud()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? point radius size of rendered points <code>get_radius()</code> <code>set_radius(newVal, relative=True)</code> yes point color default color for points <code>get_color()</code> <code>set_color(newVal)</code> yes point render mode how to draw points <code>get_point_render_mode()</code> <code>set_point_render_mode(newVal)</code> yes material material for point <code>get_material()</code> <code>set_material(newVal)</code> yes <p>Example: set options which affect the appearance of the point cloud <pre><code>cloud = polyscope.register_point_cloud(\"my points\", points)\n\ncloud.set_enabled(False) # disable\ncloud.set_enabled() # default is true\n\ncloud.set_radius(0.02) # radius is relative to a scene length scale by default\ncloud.set_radius(1.7, relative=False) # radius in absolute world units\n\ncloud.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\ncloud.set_material(\"candy\")\ncloud.set_transparency(0.5)\n\n# alternately:\nps.register_point_cloud(\"my points 2\", points, enabled=False, material='candy',\n                        radius=0.02, color=(1., 0., 0.)\n                        transparency=0.5)\n</code></pre></p>"},{"location":"structures/point_cloud/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the points of a point cloud.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a point cloud\nN = 100\npoints = np.random.rand(N, 3)\nps_cloud = ps.register_point_cloud(\"my points\", points, enabled=True)\n\n# generate some random color per-point\nvals = np.random.rand(N,3)\n\n# basic color visualization\nps_cloud.add_color_quantity(\"rand colors\", vals)\n\nps.show() \n</code></pre></p> <code>PointCloud.add_color_quantity(name, values, enabled=None)</code> <p>Add a color quantity to the point cloud.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at points</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/point_cloud/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the points of a point cloud.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a point cloud\nN = 100\npoints = np.random.rand(N, 3)\nps_cloud = ps.register_point_cloud(\"my points\", points)\n\n# generate some random data per-point\nvals = np.random.rand(N)\n\n# basic visualization\nps_cloud.add_scalar_quantity(\"rand vals\", vals)\n\n# manually specify a range for colormapping\nps_cloud.add_scalar_quantity(\"rand vals with range\", vals, vminmax=(-5., 5.), enabled=True)\n\n# use a different colormap\nps_cloud.add_scalar_quantity(\"rand vals with range\", vals, cmap='blues')\n\n# use the 'datatype' to specify default visualization semantics\nvals_gaussian = np.random.normal(size=N)\nps_cloud.add_scalar_quantity(\"gaussian vals symmetric\", vals_gaussian, datatype='symmetric')\n\n# view the point cloud with all of these quantities\nps.show() \n</code></pre></p> <code>PointCloud.add_scalar_quantity(name, values, enabled=None, datatype=\"standard\", vminmax=None, cmap=None)</code> <p>Add a scalar quantity to the point cloud.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at points</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/point_cloud/variable_radius/","title":"Variable Radius","text":"<p>By default, all points in the cloud have the same radius. However, any point cloud scalar quantity can be additionally interpreted as the radius of the points. This can also be set manually in the GUI via the point cloud [Options] \u2013&gt; [Variable Radius].</p> <p></p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\n# ... setup, register a point cloud, etc ...\n\n// Get a reference to your point cloud\nps_cloud = ps.get_point_cloud(\"your point cloud name\")\n\n# Add a random scalar quantity\nN = ps_cloud.n_points()\nvals = np.random.rand(N)\nps_cloud.add_scalar_quantity(\"test_vals\", vals)\n\n# Set the quantity as the point size\nps_cloud.set_point_radius_quantity(\"test_vals\")\nps.show()\n\n# Clear it out, go back to default constant size\nps_cloud.clear_point_radius_quantity()\nps.show()\n\n# Set the quantity as the size using actual world-coordinate units,\n# rather than auto-scaling the size\nps_cloud.set_point_radius_quantity(\"test_vals\", autoscale=False)\nps.show()\n</code></pre></p> <p>Any negative values in the scalar quantity will be clamped to <code>0</code>. By default, values will be rescaled such that the largest corresponds to the size from the point radius option (thus, using any constant scalar quantity will make the radii identical to the default value with no radius set). This automatic scaling can be disabled by setting <code>autoscale=False</code> below.</p> <p>Reproducing radius in world units</p> <p>Remember that point clouds always have a per-structure <code>radius</code> parameter which sets a radius for all of the points in the point cloud (and can be adjusted via a slider in the GUI, or via <code>radius=0.1</code>/<code>set_radius()</code>). This per-structure parameter makes things a little more complicated when also setting length via a scalar quantity as described here.</p> <p>By default, the structure radius parameter is still respected. The variable radius from the quantity first scaled such that the largest value is <code>1.</code>, and then is multiplied by the structure parameter to get the actual radius used for the points.</p> <p>This usually gives a reasonable visualization, but makes it difficult to set a precise radius in world units.  To properly reproduce a radius in world-coordinate units, you can circumvent autoscaling like <code>cloud.set_point_radius_quantity(q, autoscale=False)</code>. This will prevent the auto-scaling of the radii, and also ignore the structure\u2019s point radius parameter.</p> <p>def      self.bound_cloud.set_point_radius_quantity(quantity_name, autoscale)</p> <p>def      self.bound_cloud.clear_point_radius_quantity()</p> <code>PointCloud.set_point_radius_quantity(quantity_name, autoscale=True)</code> <p>Set the point radius from a quantity by name. The quantity must be a point cloud scalar quantity add to this cloud.</p> <p>When using a radius which is a physical length in world coordinates, set <code>autoscale</code> to <code>False</code> to skip rescaling and ignore the structure\u2019s point radius parameter.</p> <code>PointCloud.clear_point_radius_quantity()</code> <p>Clear the point radius quantity and return to using the constant radius.</p>"},{"location":"structures/point_cloud/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the points of a point cloud.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a point cloud\nN = 100\npoints = np.random.rand(N, 3)\nps_cloud = ps.register_point_cloud(\"my points\", points)\n\n# generate some random vectors per-point\nvecs = np.random.rand(N, 3)\n\n# basic visualization\nps_cloud.add_vector_quantity(\"rand vecs\", vecs, enabled=True)\n\n# set radius/length/color of the vectors\nps_cloud.add_vector_quantity(\"rand vecs\", vecs, radius=0.001, length=0.005, color=(0.2, 0.5, 0.5))\n\n# ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space\nps_cloud.add_vector_quantity(\"vecs ambient\", vecs, vectortype='ambient')\n\n# view the point cloud with all of these quantities\nps.show() \n</code></pre></p> <code>PointCloud.add_vector_quantity(name, values, enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the point cloud.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at points (or <code>Nx2</code> for 2D data)</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/basics/","title":"Surface Meshes","text":"<p>Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/etc of the mesh.</p> <p>Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold, and all faces need not have the same degree.  As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.</p> <p></p>"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","title":"Registering a surface mesh","text":"<p>Example: registering a mesh <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nvertices = np.random.rand(100, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, 100, size=(250,3)) # (F,3) array of indices \n                                                # for triangular faces\n\n# visualize!\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps.show()\n</code></pre></p> <p>Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face.</p> <code>register_surface_mesh(name, vertices, faces, enabled=None, color=None, edge_color=None, smooth_shade=None, edge_width=None, material=None)</code> <p>Add a new surface mesh structure to Polyscope.</p> <ul> <li><code>name</code> string, a name for the structure</li> <li><code>vertices</code>, an <code>Nx3</code> numpy float array of vertex locations (or <code>Nx2</code> for 2D)</li> <li><code>faces</code>, an <code>FxD</code> numpy integer array of faces, as 0-based indices in to the vertices array, OR a plain python list-of-lists of indices (or really, anything twice-iterable which yields integers). The latter option enables meshes where not all faces have the same degree.</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>color</code> float 3-tuple, default color values for the mesh as rgb in [0,1]</li> <li><code>edge_color</code> float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set <code>edge_width</code> too)</li> <li><code>edge_width</code> float, width of edges in rendered mesh; default sets <code>0</code> to disable edges, <code>1</code> is a reasonable value to enable</li> <li><code>smooth_shade</code> boolean, if <code>True</code> use smooth shading (default: <code>False</code> for flat shading)</li> <li><code>material</code> string, name of material to use for the mesh</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>2D vertex positions are also supported, see 2D data.</p> <p>Element ordering</p> <p>Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions.</p> <p>The default ordering is probably the same as yours for data on vertices, faces, and corners. However, data on edges and halfedges is much more likely to require setting an ordering.</p>"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","title":"Updating a mesh","text":"<p>The locations of the vertices in a mesh can be updated with the member function <code>update_vertex_positions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite).</p> <code>SurfaceMesh.update_vertex_positions(newPos)</code> <p>Update the vertex positions in a surface mesh structure. <code>newPos</code> must be valid input as to initially construct the vertex positions, with the same number of vertices.</p>"},{"location":"structures/surface_mesh/basics/#picking","title":"Picking","text":"<p>\u201cPicking\u201d refers to selecting and inspecting elements by clicking on the object in the scene. By default only mesh vertices and faces can be selected. Edges, corners, and halfedges, become selectable only once they are used by some quantity, for instance once a per-corner quantity is registered, then it becomes possible to click on corners.</p> <p>If desired, you can manually override this behavior by calling <code>mesh.mark_edges_as_used()</code>, to make the structure act as if edges are in use and make the pickable, etc. The same goes for <code>mesh.mark_corners_as_used()</code> and <code>mesh.mark_halfedges_as_used()</code>. If you mark edges or halfedges as used, you much also set their element ordering as described in the indexing conventions.</p>"},{"location":"structures/surface_mesh/basics/#back-face-policies","title":"Back face policies","text":"<p>The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how back faces are displayed.</p> <p></p> <ul> <li><code>identical</code> all faces are always rendered identically, whether viewed from the front or back</li> <li><code>different</code> back faces are shaded slightly darker, so they can be distinguished (this is the default)</li> <li><code>custom</code> back faces are shaded with a configurable color</li> <li><code>cull</code> back faces are culled, and not rendered at all</li> </ul> <p>The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via <code>[Options] -&gt; [Back Face Policy]</code> or programmatically with the function below or when a mesh is registered.</p> <code>SurfaceMesh.set_back_face_policy(val)</code> <p>Set the policy for rendering oppositely-oriented back faces.</p> <ul> <li><code>newPolicy</code> is string giving the new policy, one of <code>identical</code>, <code>different</code>, <code>custom</code>, or <code>cull</code> as described above</li> </ul> <p>You can also set <code>back_face_policy='cull'</code> when registering a mesh.</p> <p>There is also a corresponding <code>SurfaceMesh.get_back_face_policy()</code>.</p> <code>SurfaceMesh.set_back_face_color(val)</code> <p>Set the color to be used for custom back face coloring as a 3-tuple of floats on [0,1]. Has no effect unless the back face policy is <code>custom</code>.</p> <p>There is also a corresponding <code>get_back_face_color()</code>.</p>"},{"location":"structures/surface_mesh/basics/#options","title":"Options","text":"<p>Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial <code>register_surface_mesh()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? surface color the color of the mesh <code>get_color()</code> <code>set_color(val)</code> yes edge color the color of the edges of the mesh <code>get_edge_color()</code> <code>set_edge_color(val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>get_edge_width()</code> <code>set_edge_width(val)</code> yes shade smooth use smooth shading along faces or simple flat faces <code>get_smoooth_shade()</code> <code>set_smooth_shade(isSmooth)</code> yes material material for structure <code>get_material()</code> <code>set_material(newVal)</code> yes back face policy what back face policy to use <code>get_back_face_policy()</code> <code>set_back_face_policy(val)</code> yes back face color back face color for the <code>custom</code> policy <code>get_back_face_color()</code> <code>set_back_face_color(val)</code> yes <p>Example: set options which affect the appearance of the mesh <pre><code>import numpy as np\nimport polyscope as ps\n\nvertices = np.random.rand(100, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, 100, size=(250,3)) # (F,3) array of indices \n                                                # for triangular faces\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\nps_mesh.set_enabled(False) # disable\nps_mesh.set_enabled() # default is true\n\nps_mesh.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\nps_mesh.set_edge_color((0.8, 0.8, 0.8)) \nps_mesh.set_edge_width(1.0)\nps_mesh.set_smooth_shade(True)\nps_mesh.set_material(\"candy\")\nps_mesh.set_transparency(0.5)\n\n# alternately:\nps.register_surface_mesh(\"my mesh2\", vertices, faces, enabled=False, \n                         color=(1., 0., 0.), edge_color=((0.8, 0.8, 0.8)),\n                         edge_width=1.0, smooth_shade=True,\n                         material='candy', transparency=0.5)\n</code></pre></p>"},{"location":"structures/surface_mesh/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the elements of a surface mesh.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# visualize some random data per-vertex\ncolors_vert = np.random.rand(N_vert, 3)\nps_mesh.add_color_quantity(\"rand colors\", colors_vert, enabled=True)\n\n# visualize some random data per-face\ncolors_face = np.random.rand(N_face, 3)\nps_mesh.add_color_quantity(\"rand colors2\", colors_face, defined_on='faces')\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p>"},{"location":"structures/surface_mesh/color_quantities/#add-colors-to-elements","title":"Add Colors to Elements","text":"<code>SurfaceMesh.add_color_quantity(name, values, defined_on='vertices', enabled=None, param_name=None, image_origin=\"upper_left\")</code> <p>Add a color quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at vertices/faces</li> <li><code>defined_on</code> string, one of <code>'vertices','faces','texture'</code>, is this data a color per vertex, per face, or texture image?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p> <p>The <code>param_name</code> and <code>image_origin</code> arguments are used only if <code>defined_on='texture'</code>. See below for details.</p>"},{"location":"structures/surface_mesh/color_quantities/#color-texture-maps","title":"Color Texture Maps","text":"<p>Texture images define data by storing it an image grid, and using coordinates defined on the face-corners or vertices of a mesh to sample values from the image for each point on the surface.</p> <p>To visualize color data defined in texture maps, first add a Parameterization Quantity (aka UV map) defining the coordinates. Then, add a buffer of image data to be sampled from.</p> <p>Example <pre><code>import numpy as np\nimport polyscope as ps\n\nps.init()\n\n# add a mesh\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3)\nfaces = np.random.randint(0, N_vert, size=(N_face,3))\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# add a parameterization (aka UV map)\nparam_vals = np.random.rand(ps_mesh.n_vertices(), 2)\nps_mesh.add_parameterization_quantity(\"test_param\", param_vals, \n                                      defined_on='vertices', enabled=True)\n\n# add the texture quantity\ndims = (200,300,3)\ncolor_vals = np.random.rand(*dims) # dummy placeholder image data\nps_mesh.add_color_quantity(\"test_vals\", color_vals, \n                           defined_on='texture', param_name=\"test_param\", \n                           enabled=True)\n\nps.show()\n</code></pre></p> <p>Texture image data is added via <code>add_color_quantity()</code>, with <code>defined_on='texture'</code> and <code>param_name=...</code> specifying the name of the parameterization UV map with coordinates on <code>[0,1]</code> which will be used to sample from the image.</p> <p>The texture image data, dimension, and origin conventions are the same as those used to define images. See there for details.</p>"},{"location":"structures/surface_mesh/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/count_quantities/","title":"Count quantities","text":"<p>Count quantities store integers defined at just a few elements of a mesh, rather than at every element.</p> <p>These useful for visualizing, e.g., singularities of a vector field at vertices.</p> <p>TODO</p> <p>TODO document count quantities. See <code>polyscope/surface_mesh.h</code> for add signatures.</p>"},{"location":"structures/surface_mesh/distance_quantities/","title":"Distance quantities","text":"<p>Visualize distance-valued data at the elements of a surface mesh.</p> <p>Distance quantities are basically scalars, but are visualized with alternating stripes to show distance contours.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\ndists = # your distances, a length N_vert array\n\n# visualize the distance\nps_mesh.add_distance_quantity(\"distances\", dists, enabled=True, stripe_size=0.01)\n\n# use defaults for signed distances\nps_mesh.add_distance_quantity(\"signed distances\", dists, signed=True)\n\n# view the mesh with these quantities\nps.show() \n</code></pre></p> <code>SurfaceMesh.add_distance_quantity(name, values, defined_on='vertices', enabled=None, signed=False, vminmax=None, stripe_size=None, stripe_size_relative=True, cmap=None)</code> <p>Add a distance quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, distance scalars </li> <li><code>defined_on</code> for now, only <code>'vertices'</code> is supported</li> <li><code>signed</code> boolean, if true the data is assumed to represent signed distances, and symmetric ranges/colormaps are used by default</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>vminmax</code> a 2-tuple of floats, specifying the min and max range to colormap in to</li> <li><code>stripe_size</code> float, the width of stripes in the visualization</li> <li><code>stripe_size_relative</code> boolean, if true <code>stripe_size</code> is interpreted relative to the scene length scale, otherwise absolute</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/indexing_convention/","title":"Indexing Convention","text":""},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","title":"Default ordering","text":"<p>Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i\u2019th edge in a mesh?</p> <p>For vertices and faces, Polyscope only supports one order: the order of the elements used when you registered the mesh. However, for edges, halfedges, and corners it is more complicated. For these data, you should generally explicitly tell Polyscope what ordering/indexing you will be using for the data.</p> <p>The way it works is that Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d, and you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element, visualizations of data on that element will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements.</p> <p>This section describes the remedy: you can give the mesh a \u201cpermutation\u201d, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation <code>p</code> should be an array of integers, such that if <code>i</code> is the i^\\textrm{th} element in the default ordering, <code>p[i]</code> gives the index under your convention. Your data arrays will then be indexed as <code>data[p[i]]</code> when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as <code>data[p[i]]</code> is always a valid access; if the size of your index space is different, a size can also be passed in (in this case we abuse terminology: it is not technically a permutation).</p> <p>The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.</p>"},{"location":"structures/surface_mesh/indexing_convention/#vertices-and-faces","title":"Vertices and Faces","text":"<p>For vertices and faces, Polyscope only supports one order: the order of the elements used when you registered the mesh. This order is always used automatically.</p>"},{"location":"structures/surface_mesh/indexing_convention/#edges","title":"Edges","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following C++ code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\nsize_t vertex_B = face[ (i+1) % faceDegree ];\n\n// emit edge (vertex_A, vertex_B), if neither it nor the \n// equivalent edge (vertex_B, vertex_A) has been emitted already\n}\n}\n</code></pre> The default ordering of edges is the order in which they would be emitted by this loop.</p> <p>For edge-valued data, a permutation must be set. This is a sanity check to catch errors; for edges, it is highly unlikely that users happen to be storing their data in the same order.</p> <code>SurfaceMesh.set_edge_permutation(perm, expected_size=None)</code> <p>Set a non-standard ordering for edge-valued data on a mesh.</p> <p>The argument <code>perm</code> should be an array of integers.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>perm</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","title":"Halfedges","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face.  More formally, the ordering is equivalent to the following C++ code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\nsize_t vertex_B = face[ (i+1) % faceDegree ];\n\n// emit halfedge (vertex_A, vertex_B)\n}\n}\n</code></pre> The default ordering of halfedges is the order in which they would be emitted by this loop.</p> <p>Arrays of halfedge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below.</p> <code>SurfaceMesh.set_halfedge_permutation(perm, expected_size=None)</code> <p>Set a non-standard ordering for halfedge-valued data on a mesh.</p> <p>The argument <code>perm</code> should be an array of integers.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>perm</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#corners","title":"Corners","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face.  More formally, the ordering is equivalent to the following C++ code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\n\n// emit corner in this face incident on vertex_A\n}\n}\n</code></pre> The default ordering of corners is the order in which they would be emitted by this loop.</p> <p>Arrays of corner-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below.</p> <code>SurfaceMesh.set_corner_permutation(perm, expected_size=None)</code> <p>Set a non-standard ordering for corner-valued data on a mesh.</p> <p>The argument <code>perm</code> should be an array of integers.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>perm</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","title":"All at once","text":"<p>As a convenience, you can alternately use a single function which passes all permutations needed at the same time. This might ease writing a single helper function which defines any necessary permutations for the mesh convention in your codebase.</p> <code>SurfaceMesh.set_all_permutations(edge_perm=None, edge_perm_size=None, corner_perm=None, corner_perm_size=None, halfedge_perm=None, halfedge_perm_size=None)</code> <p>Any non-<code>None</code> keyword arguments will simply be forwarded to the appropriate <code>set_XXX_permutation()</code> variant as above.</p>"},{"location":"structures/surface_mesh/misc_quantities/","title":"Misc quantities","text":""},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","title":"Surface Graph Quantity","text":"<p>The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity.</p> <p>Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes.</p> <p>Example: drawing mesh\u2019s dual with geometry-central.</p> <p></p> <pre><code>#include \"polyscope/surface_mesh.h\"\n\n// geometry-central things\ngeom-&gt;requireFaceIndices();\n\nstd::vector&lt;Vector3&gt; positions;\nstd::vector&lt;std::array&lt;size_t, 2&gt;&gt; edgeInds;\n\n// Build the node positions\nfor (Face f : mesh-&gt;faces()) {\n\n// Compute center for face\nVector3 c = Vector3::zero();\nfor (Vertex v : f.adjacentVertices()) {\nc += geom-&gt;inputVertexPositions[v];\n}\nc /= f.degree();\n\npositions.push_back(c);\n}\n\n// Build the edge indices\nfor (Edge e : mesh-&gt;edges()) {\n\n// Connect the nodes from the two faces adjacent to each edge\nsize_t fa = geom-&gt;faceIndices[e.halfedge().face()];\nsize_t fb = geom-&gt;faceIndices[e.halfedge().twin().face()];\n\nedgeInds.push_back({fa, fb});\n}\n\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;\naddSurfaceGraphQuantity(\"dual graph\", positions, edgeInds);\n</code></pre> <code>SurfaceMesh::addSurfaceGraphQuantity(std::string name, const P&amp; nodes, const E&amp; edges)</code> <p>Add a new surface graph quantity to the structure.</p> <ul> <li><code>nodes</code> is the list of 3D positions for the graph nodes. The type should be adaptable to a list of <code>float</code>-valued 3-vectors.</li> <li><code>edges</code> is the list of edges for the graph, where each entry is two 0-based indices in to the <code>nodes</code> array. The type should be adaptable to a list of <code>size_t</code>-valued 2-vectors (aka pairs of indices).</li> </ul> <p>The resulting class has <code>color</code> and <code>radius</code> fields which can be set to adjust the appearance of the resulting graph.</p>"},{"location":"structures/surface_mesh/misc_quantities/#options","title":"Options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes radius the radius the graph is drawn with <code>double getRadius()</code> <code>setRadius(double val, bool isRelative=true)</code> yes color the color to draw the graph with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/parameterization_quantities/","title":"Parameterization Quantities","text":"<p>A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# parameterization per vertex\nparam_vert = np.random.rand(N_vert,2)\nps_mesh.add_parameterization_quantity(\"rand param\", param_vert, enabled=True)\n\n# parameterization per corner\nparam_corner = np.random.rand(ps_mesh.n_corners(),2)\nps_mesh.add_parameterization_quantity(\"rand param corner\", param_corner, defined_on='corners')\n\n# use options to customize visualization\nps_mesh.add_parameterization_quantity(\"rand param corner2\", param_corner, defined_on='corners',\n                                       coords_type='world', viz_style='local_rad')\n\n\n# with custom checker/grid color\ncA = (0.1, 0.2, 0.3)\ncB = (0.4, 0.5, 0.6)\nps_mesh.add_parameterization_quantity(\"rand param corner3\", param_corner, defined_on='corners',\n                                       coords_type='unit', viz_style='grid', grid_colors=(cA, cB))\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p> <code>SurfaceMesh.add_parameterization_quantity(name, values, defined_on='vertices', coords_type='unit', enabled=None, viz_style=None, grid_colors=None, checker_colors=None, checker_size=None, cmap=None)</code> <p>Add a parameterization quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx2</code> numpy array, coordinates at vertices/corners</li> <li><code>defined_on</code> one of <code>'vertices','corners'</code>, is this a coordinate per vertex or per corner?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>viz_style</code> option determines how parameterizations are visualized:</p> <ul> <li><code>checker</code>: a two-color checker pattern</li> <li><code>grid</code>: a two-color grid with thin lines</li> <li><code>local_check</code>: a checkerboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>local_rad</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul>"},{"location":"structures/surface_mesh/parameterization_quantities/#types","title":"Types","text":"<p>The <code>coords_type</code> options determines how parameter coordinates are interpreted for scaling:</p> <ul> <li><code>unit</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>world</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul>"},{"location":"structures/surface_mesh/parameterization_quantities/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>When adding a parameterization quantity, the following keyword options can be set. These are available for all kinds of parameterization quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>coords_type</code> string, one of <code>'unit'</code>, <code>'world'</code>  (see above)</li> <li><code>viz_style</code> string, one of <code>'checker'</code>, <code>'grid'</code>, <code>'local_check'</code>, <code>'local_rad'</code> (see above)</li> <li><code>grid_colors</code> 2-tuple of rgb colors, used to color the grid visualization</li> <li><code>checker_colors</code> 2-tuple of rgb colors, used to color the checkerboard visualization</li> <li><code>checker_size</code> float, the size of checkers/grid/stripes</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the elements of a surface mesh.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# visualize some random data per-vertex\nvals_vert = np.random.rand(N_vert)\nps_mesh.add_scalar_quantity(\"rand vals\", vals_vert, enabled=True)\n\n# visualize some random data per-face\nvals_face = np.random.rand(N_face)\nps_mesh.add_scalar_quantity(\"rand vals2\", vals_face, defined_on='faces')\n\n# visualize some random data per-edge (halfedges are also supported)\nvals_edge = np.random.rand(ps_mesh.n_edges())\nps_mesh.add_scalar_quantity(\"rand vals3\", vals_edge, defined_on='edges')\n\n# as always, we can customize the initial appearance\nps_mesh.add_scalar_quantity(\"rand vals3 opt\", vals_edge, defined_on='edges', \n                            enabled=True, vminmax=(-3., 3.), cmap='reds')\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p>"},{"location":"structures/surface_mesh/scalar_quantities/#add-scalars-to-elements","title":"Add Scalars to Elements","text":"<code>SurfaceMesh.add_scalar_quantity(name, values, defined_on='vertices', enabled=None, datatype=\"standard\", vminmax=None, cmap=None, param_name=None, image_origin=\"upper_left\")</code> <p>Add a scalar quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at vertices/faces/etc</li> <li><code>defined_on</code> one of <code>'vertices','faces','edges','halfedges','texture'</code>, is this data a value per vertex or a value per face, etc?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p> <p>The <code>param_name</code> and <code>image_origin</code> arguments are used only if <code>defined_on='texture'</code>. See below for details.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#scalar-texture-maps","title":"Scalar Texture Maps","text":"<p>Texture images define data by storing it an image grid, and using coordinates defined on the face-corners or vertices of a mesh to sample values from the image for each point on the surface.</p> <p>To visualize scalar data defined in texture maps, first add a Parameterization Quantity (aka UV map) defining the coordinates. Then, add a buffer of image data to be sampled from.</p> <p>The resulting scalar texture supports color mapping and all of the other usual scalar data features.</p> <p>Example <pre><code>import numpy as np\nimport polyscope as ps\n\nps.init()\n\n# add a mesh\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3)\nfaces = np.random.randint(0, N_vert, size=(N_face,3))\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# add a parameterization (aka UV map)\nparam_vals = np.random.rand(ps_mesh.n_vertices(), 2)\nps_mesh.add_parameterization_quantity(\"test_param\", param_vals, \n                                      defined_on='vertices', enabled=True)\n\n# add the texture quantity\ndims = (200,300)\nvals = np.random.rand(*dims) # dummy placeholder image data\nps_mesh.add_scalar_quantity(\"test_vals\", vals, \n                             defined_on='texture', param_name=\"test_param\", \n                             vminmax=(-5., 5.), enabled=True)\n\nps.show()\n</code></pre></p> <p>Texture image data is added via <code>add_scalar_quantity()</code>, with <code>defined_on='texture'</code> and <code>param_name=...</code> specifying the name of the parameterization UV map with coordinates on <code>[0,1]</code> which will be used to sample from the image.</p> <p>The texture image data, dimension, and origin conventions are the same as those used to define images. See there for details.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/texture_map_quantities/","title":"Texture Map Quantities","text":"<p>Scalar and color texture maps can be used to define on surface meshes. See the relevant sections in the scalar and color quantity sections.</p> <ul> <li>Scalar texture maps</li> <li>Color texture maps</li> </ul>"},{"location":"structures/surface_mesh/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the elements of a surface mesh.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a surface mesh\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# visualize some random vectors per vertex\nvecs_vert = np.random.rand(N_vert, 3)\nps_mesh.add_vector_quantity(\"rand vecs\", vecs_vert, enabled=True)\n\n# set radius/length/color of the vectors\nps_mesh.add_vector_quantity(\"rand vecs opt\", vecs_vert, radius=0.001, \n                            length=0.005, color=(0.2, 0.5, 0.5))\n\n# ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space\nps_mesh.add_vector_quantity(\"vecs ambient\", vecs_vert, vectortype='ambient')\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p> <code>SurfaceMesh.add_vector_quantity(name, values, defined_on='vertices', enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at vertices/faces (or <code>Nx2</code> for 2D data)</li> <li><code>defined_on</code> string, one of <code>vertices</code> or <code>faces</code>, is this data a vector per-vertex or a vector per-face?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","title":"Tangent vectors","text":"<p>Tangent vectors lie flat against the surface of a mesh. They are defined as 2D vector in a local 2D coordinate system at each vertex or face. We need to specify the vector itself as well as the basis vectors for the local coordinate systems.</p> <code>SurfaceMesh.add_tangent_vector_quantity(name, values, basisX, basisY, defined_on='vertices', n_sym=1, enabled=None, vectortype=\"standard\", length=None, radius=None, color=None, ribbon=None)</code> <p>Add a vector quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx2</code> numpy array, of tangent vectors at vertices/faces</li> <li><code>basisX</code> an <code>Nx3</code> numpy array, giving the X component of the local basis at each vertex/face</li> <li><code>basisY</code> an <code>Nx3</code> numpy array, giving the Y component of the local basis at each vertex/face</li> <li><code>defined_on</code> string, one of <code>vertices</code> or <code>faces</code>, is this data a vector per-vertex or a vector per-face?</li> <li><code>n_sym</code> is a symmetry order for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non-<code>1</code> value, n distinct vectors will be displayed at each element, by rotating the input vector 2*PI/nSym radians.</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","title":"One forms","text":"<p>One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices.</p> <code>SurfaceMesh.add_one_form_vector_quantity(name, values, orientations, enabled=None, length=None, radius=None, color=None, ribbon=None)</code> <p>Add a one-form vector quantity to the mesh.  Remember, before passing edge-valued data, set the indexing convention Polyscope.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>n_edges</code> numpy float array, integrated 1-form values at edges</li> <li><code>orientations</code> a length <code>n_edges</code> numpy boolean array. 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. These booleans should be <code>true</code> if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise.</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_grid/basics/","title":"Volume Grids","text":"<p>Volume grid structures visualize data defined on an axis-aligned regularly-spaced 3D grid. </p> <p>As usual, first you register a volume grid, then add one or more quantities defined on that grid. Registering the grid itself just means specifying the locations of its extremal corners and the grid resolution. Then you can add data, such as scalar data as linearly-interpolated values per-node or as piecewise-constant values per-cell. Slice planes can also be used inspect the interior of the grid, isosurfaces can be extracted from scalar functions at nodes, and more. </p>    Your browser does not support the video tag.  <p>Example: registering a volume grid and adding a scalar quantity <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# define the resolution and bounds of the grid\ndims = (20, 20, 20)\nbound_low = (-3., -3., -3.)\nbound_high = (3., 3., 3.)\n\n# register the grid\nps_grid = ps.register_volume_grid(\"sample grid\", dims, bound_low, bound_high)\n\n# your dimX*dimY*dimZ buffer of data\nscalar_vals = np.zeros(dims[0], dims[1], dims[2]) \n\n# add a scalar function on the grid\nps_grid.add_scalar_quantity(\"node scalar1\", scalar_vals, \n                            defined_on='nodes', vminmax=(-5., 5.), enabled=True)\n\nps.show()\n</code></pre></p>"},{"location":"structures/volume_grid/basics/#registering-a-volume-grid","title":"Registering a volume grid","text":"<p>Specifying node vs. cells</p> <p>Volume grid dimensions and locations are always defined in terms of nodes (aka cell corners). The dimension is the number of nodes along each axis, and the location is defined by the extremal nodes.</p> <p>For dimensions, if you are instead thinking in terms of the number of cells (little cubical regions), add +1 to the number of cells along each dimension to get the equivalent number of nodes when registering the grid.</p> <p>For locations, the min/max bounds you specify when registering the grid are the locations up the minimum and maximum node (aka cell corner). If you are instead thinking in terms of cell center locations, shift them half-cell-width offset when registering the grid.</p> <code>register_volume_grid(name, gridNodeDim, boundMin, boundMax, enabled=None, color=None, edge_color=None, edge_width=None, cube_size_factor=None, material=None, transparency=None)</code> <p>Add a new volume grid structure to Polyscope.</p> <ul> <li><code>name</code> the name of the structure</li> <li><code>gridNodeDim</code> an integer 3-tuple giving the number of nodes in the grid along each dimension</li> <li><code>boundMin</code> a float 3-tuple giving the xyz coordinates for the minimal node corner of the grid</li> <li><code>boundMax</code> a float 3-tuple giving the xyz coordinates for the maximal node corner of the grid</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>color</code> float 3-tuple, color for the volume as rgb in [0,1]</li> <li><code>edge_color</code> float 3-tuple, color for grid edges as rgb in [0,1] (be sure to set <code>edge_width</code> too)</li> <li><code>edge_width</code> float, width of edges on the grid; default sets <code>0</code> to disable edges, <code>1</code> is a reasonable value to enable</li> <li><code>cube_size_factor</code> float, shrink factor from 0-1 to draw gaps between cells, 0 is no shrink (default)</li> <li><code>material</code> string, name of material to use for the grid</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_grid/basics/#slice-planes","title":"Slice planes","text":"<p>Slice planes are particularly useful for inspecting the internal structure of a volume grid, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.</p>"},{"location":"structures/volume_grid/basics/#picking","title":"Picking","text":"<p>\u201cPicking\u201d refers to selecting and inspecting elements by clicking on the object in the scene. Picking volume grid elements works a little differently from other structures. For most structures, each click selects an element of the structure. However for volume grids, clicking on the structure once initiates picking, then the UI continuously displays data for the location under your mouse cursor. You can always deselect the volume grid elements by clicking somewhere off the grid.</p> <p>By default, if you have only registered data defined on nodes, then only nodes can be picked (and vice-versa for cells). You can override this behavior by calling <code>volume_grid.mark_nodes_as_used()</code>, to act as if a node quantity had been added, and likewise for <code>volume_grid.mark_cells_as_used()</code>.</p>"},{"location":"structures/volume_grid/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? color the color of the volume <code>get_color()</code> <code>set_color(val)</code> yes edge color the color of the grid edges <code>get_edge_color()</code> <code>set_edge_color(val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>double get_edge_width()</code> <code>set_edge_width(val)</code> yes cube size factor shrink factor from 0-1 to draw gaps between cells, 0 is no shrink (default) <code>get_cube_size_factor()</code> <code>set_cube_size_factor(val)</code> yes material what material to use <code>get_material()</code> <code>set_material(name)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/volume_grid/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar-valued data at the nodes or cells of a volume grid.</p> <p></p> <p>Example: registering a volume grid and adding a scalar quantity <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# define the resolution and bounds of the grid\ndims = (20, 20, 20)\nbound_low = (-3., -3., -3.)\nbound_high = (3., 3., 3.)\n\n# register the grid\nps_grid = ps.register_volume_grid(\"sample grid\", dims, bound_low, bound_high)\n\n# your dimX*dimY*dimZ buffer of data\nscalar_vals = np.zeros(dims[0], dims[1], dims[2]) \n\n# add a scalar function on the grid\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes')\n\n# set some scalar options \nps_grid.add_scalar_quantity(\"node scalar2\", scalar_vals, defined_on='nodes', \n                            vminmax=(-5., 5.), cmap='blues', enabled=True)\n\nps.show()\n</code></pre></p>"},{"location":"structures/volume_grid/scalar_quantities/#add-scalars","title":"Add scalars","text":"<code>VolumeGrid.add_scalar_quantity(name, values, defined_on='nodes', datatype=\"standard\", **scalar_args)</code> <p>Add a scalar quantity defined at the nodes of the grid.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a numpy array of shape <code>(dimX, dimY, dimZ)</code> giving scalars at nodes/cells. </li> <li><code>defined_on</code> one of <code>'nodes', 'cells'</code>, is this data a value per node or a value per cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_grid/scalar_quantities/#add-implicit-scalars","title":"Add implicit scalars","text":"<p>Implicit helpers</p> <p>Implicit helpers offer an easier way to interface your data with Polyscope. You define a callback function which can be called at a batch of xyz coordinates to return a batch of values, and pass that function as input. Polyscope then automatically takes care of calling the function at the appropriate locations to sample the function onto the grid.</p> <p>See Implicit Helpers for more details about implicit helpers.</p> <code>VolumeGrid.add_scalar_quantity_from_callable(name, func, defined_on='nodes', datatype=\"standard\", **scalar_args)</code> <p>Add a scalar quantity defined at the nodes of the grid, sampling automatically via a callable function.</p> <ul> <li><code>func</code> is a function which performs a batch of evaluations of the implicit function. It should take a <code>(Q,3)</code> numpy array of world-space xyz locations at which to evaluate the function where <code>Q</code> is the number of queries, and return a <code>(Q,)</code> numpy array of results. </li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_grid/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_grid/scalar_quantities/#visualizing-isosurfaces","title":"Visualizing Isosurfaces","text":"<p>For a scalar values at nodes, we can additionally extract isosurfaces (aka levelsets) via the marching cubes algorithm, and visualize them as surface meshes.</p> <p></p> <p>Example: visualizing scalar isosurfaces <pre><code># continued after the grid as been set up as in the example above\n\n# draw the isosurfce, hiding the usual grid so it is visible\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes',\n                            enable_isosurface_viz=True, isosurface_level=0.5,\n                            isosurface_color=(0.2, 0.1, 0.8),\n                            enable_gridcube_viz=False)\nps.show()\n\n# draw the isosurface, using a slice plane to cut through it\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes',\n                            enable_isosurface_viz=True, isosurface_level=0.5,\n                            slice_planes_affect_isosurface=False)\nps.add_scene_slice_plane()\nps.show()\n\n\n# extract the isosurface as its own mesh structure\nscalarQ-&gt;registerIsosurfaceAsMesh(\"my isosurface mesh\");\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes',\n                            enable_isosurface_viz=True, isosurface_level=0.5,\n                            register_isosurface_as_mesh_with_name='isosurface mesh')\n</code></pre></p> <p>The following optional arguments to the node scalar quantity adder affect the behavior of isosurfaces. </p> <p>Note</p> <p>By default, the grid obscures the isosurface so it cannot be seen. You probably want to either:</p> <ul> <li>use a slice plane, along with the <code>slice_planes_affect_isosurface=False</code> option, or</li> <li>use <code>enable_gridcube_viz=False</code> to disable the default grid visualization</li> </ul> <ul> <li><code>enable_gridcube_viz</code> boolean, is the usual grid cube visualization drawn</li> <li><code>enable_isosurface_viz</code> boolean, should the isosurface be extracted and drawn</li> <li><code>isosurface_level</code> float, which isolevel should be extracted</li> <li><code>isosurface_color</code> 3-tuple of floats, color of the isosurface mesh</li> <li><code>slice_planes_affect_isosurface</code> boolean, do slice planes affect the isosurface</li> <li><code>register_isosurface_as_mesh_with_name</code> string, if given, register the isosurface as a new mesh with this name. Passing <code>\"\"</code> generates a default name.</li> </ul>"},{"location":"structures/volume_mesh/basics/","title":"Volume Meshes","text":"<p>Volumetric meshes, such as tetrahedral (tet) and hexahedral (hex, cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values.</p>    Your browser does not support the video tag."},{"location":"structures/volume_mesh/basics/#registering-a-volume-mesh","title":"Registering a volume mesh","text":"<p>Example: registering a tetrahedral mesh</p> <pre><code>import polyscope as ps\nimport numpy as np\nimport igl\n\nverts, tets, _ = igl.read_mesh(\"my_mesh.mesh\")\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add a scalar function on vertices\ndata_vert = np.random.rand(n_vert)\nps_vol.add_scalar_quantity(\"my vertex val\", data_vert)\n\n# you can also access the structure by name\nps.get_volume_mesh(\"test volume mesh\").add_scalar_quantity(\"my vertex val\", data_vert)\n\n# Add a scalar function on cells (with some options set)\ndata_cell = np.random.rand(n_cell)\nps_vol.add_scalar_quantity(\"my cell val\", data_cell, defined_on='cells',\n                           vminmax=(-3., 3.), cmap='blues')\n\n# Show the GUI\nps.show() \n</code></pre> <p>Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different argument variants to register meshes with tets, hexes, or a mix of the two. </p> <p></p> <code>register_volume_mesh(name, vertices, tets=None, hexes=None, mixed_cells=None, enabled=None, color=None, interior_color=None, edge_color=None, edge_width=None, material=None)</code> <p>Add a new volume mesh structure to Polyscope.</p> <ul> <li><code>name</code> string, a name for the structure</li> <li><code>vertices</code> an <code>Nx3</code> numpy float array of vertex locations </li> </ul> <p>The elements are specified by a combination of the following arguments:</p> <ul> <li><code>tets</code> a <code>Tx4</code> numpy integer array of tetrahedra, as 0-based indices in to the vertices array</li> <li><code>hexes</code> a <code>Hx8</code> numpy integer array of hexahedra, as 0-based indices in to the vertices array</li> <li><code>mixed_cells</code> a <code>Mx8</code> numpy integer array which may contain a mix of tetrahedra and hexahedra. For any rows which are tets and thus have just 4 indices, the remaining indices should be set to any negative value.</li> </ul> <p>You may pass in <code>tets</code>, <code>hexes</code>, or both to specify the connectivty. Alternately, <code>mixed_cells</code> may be used. However, it is not supported to specify both <code>tets</code>/<code>hexes</code> and <code>mixed_cells</code>.  For the purposes of element ordering, when <code>tets</code> and <code>hexes</code> are both passed, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells.</p> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>color</code> float 3-tuple, default color values for the outside of the mesh as rgb in [0,1]</li> <li><code>interior_color</code> float 3-tuple, default color values for the inside of the mesh as rgb in [0,1]</li> <li><code>edge_color</code> float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set <code>edge_width</code> too)</li> <li><code>edge_width</code> float, width of edges in rendered mesh; default sets <code>0</code> to disable edges, <code>1</code> is a reasonable value to enable</li> <li><code>material</code> string, name of material to use for the mesh</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>No support for 2D</p> <p>Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data).</p>"},{"location":"structures/volume_mesh/basics/#updating-a-mesh","title":"Updating a mesh","text":"<p>The locations of the vertices in a mesh can be updated with the member function <code>update_vertex_positions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite).</p> <code>VolumeMesh.update_vertex_positions(newPos)</code> <p>Update the vertex positions in a volume mesh structure. <code>newPos</code> must be valid input to initially construct the vertex positions, with the same number of vertices.</p>"},{"location":"structures/volume_mesh/basics/#slice-planes","title":"Slice planes","text":"<p>Slice planes are particularly useful for inspecting the internal structure of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.</p> <p>Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.</p>"},{"location":"structures/volume_mesh/basics/#options","title":"Options","text":"<p>Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial <code>register_volume_mesh()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? color the color of the outside of the volume <code>get_color()</code> <code>set_color(val)</code> yes interior color the color of the inside of the volume <code>get_interior_color()</code> <code>set_interior_color(val)</code> yes edge color the color of the edges of the mesh <code>get_edge_color()</code> <code>set_edge_color(val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>get_edge_width()</code> <code>set_edge_width(val)</code> yes material what material to use <code>get_material()</code> <code>set_material(name)</code> yes <p>Example: set options which affect the appearance of the mesh <pre><code>import numpy as np\nimport polyscope as ps\n\n# a simple inline mesh\nverts = np.array([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n    [1, 0, 1],\n    [1, 1, 1],\n    [0, 1, 1],\n    [1, 1, 1.5]\n])\ncells = np.array([\n  [0, 1, 2, 3, 4, 5, 6, 7],\n  [7, 5, 6, 8, -1, -1, -1, -1],\n])\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, mixed_cells=cells)\n\nps_vol.set_enabled(False) # disable\nps_vol.set_enabled() # default is true\n\nps_vol.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\nps_vol.set_interior_color((0.4, 0.7, 0.9))\nps_vol.set_edge_color((0.8, 0.8, 0.8)) \nps_vol.set_edge_width(1.0)\nps_vol.set_material(\"wax\")\nps_vol.set_transparency(0.5)\n\n# alternately:\nps.register_volume_mesh(\"test volume mesh 2\", verts, mixed_cells=cells, enabled=False, \n                         color=(1., 0., 0.), interior_color=(0., 1., 0.),\n                         edge_color=((0.8, 0.8, 0.8)), edge_width=1.0, \n                         material='candy', transparency=0.5)\n\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing a color value at cells (here, random values) <pre><code># ... initialization, create mesh ...\n\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add a color function on cells (with some options set)\ncolors = np.random.rand(n_cell, 3)\nps_vol.add_color_quantity(\"my color\", colors, defined_on='cells', enabled=True)\n\n# Show the GUI\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/color_quantities/#add-colors-to-elements","title":"Add colors to elements","text":"<code>VolumeMesh.add_color_quantity(name, values, defined_on='vertices', enabled=None)</code> <p>Add a scalar quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at vertices/cells</li> <li><code>defined_on</code> string, one of <code>\"vertices\"</code> or <code>\"cells\"</code>, is this data a color per vertex or a color per cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_mesh/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_mesh/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing a scalar on vertices (here, random values) <pre><code># ... initialization, create mesh ...\n\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add a scalar function on vertices\ndata_vert = np.random.rand(n_vert)\nps_vol.add_scalar_quantity(\"my vertex val\", data_vert)\n\n# Add a scalar function on cells (with some options set)\ndata_cell = np.random.rand(n_cell)\nps_vol.add_scalar_quantity(\"my cell val\", data_cell, defined_on='cells',\n                           vminmax=(-3., 3.), cmap='blues', enabled=True)\n\n// Show the GUI\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/scalar_quantities/#add-scalars-to-elements","title":"Add scalars to elements","text":"<code>VolumeMesh.add_scalar_quantity(self, name, values, defined_on='vertices', enabled=None, datatype=\"standard\", vminmax=None, cmap=None)</code> <p>Add a scalar quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at vertices/cells</li> <li><code>defined_on</code> one of <code>'vertices','cells'</code>, is this data a value per vertex or a value per cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_mesh/scalar_quantities/#inspecting-with-slice-planes","title":"Inspecting with slice planes","text":"<p>Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.</p>"},{"location":"structures/volume_mesh/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, or <code>\"magnitude\"</code>, affects default colormap and map range</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_mesh/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing vectors on vertices (here random vectors) <pre><code># ... initialization, create mesh ...\n\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add vectors on vertices (with some options set)\nvecs = np.random.rand(n_vert, 3)\nps_vol.add_vector(\"my color\", vecs, enabled=True, vectortype='ambient')\n\n# Show the GUI\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/vector_quantities/#add-vectors-to-elements","title":"Add vectors to elements","text":"<code>VolumeMesh.add_vector_quantity(name, values, defined_on='vertices', enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at vertices/cells</li> <li><code>defined_on</code> string, one of <code>vertices</code> or <code>cells</code>, is this data a vector per-vertex or a vector per-cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_mesh/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"}]}