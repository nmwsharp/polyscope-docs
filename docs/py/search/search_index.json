{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Polyscope is a C++/Python viewer and user interface for 3D data such as meshes and point clouds. It allows you to register your data and quickly generate informative and beautiful visualizations, either programmatically or via a dynamic GUI. Polyscope is designed to be lightweight\u2014it does not \u201ctake ownership\u201d over your entire program, and it is easy to integrate with existing codebases and popular libraries. The lofty objective of Polyscope is to offer a useful visual interface to your data via a single line of code.</p> <p>Polyscope uses a paradigm of structures and quantities. A structure is a geometric object in the scene, such as a surface mesh or point cloud. A quantity is data associated with a structure, such as a scalar function or a vector field.</p> <p>When any of these structures and quantities are registered, Polyscope displays them in an interactive 3D scene, handling boilerplate concerns such as toggling visibility, color-mapping data and adjusting maps, \u201cpicking\u201d to click in the scene and query numerical quantities, etc.</p> <p>Note: There are two variants of this documentation, for C++ and Python. Use the buttons on the top bar to change language.</p> <p>A simple workflow for visualizing data in Polyscope looks like:</p> PythonC++ <pre><code>import polyscope as ps\n\n# Initialize polyscope\nps.init()\n\n### Register a point cloud\n# `my_points` is a Nx3 numpy array\nps.register_point_cloud(\"my points\", my_points)\n\n### Register a mesh\n# `verts` is a Nx3 numpy array of vertex positions\n# `faces` is a Fx3 array of indices, or a nested list\nps.register_surface_mesh(\"my mesh\", verts, faces, smooth_shade=True)\n\n# Add a scalar function and a vector function defined on the mesh\n# vertex_scalar is a length V numpy array of values\n# face_vectors is an Fx3 array of vectors per face\nps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"my_scalar\", \n        vertex_scalar, defined_on='vertices', cmap='blues')\nps.get_surface_mesh(\"my mesh\").add_vector_quantity(\"my_vector\", \n        face_vectors, defined_on='faces', color=(0.2, 0.5, 0.5))\n\n# View the point cloud and mesh we just registered in the 3D UI\nps.show()\n</code></pre> <pre><code>#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\n// Initialize polyscope\npolyscope::init();\n\n// Register a point cloud\n// `points` is a Nx3 array-like container of points\npolyscope::registerPointCloud(\"my points\", points)\n\n// Register a surface mesh structure\n// `meshVerts` is a Vx3 array-like container of vertex positions\n// `meshFaces` is a Fx3 array-like container of face indices  \npolyscope::registerSurfaceMesh(\"my mesh\", meshVerts, meshFaces);\n\n// Add a scalar and a vector function defined on the mesh\n// `scalarQuantity` is a length V array-like container of values\n// `vectorQuantity` is an Fx3 array-like container of vectors per face\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addVertexScalarQuantity(\"my_scalar\", scalarQuantity);\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;addFaceVectorQuantity(\"my_vector\", vectorQuantity);\n\n// View the point cloud and mesh we just registered in the 3D UI\npolyscope::show();\n</code></pre> <p>Polyscope is designed to make your life easier. It is simple to build, and fewer than 10 lines of code should be sufficient to start visualizing.</p> <p>Author: Nicholas Sharp</p> <p>If Polyscope contributes to an academic publication, cite it as: <pre><code>@misc{polyscope,\ntitle = {Polyscope},\nauthor = {Nicholas Sharp and others},\nnote = {www.polyscope.run},\nyear = {2019}\n}\n</code></pre></p> <p>Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.</p>"},{"location":"#_1","title":"Home","text":""},{"location":"FAQ/","title":"FAQ, Tips, and Tricks","text":"<ul> <li> <p>Interface and Camera Controls</p> <ul> <li>Saving and restoring camera poses</li> <li>Centering the view on an area of interest</li> <li>How do I take a screenshot / save an image?</li> <li>Positioning objects in the scene and reading back results</li> <li>Managing large numbers of structures and quantities</li> </ul> </li> <li> <p>Interactions</p> <ul> <li>How do I show animated data?</li> <li>How do I create custom UIs with buttons, sliders, text boxes, etc?</li> <li>How do I set up mouse click interactions and callbacks</li> </ul> </li> <li> <p>Appearance</p> <ul> <li>Visualizing colors as exact RGB values, without any shading or tonemapping</li> <li>Rendering figures for papers and presentations</li> </ul> </li> <li> <p>System</p> <ul> <li>How do I run Polyscope remotely / on a headless server / in a notebook?</li> </ul> </li> </ul>"},{"location":"FAQ/#saving-and-restoring-camera-poses","title":"Saving and restoring camera poses","text":"<p>Use <code>look_at()</code> and other functions to manually specify the viewing camera pose. </p> <p>Or, you can interactively position the camera in the scene, copy it to your clipboard as a json string with <code>ctrl-c</code>, then restore it from the clipboard with <code>ctrl-v</code>. These strings can also be saved and restored programmatically.</p>"},{"location":"FAQ/#centering-the-view-on-an-area-of-interest","title":"Centering the view on an area of interest","text":"<p>See camera controls. You can use ctrl+shift+click (cmd+shift+click on macOS) to orbit the view about a point of interest, as well as zooming in relative to that point.</p>"},{"location":"FAQ/#how-do-i-take-a-screenshot-save-an-image","title":"How do I take a screenshot / save an image?","text":"<p>See Screenshots. Call <code>screenshot()</code>, or click the <code>[screenshot]</code> button in the upper-left corner of the UI.</p>"},{"location":"FAQ/#positioning-objects-in-the-scene-and-reading-back-results","title":"Positioning objects in the scene and reading back results","text":"<p>See Transforms for various options and to set and get per-structure transformations. In the GUI, you can use the <code>[Options] --&gt; [Transform]</code> menu to enable a widget to interactively transform each object within the scene.</p>"},{"location":"FAQ/#managing-large-numbers-of-structures-and-quantities","title":"Managing large numbers of structures and quantities","text":"<p>Polyscope generally scales just fine with 100s or even 1000s of distinctly named structures in the scene. However, with this many structures, it may become difficult to select what you want in the UI. Polyscope has a few features which can help:</p> <p>Every structure has controls in its options UI menu under <code>Options --&gt; Structure Selection</code> and <code>Options --&gt; Quantity Selection</code> which can be used to enable/disable all structures and quantities, or isolate to viewing a single structure.</p> <p>Use Groups to group your structures in to categories which can be enabled/disabled all together. Notice the <code>hide descendants</code> and <code>show details</code> options on groups, which can totally hide structures from the UI while still offering some control via the group.</p> <p>You can always use the Custom UIs to create your own interface buttons and selectors which programmatically enable or disable registered objects or adjust their settings.</p>"},{"location":"FAQ/#how-do-i-show-animated-data","title":"How do I show animated data","text":"<p>There is no explicit built-in functionality for animated or time-series data, but it is easy and common to do it yourself with a per-frame callback function.</p>"},{"location":"FAQ/#how-do-i-create-custom-uis-with-buttons-sliders-text-boxes-etc","title":"How do I create custom UIs with buttons, sliders, text boxes, etc","text":"<p>Polyscope integrates with the excellent Dear ImGui library for UI elements, and comes with its own bindings to use ImGui from Python. See the interactions page for how to use ImGui functions within polyscope, and see the ImGui docs for everything ImGui can do.</p>"},{"location":"FAQ/#how-do-i-set-up-mouse-click-interactions-and-callbacks","title":"How do I set up mouse click interactions and callbacks","text":"<p>See Mouse Interactions. Polyscope follows an immediate-mode philosophy for interactions: rather than registering many callbacks for various IO events, you can test for mouse and keyboard state in your main loop, or in the per-frame callback (which is the only callback), to implement any behavior your would like. ImGui offers many functions for testing mouse/keyboard state, and there are also a few polyscope-specific functions to get information about scene at the location you clicked, such as constructing rays and querying depth.</p>"},{"location":"FAQ/#rendering-figures-for-papers-and-presentations","title":"Rendering figures for papers and presentations","text":"<p>Several settings can be customized to give a more polished appearance. Consider:</p> <ul> <li>Adjusting the ground plane to shadow-only for ground shadows </li> <li>Increasing antialiasing rate</li> <li>Saving screenshots with transparency for compositing</li> </ul>"},{"location":"FAQ/#visualizing-colors-as-exact-rgb-values-without-any-shading-or-tonemapping","title":"Visualizing colors as exact RGB values, without any shading or tonemapping","text":"<p>Normally, colors are shaded and tone-mapped for rendering, which means the colors and colormapped-values you specify are not exactly the colors Polyscope renders to the screen. Use the flat material to circumvent these effects, and ensure that colors are flat-shaded to the screen with exactly the RGB values specified.</p>"},{"location":"FAQ/#how-do-i-run-polyscope-remotely-in-a-browser-via-a-notebook-or-on-headless-server","title":"How do I run Polyscope remotely in a browser, via a notebook, or on headless server?","text":"<p>See headless rendering. </p> <p>In short, Polyscope does support headless rendering: it can be used on remote serves with no display attached to render images and videos to files or buffers, by initializing with a special EGL backend. However, Polyscope does not currently support any kind of client-server mode, or execution in the browser from remote machines, etc. It must be executing locally on the machine which you are using it from.  </p> <p>Polyscope does not currently support creating interactive visualizations inline in IPython/Jupyter notebooks when the kernel is executing on a remote server. If the kernel is executing on your local machine, you can use Polyscope, but the windows will be created directly on your desktop system outside of the notebook.</p>"},{"location":"about/bindings/","title":"Bindings","text":""},{"location":"about/bindings/#python-bindings","title":"Python bindings","text":"<p>Warning</p> <p>Python bindings are in the works! Check back soon.</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Polyscope is an open-source project, and you are encouraged to contribute! The core library is lives in this repository, with documentation here and Python bindings here.</p> <p>All contributions will be released under Polyscope\u2019s MIT license.</p> <p>How to make a great pull request:</p> <p> Implement a feature or fix a bug</p> <p> Write a new unit test and run tests</p> <p> Submit a PR and ensure automated tests pass</p> <p> Update the documentation </p> <p> Create any new Python bindings</p> <p>Of course, contributions that only do some of the above are still welcome and appreciated! But doing all of these steps means your pull request is most likely to be merged right away.</p> <p>The sections below go in to more detail on each of these steps.</p>"},{"location":"about/contributing/#c-implementation","title":"C++ implementation","text":"<p>C++ vs. Python contributions</p> <p>Polyscope is implemented as a C++ library, with a thin binding layer to Python.</p> <p>All functionality is implemented on the C++ side\u2014pull requests which implement new features solely on the Python side or using external Python dependencies generally will not be accepted. Please file an issue asking first if you are unsure! Of course, bugfixes and additions to the Python binding layer itself are an exception.</p> <p>Conversely, any new C++ features are strongly encouraged to add corresponding Python bindings! See below.</p> <p>A few general pointers:</p> <ul> <li> <p>The UI (menus, dialogs, buttons, etc) is managed using Dear ImGUI, which is very well-documented and has many resources available online.</p> </li> <li> <p>Core rendering logic and shaders are implemented in the <code>/render</code> subdirectory, particularly <code>engine.h</code>. The engine is written to abstract over rendering backends, but at the moment only openGL is supported. There is also a \u201cmock\u201d backend for testing; new rendering features should be mirrored in both <code>gl_engine.cpp</code> and <code>mock_gl_engine.cpp</code>.</p> </li> <li> <p>Polyscope shaders use a custom in-house shader builder, which performs string manipulation with a simple substitution language to build shaders at runtime which support optional features like slice planes, transparency, different quantity visualization policies, etc. The shaders themselves also explicitly track some metadata like what attributes and uniforms they require. Examples of base shaders can be found e.g. here, and substitution rules here. For any shader or rule to be available in Polyscope, it must be registered in <code>GLEngine::populateDefaultShadersAndRules()</code>, and also in the corresponding function of the mock engine for testing.</p> </li> <li> <p>If adding a new structure or quantity, be sure to make use of the data adaptors for all user inputs. See here for an example. Generally, this means functions which take user data should be templated, and the input then passed through <code>standardizeArray&lt;&gt;()</code> or <code>standardizeVectorArray&lt;&gt;()</code>, etc.</p> </li> <li> <p>If adding new options or parameters to a structure/quantity. Be sure to follow proper encapsulation principles (create getters &amp; setters), and use a persistent values. Check out <code>PointCloud::pointColor</code> for a good basic example.  Also, all length-valued quantities should use scaled values (as in <code>PointCloud::pointRadius</code>).</p> </li> </ul>"},{"location":"about/contributing/#unit-testing","title":"Unit testing","text":"<p>Whenever possible, add a unit test that somehow exercises any new functionality or verifies that the bug has been fixed.  Polyscope uses the googletest testing framework. See documentation there for test macros, executable options, etc.</p> <p>In a perfect world, we would actually test that the rendered output from Polyscope is pixel-perfect. However, this is hard for a lot of reasons, so instead most of our tests are just \u201csmoke tests\u201d that call functions with some dummy data and ensure no errors are thrown.</p> <p>In fact, these tests are often run on headless servers, where we cannot even initialize an openGL environment. For this reason, in addition to the usual <code>openGL</code> backend, we also have an <code>openGL_mock</code> backend (implemented here) for testing on headless servers. This backend cannot actually render anything, but still performs many rendering-related sanity checks.  If making changes to the rendering engine &amp; shaders, you may find that changes need to be mirrored in <code>mock_gl_engine.cpp</code>.</p> <p>To run unit tests locally on your own machine (here, via unix terminal commands), use</p> <pre><code>cd test\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake -j4 \n./bin/polyscope-test backend=openGL3_glfw\n</code></pre> <p>which should create a window onscreen and run tests for a few seconds.</p> <p>Additionally, run the tests again like</p> <pre><code>./bin/polyscope-test </code></pre> <p>which will use the <code>openGL_mock</code> backend (you will not see anything onscreen). This is how testing will be performed on the headless CI servers. If both sets of tests pass without errors, you are good to go.</p>"},{"location":"about/contributing/#prs-automated-tests","title":"PRs &amp; automated tests","text":"<p>Once your feature seems ready and unit tests are passing, submit a pull request to the main repository. This will trigger continuous integration (CI) tests via Github Actions to automatically compile the code on a collection of windows/mac/linux machines with various compilers, and verify that tests pass. If there are any issues, a failed \u201ccheck\u201d will show on the pull request page which you can click to learn more.</p> <p>If this is your first contribution to Polyscope, a maintainer will need to manually approve the CI run (this is a github restriction).</p> <p>You are welcome to reach out in the PR chat to sort out any problems. We may request changes! If a PR ever goes more than a few days without a response feel free to ping @nmwsharp.</p>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>Documentation is hosted in its own separate repository. Polyscope docs use the mkdocs documentation engine, with the mkdocs-material theme (this theme is quite large and adds significant functionality beyond base mkdocs). The documentation is written in a large collection of markdown files; it is not automatically scraped from the code, or code comments, etc, so we must manually keep it up to date.</p> <p>There are two duplicate copies of all the docs for C++ and Python, stored in parallel directories <code>/cpp</code> and <code>/py</code>. A few shared files and assets are stored in the <code>/shared</code> directory, or symlinked from the <code>/py</code> subdirectory to point to a file the <code>/cpp</code> directory. We try to keep these two parallel versions in sync as much as possible, only differing where necessary between C++ and Python.</p> <p>To preview the documentation while editing, first install the necessary packages with <code>pip install mkdocs mkdocs-material==6.2.8 mkdocs-macros-plugin pygments</code>. Then run <code>python3 -m mkdocs serve</code> (run this command from the <code>/cpp</code> directory to view C++ docs, and likewise for <code>/py</code>). A local address will be printed to your terminal, which you can navigate to in-browser to see the docs.</p> <p>Hopefully editing the docs markdown files should be self-evident, you can mainly copy existing content &amp; formatting. Any new files need to be added the manifests in <code>mkdocs.yml</code>.  Don\u2019t forget to add a blurb to the release notes! </p> <p>If you are not able to build the docs for any reason, it is fine to just edit the markdown files and submit a docs PR with that.</p> <p>To actually update the hosted documentation files online at polyscope.run, the documentation site needs to be recompiled and committed to the to the <code>/docs</code> subdirectory. The <code>build_commit_push.sh</code> script can handle this for you, rebuilding both C++ &amp; Python docs and committing the result to the <code>/docs</code> subdirectory:</p> <pre><code>sh build_commit_push.sh\n</code></pre> <p>If you include these built docs changes in your PR, the webpage will automatically update when it is merged. Otherwise the maintainers (usually @nmwsharp) will need to run this command and commit the update after accepting your PR.</p>"},{"location":"about/contributing/#python-bindings","title":"Python bindings","text":"<p>Python bindings for Polyscope are stored in their own separate repository. We use pybind11 to generate bindings. These bindings are kept as thin wrappers as much as possible, just doing a minimal translation between the C++ interface and typical Python calling conventions.</p> <p>The bindings are actually managed internally as two separate Python packages: <code>polyscope_bindings</code> (which contains the raw bindings generated by our pybind11 code), and the higher-level <code>polyscope</code> (which contains the actual, nice user-facing Python functions). The separation is because there is no way to write additional Python code in the pybind11-generated package, but we often want to do some translation and error checking on the Python side before invoking the bindings. As such, adding a binding generally means writing code in two places:</p> <ol> <li>Add a new pybind11 C++ binding, like those here</li> <li>Add a new Python wrapper function which calls the generated binding, like the ones here</li> </ol> <p>Note that a few stylistic conventions between Python and C++. In particular, we do not expose classes for quantities, but set options via optional keyword arguments when the quantity is added. The pybind11 C++ bindings take Eigen arrays as arguments, because pybind11 performs automatic translation between Eigen/numpy.</p> <p>Python binding unit tests are stored in <code>/test/polyscope_test.py</code>. As with C++, these are mainly just simple \u201csmoke tests\u201d which call the functions with dummy data and ensure no errors are thrown. All new bindings functions need a test! To build and test the bindings, first compile the bindings from the <code>polyscope-py</code> root directory like <pre><code>mkdir build\ncd build\ncmake ..\nmake -j8\n</code></pre> the run <code>python polyscope_test.py</code>. As you write code, these bindings must be recompiled to reflect any changes to the pybind11 C++. When testing, make sure there is not another copy of Polyscope for Python installed in your system, which might unintentionally be used instead of the development version! Also, the adjacent <code>demo_app.py</code> can be used for simple testing.</p> <p>Don\u2019t forget, the Python bindings have a parallel set of docs in the <code>/py</code> directory. Updates to Python should be reflected there.</p> <p>When all your tests are passing, create a pull request! As with C++, submitting a pull request to the Python bindings will trigger a cloud build and some automated checks.</p> <p>Actually deploying a new Python version to <code>pip</code> and <code>conda</code> package managers is a somewhat significant process, so we typically group together updates before cutting a new version.  Ping @nmwsharp to get a new version deployed.  Major and minor versions of the Python library are kept in-sync with the C++ library versions, whereas patch versions (<code>1.2.4</code> \u2013&gt; <code>1.2.5</code>) are used for new updates to the Python bindings only.</p>"},{"location":"about/dependencies/","title":"Dependencies","text":"<p>Polyscope stands on the shoulders of many outstanding open-source projects. These dependencies are all permissively licensed, and bundled with the project; we just list them here to give due credit!</p> Name Purpose Link GLFW Window and input management with openGL glfw.org Dear ImGui GUI interface (buttons, text boxes, etc) github.com/ocornut/imgui ImPlot Extension of ImGui for 2D plots (lines, scatter, etc) github.com/epezent/implot glad OpenGL loader (used on Windows/Linux) github.com/Dav1dde/glad glm Vector math and glsl utilities glm.g-truc.net stb Header-only libraries, esp. image loading github.com/nothings/stb json Read/write json text github.com/nlohmann/json MC.h adapted for marching cubes github.com/aparis69/MarchingCubeCpp mkdocs Doc generation mkdocs.org mkdocs-material Doc generation squidfunk.github.io/mkdocs-material/ googletest Unit testing github.com/google/googletest pybind11 (Python only) Python bindings github.com/pybind/pybind11 Eigen (Python only) numpy interop for bindings eigen.tuxfamily.org <p>Additionally Polyscope may optionally load EGL at runtime, functionality which must be enabled by a compile flag for headless rendering. EGL is not shipped with Polyscope, and it is not linked statically nor dynamically; it is loaded at runtime from the user\u2019s system only if the headless EGL backend is initialized, akin to a plugin.</p> <p>Polyscope includes a few public-domain / permissively licensed assets. Some of the built-in matcaps are from the Blender project, and others were rendered using Blender.  The built-in colormaps come from several sources as detailed on the colormap page, including Smith et. al., cmocean, and matplotlib.  The concrete texture on the ground is from cc0textures.com. Thank you, artists!</p>"},{"location":"about/license/","title":"License","text":"<p>The core Polyscope C++ library is released under an MIT license, and all of its dependencies are under similar permissive licenses (MIT, zlib, or public domain).</p> <p>These Python bindings are also released under an MIT license. The python bindings are generated using pybind11, which is under a BSD 3-clause license, and Eigen, which is licensed under MPL2; again, these are permissive licenses.</p> <p>Polyscope is created and maintained by academics: citations let us know our work is having impact! Please cite Polyscope or otherwise give a shout-out if and when it contributes to published works.</p> <pre><code>@misc{polyscope,\ntitle = {Polyscope},\nauthor = {Nicholas Sharp and others},\nnote = {www.polyscope.run},\nyear = {2019}\n}\n</code></pre>"},{"location":"about/release_notes/","title":"Release Notes","text":"<p>See github releases: github.com/nmwsharp/polyscope-py/releases</p>"},{"location":"basics/camera_controls/","title":"Managing Views & Cameras","text":"<p>These functions control the current viewing camera in for the Polyscope scene, as well as more-generally managing camera parameters across visualizations, such as for Camera View structures.</p> <pre><code>import polyscope as ps\nimport numpy as np\n\n# change the default up-direction or front-direction for the scene\nps.set_up_dir(\"z_up\")\nps.set_front_dir(\"neg_y_front\")\n\n# change the navigation style (default is Turntable)\nps.set_navigation_style(\"free\")\n\n# get the current camera view matrix\nview_mat = ps.get_camera_view_matrix()\n\n\n# set the current camera view matrix\nps.set_camera_view_matrix(view_mat)\n\n# set the current camera pose to look-at something in the scene\nps.look_at((0., 0., 5.), (1., 1., 1.))\n# (alternately, use numpy vectors)\nps.look_at(np.array((0., 0., 5.)), np.array((1., 1., 1.)))\n\n# manipulate the current camera with the CameraParameters object,\n# which standardizes all camera information\ncam_params = ps.get_view_camera_parameters()\nps.set_view_camera_parameters(cam_params)\n\n# you can even use the parameters to create a camera view structure,\n# which visualize views of the scene as a frame and can hold image\n# quantities\nps_cam = ps.register_camera_view(\"cam1\", cam_params) \n</code></pre>"},{"location":"basics/camera_controls/#window-controls","title":"Window Controls","text":"<p>Get and set the size of the window which appears on the user\u2019s display.</p> <code>set_window_size(width, height)</code> <p>Set the size of the window.</p> <p>Note that for some platforms, on high-DPI screens the pixel buffer resolution may be different from the logical size. This is the logical size.</p> <code>get_window_size()</code> <p>Get the current size of the window. Returns a <code>(width, height)</code> tuple.</p> <p>Note that for some platforms, on high-DPI screens the pixel buffer resolution may be different from the logical size. This is the logical size.</p> <code>get_buffer_size()</code> <p>Get the current pixel buffer resolution of the window. Returns a <code>(width, height)</code> tuple.</p> <p>Note that for some platforms, on high-DPI screens the pixel buffer resolution may be different from the logical size. This is the pixel buffer size.</p> <code>set_window_resizable(is_resizable)</code> <p>If <code>false</code>, the window will be locked to size and the OS will not allow it to be resized. (Default: <code>true</code>)</p> <p>There is also a corresponding <code>get_window_resizable()</code>.</p>"},{"location":"basics/camera_controls/#manipulating-the-current-view","title":"Manipulating the Current View","text":"<p>These settings affect the 3D camera view in polyscope. It is often convenient to set them just before calling <code>ps.init()</code>, but they may set be anywhere.</p> <p>View Getters: <pre><code># call like ps.get_camera_view_matrix() etc\npolyscope.get_view_camera_parameters() # contains all of this info\n\n# (these friendly helpers get the same info as ^^^)\npolyscope.get_camera_view_matrix()\npolyscope.get_vertical_fov_degrees()\npolyscope.get_aspect_ratio_width_over_height()\n</code></pre></p> <code>get_view_camera_parameters()</code> <p>Get the camera parameters (intrinsic and extrinsics) that describe the current viewport view. </p> <p>See the section below for additional methods to get values from the camera parameters.</p> <p>Example: <pre><code>curr_params = ps.get_view_camera_parameters()\n\n# get some data from the parameters\nview_mat = curr_params.get_view_mat()\nfov_vert_deg = curr_params.get_fov_vertical_deg()\naspect = curr_params.get_aspect()\npos = curr_params.get_position()\n</code></pre></p> <p>View Setters: <pre><code># call like ps.set_camera_view_matrix() etc\npolyscope.set_view_camera_parameters(params) # contains all of this info\n\n## (these friendly helpers set the same info as ^^^)\npolyscope.set_camera_view_matrix(mat)\npolyscope.look_at(camera_location, target, fly_to=False)\npolyscope.look_at_dir(camera_location, target, up_dir, fly_to=False)\npolyscope.set_vertical_fov_degrees(fov)\n# there is no aspect ratio setter: it is determined by the window size\n</code></pre></p> <code>set_view_camera_parameters(params)</code> <p>Set the camera parameters (intrinsic and extrinsics) that describe the current viewport view. </p> <p>See the section below for additional methods to construct these camera parameters.</p> <p>Example: <pre><code>intrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\nnew_params = ps.CameraParameters(intrinsics, extrinsics)\n\nps.set_view_camera_parameters(new_params)\n</code></pre></p>"},{"location":"basics/camera_controls/#look-at","title":"Look-At","text":"<p>The look-at functions are particularly easy to use to position the camera towards content of interest.</p> <code>look_at(camera_location, target, fly_to=False)</code> <p>Set the camera to be located at the 3D position <code>camera_location</code> and looking at the 3D position <code>target</code>, both in world coordinates. The up direction for the camera is set to be the scene\u2019s up direction. If <code>fly_to=True</code>, the camera will smoothly animate to the new configuration.</p> <p>The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p> <p>Example: <pre><code>polyscope.look_at((0., 0., 5.), (1., 1., 1.))\n</code></pre></p> <code>look_at_dir(camera_location, target, up_dir, fly_to=False)</code> <p>Set the camera to be located at the 3D position <code>camera_location</code> and looking at the 3D position <code>target</code>, oriented with the up direction <code>up_dir</code>, all in world coordinates. If <code>fly_to=True</code>, the camera will smoothly animate to the new configuration.</p> <p>Note that setting the up direction for the camera view with this function is separate from the scene\u2019s up direction with <code>set_up_dir()</code>, which affects things like ground plane placement, and manual view manipulation.</p> <p>The input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p> <p>Example: <pre><code>polyscope.look_at_dir((0., 0., 5.), (1., 1., 1.), (-1., -1., 0.))\n</code></pre></p>"},{"location":"basics/camera_controls/#home-view","title":"Home View","text":"<p>The home view is a reasonable default camera view, computed based on the up- and front- direction, as well as the scene extents which may be computed automatically from data you have registered.</p> <p>By default, the camera is located at the home view when the scene is first opened. You can also return it to that view at any time with <code>reset_camera_to_home_view()</code>.</p> <code>reset_camera_to_home_view()</code> <p>Reset the camera view to the home view (a reasonable default view scaled to the scene).</p> <p>Note: The \u201chome\u201d view is dependent on the data in the scene; it is computed from the bounding boxes of all registered structures to ensure that everything is nicely scaled and in view. As such, one should generally call this function after registering data.</p> <p>Example: <pre><code>ps.reset_camera_to_home_view()\n</code></pre></p>"},{"location":"basics/camera_controls/#navigation-style","title":"Navigation Style","text":"<p>The navigation style affects how the user\u2019s mouse interactions navigate the scene. The default is a Turntable rotating around the current canonical <code>Up</code> direction.</p> <p>Navigation Style Strings:</p> <ul> <li><code>'turntable'</code> The up direction (see below) is always fixed vertically, with rotation along the azumith and altitude directions.</li> <li><code>'free'</code> The camera is free to take any orientation, rotation is always about relative to the current camera.</li> <li><code>'planar'</code> The camera is locked in to a 2D view of the XY plane, with no rotation (see 2D data).</li> </ul> <code>set_navigation_style(s)</code> <p>The style of the camera navigation. Affects what happens when you drag to rotate around the 3D view with your mouse.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. </p> <p>Example: <pre><code>import polyscope as ps\nps.set_navigation_style(\"free\")\n</code></pre></p> <code>get_navigation_style()</code> <p>Get the current navigation style (see explanation in the setter above). Returns a string.</p>"},{"location":"basics/camera_controls/#canonical-up-and-front","title":"Canonical Up and Front","text":"<p>Unfortunately, no one can agree which cartesian direction is \u201cup\u201d in a 3D scene. Polyscope does not assume any particular up direction, it can be configured (default is <code>Y-up</code>).</p> <p>This effects many defaults of the scene, such as how the camera is oriented and where the ground plane is placed. </p> <code>set_up_dir(s)</code> <p>Set the default \u201cup\u201d direction for the scene. This setting affects default orientation of the view, the behavior of some navigation styles (esp. <code>Turntable</code>), and the orientation of the ground plane.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the setting strings are:</p> <ul> <li><code>'x_up'</code> The positive X-axis is up.</li> <li><code>'neg_x_up'</code> The negative X-axis is up.</li> <li><code>'y_up'</code> The positive Y-axis is up.</li> <li><code>'neg_y_up'</code> The negative Y-axis is up.</li> <li><code>'z_up'</code> The positive Z-axis is up.</li> <li><code>'neg_z_up'</code> The negative Z-axis is up.</li> </ul> <p>Default: <code>'y_up'</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_up_dir(\"z_up\")\n</code></pre></p> <code>get_up_dir()</code> <p>Get the current up direction (see explanation in the setter above). Returns a string.</p> <p>A default front direction can also be configured, which effects the placement of the home camera location.</p> <code>set_front_dir(s)</code> <p>Set the default \u201cfront\u201d direction for the scene. This setting affects default orientation of the view; the starting camera looks at the front of the data.</p> <p>This value is interpeted as if the scene were a cube, and you are specifying which face of the cube is the \u2018front\u2019. So <code>z_front</code> means the +Z face of the cube is the front face, and thus our camera initially points down the -Z axis to look at it.</p> <p>This value can be manually set under the <code>view</code> menu of the ui. Programmatically, the setting strings are:</p> <ul> <li><code>'x_front'</code> The positive X-axis is the front.</li> <li><code>'neg_x_front'</code> The negative X-axis is the front.</li> <li><code>'y_front'</code> The positive Y-axis is the front.</li> <li><code>'neg_y_front'</code> The negative Y-axis is the front.</li> <li><code>'z_front'</code> The positive Z-axis is the front.</li> <li><code>'neg_z_front'</code> The negative Z-axis is the front.</li> </ul> <p>Default: <code>z_front</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_front_dir(\"z_front\")\n</code></pre></p> <code>get_front_dir()</code> <p>Get the current front direction (see explanation in the setter above). Returns a string.</p>"},{"location":"basics/camera_controls/#perspective-and-orthographic-views","title":"Perspective and Orthographic Views","text":"<p>By default, Polyscope\u2019s view uses perspective projection. Perspective projections roughly correspond to how images are usually perceived by our eyes and cameras.</p> <p>Alternately orthographic projection is also supported. Orthographic projections are common in engineering and architecture, because they have the property that distances are preserved in the projected image, regardless of whether the object is near or far from the camera.</p> <p></p> <p>In perspective mode, zooming (for instance, by manually scrolling the mouse) translates the camera forward in space. In orthographic mode, it instead adjusts the field of view without moving the camera. This is because counter-intuitively, translating the camera forward does not actually change the view in an orthographic projection!</p> <code>set_view_projection_mode(mode_name)</code> <p>Set the camera view projection to be either orthographic or perspective (default).</p> <p>Example: <pre><code># Enable the orthographic view\nps.set_view_projection_mode(\"orthographic\")\n\n# Go back to default perspective projection\nps.set_view_projection_mode(\"perspective\")\n</code></pre></p>"},{"location":"basics/camera_controls/#centering-the-view-on-scene-content","title":"Centering the View on Scene Content","text":"<p>To focus on particular areas of interest, hold ctrl+shift (cmd+shift on macOS) and click in the scene. This will re-center the view in the clicked location. You can also hold ctrl+shift (cmd+shift on macOS) and scroll to zoom relative to selected center location, which makes it easer to zoom in on small details. Use the Reset View button to reset the center of interest.</p>    Your browser does not support the video tag.  <code>set_view_center(new_center, fly_to=False)</code> <p>Programmatically set the view center to a location in world-space. For example, with the Turntable view, this changes the center of rotation.</p> <ul> <li><code>new_center</code> a 3d vector position in world space as the new center</li> <li><code>fly_to</code> a boolean indicating whether to animate the update</li> </ul> <p>The input 3D vector can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p> <p>For some view types, the view must immediately be projected to conform to the new center. If <code>fly_to=True</code> this projection will be a smooth flight, otherwise it will be instantaneous.</p> <p>There is also a corresponding <code>get_view_center()</code> returning a vector.</p>"},{"location":"basics/camera_controls/#savingrestoring-views","title":"Saving/Restoring Views","text":"<p>The current camera view (location, direction, camera parameters, and window size) can be saved or loaded from a json string. This is useful for quickly setting up repeatable visualizations.</p> <p>Also, in the Polyscope GUI, this string can be copied to the clipboard at any time via the \u201ccopy\u201d hotkey (ctrl-C or cmd-C), or loaded from your current clipboard using the \u201cpaste\u201d hotkey (ctrl-V or cmd-V).</p> <code>get_view_as_json()</code> <p>Get the current view parameters specified as a json string. Returns a string.</p> <p>Example: <pre><code>import polyscope as ps\nmy_str = ps.get_view_as_json()\n</code></pre></p> <code>void set_view_from_json(json_str)</code> <p>Set the current view to match the parameters specified in the json string.</p> <p>Example: <pre><code>ps.set_view_from_json(my_str);\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-parameters-objects","title":"Camera Parameters Objects","text":"<p><code>CameraParameters</code> objects describe a camera view in Polyscope, including its intrinsics (the field of view and aspect ratio), and extrinsics (the location and orientation). These parameters are used both for manipulations of the interactive viewport, as well as creating Camera View structures which are visualized as part of the content in your scene.</p> <p>Example: <pre><code>import polyscope as ps\n\n# construct camera parameters\nintrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\nparams = ps.CameraParameters(intrinsics, extrinsics)\n\n# set the viewport view to those parameters\nps.set_view_camera_parameters(params)\n\n# get the current viewport view\ncurr_params = ps.get_view_camera_parameters()\n\n# or, use the parameters to create a camera view\ncam = ps.register_camera_view(\"cam1\", params)\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-intrinsics","title":"Camera Intrinsics","text":"<p>A <code>CameraIntrinsics</code> object describes the field of view and aspect ratio of a camera. It does not describe a \u201cpixel resolution\u201d for a camera\u2014you could have many images of different resolutions all associated with the same camera, as long as the aspect ratios are right.</p> <p>Camera intrinsics can be created by specifying any pair of vertical field of view, horizontal field of view, and aspect ratio.</p> <code>CameraIntrinsics(fov_vertical_deg=None, fov_horizontal_deg=None, aspect=None)</code> <p>Construct camera intrinsics. You must specify exactly two of the following parameters</p> <ul> <li><code>fov_vertical_deg</code> vertical field of view in degrees</li> <li><code>fov_horizontal_deg</code> horizontal field of view in degrees</li> <li><code>aspect</code> aspect ratio, as <code>width / height</code></li> </ul> <p>Example: <pre><code>intrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-extrinsics","title":"Camera Extrinsics","text":"<p>A <code>CameraExtrinsics</code> object describes the location and orientation of a camera. It can be defined by the forward/up/right axes of the camera in world coordinates, or via an extrinsic matrix, typically denoted <code>E</code>, which maps points in world coordinates to points in the camera\u2019s local coordinate system. Polyscope uses openGL conventions for camera space, such that the camera points toward the -Z axis, with +Y pointing up and +X pointing right.</p> <p>Camera extrinsics can be created by specifying frame axes or an extrinsic matrix.</p> <code>CameraExtrinsics(root=None, look_dir=None, up_dir=None, mat=None)</code> <p>Construct camera extrinsics.</p> <p>You must specify either all three of:</p> <ul> <li><code>root</code> the world-space position of the camera</li> <li><code>look_dir</code> a world-space unit vector along which the camera looks</li> <li><code>up_dir</code> a world-space unit vector defining the up axis for the camera</li> </ul> <p>Or specify: - <code>mat</code> a 4x4 matrix mapping points in world-space to local camera space. Polyscope\u2019s camera space uses openGL convention.</p> <p>All vectors and matrices should be numpy arrays, or something which a numpy array can be constructed from (like a tuple of floats).</p> <p>Example: <pre><code>extrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\n</code></pre></p>"},{"location":"basics/camera_controls/#camera-parameters","title":"Camera Parameters","text":"<p>The <code>CameraParameters</code> object combines a set of intrinsics and extrinsics to fully define a camera.</p> <code>CameraParameters(intrinsics, extrinsics)</code> <p>Construct camera parameters from intrinsics and extrinsics.</p> <p>Example: <pre><code>intrinsics = ps.CameraIntrinsics(fov_vertical_deg=60., aspect=2.)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., 0., 0.), up_dir=(0.,1.,0.))\nparams = ps.CameraParameters(intrinsics, extrinsics)\n</code></pre></p> <p>Various getters access the intrinsic and extrinsic properties of the parameters object. <pre><code># intrinsics\nCameraParameters.get_fov_vertical_deg()\nCameraParameters.get_aspect()\n\n# extrinsics\nCameraParameters.get_T()\nCameraParameters.get_R()\nCameraParameters.get_view_mat()     # synonym for get_E()\nCameraParameters.get_E()\nCameraParameters.get_position()\nCameraParameters.get_look_dir()\nCameraParameters.get_up_dir()\nCameraParameters.get_right_dir()\nCameraParameters.get_camera_frame() # &lt;look, up, right&gt; world-space vectors\n</code></pre></p>"},{"location":"basics/camera_controls/#generating-pixel-rays","title":"Generating pixel rays","text":"<p>It is often necessary to generate the world-space ray corresponding to each pixel of an image in a camera view. The base point for these rays is easy, it is just <code>params.get_position()</code>. However the ray directions vary-per pixel; the <code>CameraParameters</code> object has two helpers to automatically construct these rays.</p> <code>CameraParameters.generate_camera_rays(dims, image_origin='upper_left')</code> <p>Generate an array of rays corresponding to an image with the given resolution <code>dims=(w,h)</code>. The result is a <code>[h,w,3]</code> numpy buffer. Ray origins are all implicitly given by <code>params.get_position()</code>.</p> <p>Example: <pre><code>rays = params.generate_camera_rays((300,200))\n</code></pre></p> <code>CameraParameters.generate_camera_ray_corners()</code> <p>Generate the rays corresponding to the [upperleft, upperright, lowerleft, lowerright] corners of the camera\u2019s view. </p> <p>This method is useful because the caller can easily linearly interpolate the normalize get ray directions for all pixels in an image, but this method just needs to return a small amount of data. This makes it easy to e.g. generate rays for a real-time renderer on a GPU, without transferring a whole buffer of ray directions for each frame.</p>"},{"location":"basics/flow/","title":"Basic Flow","text":"<p>This page describes the basic control flow to initialize Polyscope and invoke it from you program. See the structures and quantities sections on the left for the various kinds of data you can add to Polyscope.</p> <p>Polyscope needs to be initialized exactly once by calling <code>init()</code>, typically near the beginning of your program. You can then register structures to the scene, and show the window using either of two methods.</p>"},{"location":"basics/flow/#program-structure","title":"Program Structure","text":"<p>There are two separate ways to structure your program\u2019s control flow with polyscope.  Either way, <code>init()</code> must be called first.</p> <p>Option 1: show() The simpler, and more-common approach is to call <code>show()</code>, which will run Polyscope\u2019s window continuously. The <code>show()</code> function will not return until the window is closed. If you want to execute your own code while the Polyscope window is active, you must do so via the <code>user_callback</code>.</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# ... your code ...\n# ... add visualizations to Polyscope, etc ...\n\n# if desired, set up a user_callback to execute your code each\n# frame and add ImGui UI elements\n\nps.show() # shows the UI, blocks until the UI exits\n\n# If desired, add more visualizations, then show the UI again.\n# Data is preserved between calls to show() unless explicitly removed.\n# ... your code ...\nps.show()\n</code></pre> <p>Option 2: frame_tick() An alternate approach is to manually call <code>frame_tick()</code> in a tight loop to run the UI. This is useful to quickly integrate Polyscope into existing programs which already have a main loop. The <code>user_callback</code> is still necessary to add ImGui UI elements.</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# if desired, set up a user_callback to add ImGui UI elements\n\nwhile(not ps.window_requests_close()):\n\n    #  ... your code ...\n    #  ... add visualizations to Polyscope, etc ...\n\n    ps.frame_tick() # renders one UI frame, returns immediately\n</code></pre> <p>When using <code>frame_tick()</code>, see the setting <code>set_frame_tick_limit_fps_mode()</code> to customize the rate at which this loop executes, e.g. to lock it to a fixed rate like 60 fps. By default, it will execute as quickly as possible, but Polyscope will only actually render when needed to hit the target framerate.</p> <p>Where to make ImGui calls</p> <p>Polyscope includes ImGui, allowing you to build custom UI elements like buttons and fields. </p> <p>Regardless of which control flow method you use, ImGui calls can only be made within the <code>userCallback</code> function. Making ImGui calls elsewhere will lead to errors and crashes.</p>"},{"location":"basics/flow/#functions","title":"Functions","text":"<code>init(backend=\"\")</code> <code>show()</code> <code>unshow()</code> <code>frame_tick()</code> <code>window_requests_close()</code> <code>set_frame_tick_limit_fps_mode(mode_str)</code>"},{"location":"basics/flow/#init","title":"init()","text":"<p>Initialize polyscope. Should be called exactly once, generally at the beginning of a program. Will throw an error if anything goes wrong during initialization.</p> <p>Performs one-time work like setting up openGL and creating a window.</p> <p><code>backend</code> is an optional specifier for which rendering backend to use, passing <code>\"\"</code> selects a reasonable default backend. Generally, you should not need to manually set the backend.</p>"},{"location":"basics/flow/#show","title":"show()","text":"<p>Give control to the polyscope GUI. Blocks until the user returns control via the GUI, possibly by exiting the window.</p> <p>This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to <code>frame_ticK()</code> and <code>show()</code>.</p> <p>You can even nest calls to <code>show()</code>\u2014for instance, if the user clicks a button in your callback which executes some function, you can invoke <code>show()</code> again within that function for immediate debugging. Closing the nested window will then \u201cpop back\u201d to continue displaying the previously shown GUI.</p> <p>If desired, register a <code>user_callback</code> which will be internally executed by Polyscope within each frame, you may not make ImGui calls arbitrarily throughout your code.</p> <p>Several options are available which affect the behavior of <code>show()</code>, such as whether the window is automatically brought to the front and given focus. See the options listing for details.</p>"},{"location":"basics/flow/#unshow","title":"unshow()","text":"<p>The opposite of <code>show()</code>. If <code>show()</code> is currently active, this closes the window and causes the call to <code>show()</code> to return. This is equivalent to manually closing the Polyscope window by clicking the window manager\u2019s close button.</p> <p>Generally it is not necessary to call this function; the user can exit by closing the window. However, <code>unshow()</code> may be useful to programmatically close the window when a condition is met, or via a custom ImGui element.</p> <p><code>unshow()</code> does not deinitialize Polyscope. You can still call <code>show()</code> again after.</p>"},{"location":"basics/flow/#frame_tick","title":"frame_tick()","text":"<p>Render one frame of the polyscope UI. This function needs to be called in a tight loop by your code, like:</p> <pre><code>ps.init()\n\nwhile(not ps.window_requests_close()):\n\n    # \n    # ... your code ...\n    # \n\n    ps.frame_tick()\n</code></pre> <p>If <code>frame_tick()</code> is not called often enough, the interface will be unresponsive.</p> <p>This function can be called anywhere, and can be called multiple times to re-open the GUI after it has been closed. Existing data will be preserved between calls to <code>frame_ticK()</code> and <code>show()</code>.</p> <p>If any ImGui UI elements are to be created, they must be created inside of a <code>user_callback()</code> (which will be internally executed by Polyscope within each <code>frame_tick()</code>, you may not make ImGui calls arbitrarily throughout your code.</p> <p>The <code>frame_tick()</code> function can be called anywhere within your program\u2019s control flow, including from multiple call sites. You may also interleave or nest calls to <code>frame_tick()</code> and <code>show()</code> to use both kinds of control flow within a program.</p>"},{"location":"basics/flow/#window_requests_close","title":"window_requests_close()","text":"<p>Returns <code>True</code> if the user has tried to exit the window at the OS level, e.g. by clicking the close button. </p> <p>Useful for deciding when to exit your control loop when using <code>frame_tick()</code>.</p>"},{"location":"basics/flow/#frame_tick_limit_fps_mode","title":"frame_tick_limit_fps_mode","text":"<p>Set how the frames per second settings such as <code>set_max_fps()</code> and <code>set_enable_vsync()</code> should be respected when using <code>frame_tick()</code> to run the main loop. (see program options for more details on those settings)</p> <p>The argument is one of the following strings:</p> <ul> <li><code>'ignore_limits'</code>: Any FPS/vsync limits will be ignored, <code>frame_tick()</code> will execute as fast as possible, rendering each time and immediately returning.</li> <li><code>'block_to_hit_target'</code>: Any FPS/vsync will be respected, and the call to <code>frame_tick()</code> will block to sleep as needed to hit the target framerate, similar to <code>show()</code>. This is usually what you want for simple interactive visualization applications.</li> <li><code>'skip_frames_to_hit_target'</code>: Any FPS/vsync will be respected for rendering, but the call to <code>frame_tick()</code> will always return as quickly as possible, skipping rendering and any callbacks when not needed to hit the framerate so your main loop may iterate much faster. This is useful when you want to call <code>frame_tick()</code> in a very tight loop without slowing down your program, such as in a training or optimization loop. (default)</li> </ul> <p>frame tick only! This setting only has any effect if you are using <code>frame_tick()</code> to run your main loop. If you used <code>show()</code>, it is ignored, and you can adjust the FPS with the <code>set_max_fps()</code> setting.</p>"},{"location":"basics/interactive_UIs_and_animation/","title":"Interactive UIs & Animation","text":"<p>Polyscope enables you to create custom interactive UIs with your own GUI elements such as buttons, sliders, and textboxes which execute user-defined code. </p> <p>Likewise, there is no explicit built-in functionality for time-varying data in Polyscope, but you can easily create custom UIs to display and update your content.</p> <p>In either case, you can create interactive UI elements with the excellent Dear ImGui library, see below for more.</p> <p></p>"},{"location":"basics/interactive_UIs_and_animation/#basic-flow-for-interactive-uis-and-animation","title":"Basic Flow for Interactive UIs and Animation","text":"<p>The first step is to get your code executing every frame while the Polyscope window is open and running.</p> <p>You can specify a callback function which Polyscope will invoke on each frame while the window is active.  This callback can be used to build a program-specific GUI, update an animation, perform computation, etc.  With this approach, you simplify set the desired callback function, and then call <code>polyscope.show()</code> as usual.</p> <p>Your callback function should have no arguments and no return value. To use state inside your callback, access it directly from the outer scope where your function was defined.</p> <p>Example: <pre><code>import polyscope as ps\nimport polyscope.imgui as psim\nimport numpy as np\n\nps.init()\n\n# track state\nmy_val = 10\n\ndef my_other_function():\n    print(\"hello\")\n\ndef callback():\n    # Executed every frame\n\n    # Update content in the scene\n    ps.register_point_cloud(\"this frame point\", np.random.rand(100, 3))\n\n    # access state from the outer scope\n    global my_val # note: python has weird rules about 'global' vs 'nonlocal'\n\n    # Build a UI element to edit a parameter, which will \n    # appear in the onscreen panel\n    _, my_val = psim.InputInt(\"my val\", my_val)\n\n    if psim.Button(\"run subroutine\"):\n        my_other_function()\n\nps.set_user_callback(callback)\nps.show()\n</code></pre></p> <code>set_user_callback(func)</code> <p>Set a function which will be called by polyscope on every UI draw iteration. The argument should be a Python function, which takes no arguments.</p> <code>clear_user_callback()</code> <p>Clear the callback function.</p> <p>callback sets up ImGui internally</p> <p>By default, when the user callback executes, Polyscope will internally set up an <code>ImGui</code> pane for you to create UI elements in. You can immediately make calls like <code>psim.Button()</code> in the callback without any additional ImGui bookkeeping.</p> <p>This behavior is configurable with an option below.</p> <p>Updating data from main loop with <code>frame_tick()</code></p> <p>Nested calls to <code>show()</code></p>"},{"location":"basics/interactive_UIs_and_animation/#custom-main-loops","title":"Custom main loops","text":"<p>As described in program structure, it is alternately possible to run the Polyscope window not by calling <code>show()</code>, but by writing your own main loop, and calling <code>frame_tick()</code> on each iteration.</p> <p>If you choose this route, you can also modify scene content by simple issuing polyscope calls like <code>register_surface_mesh()</code> at any point in your main loop.</p> <p>However, you cannot issue ImGui calls at any point in your main loop. This limitation is because Polyscope needs to set up the ImGui context, which is not available as your main loop executes.</p> <p>Fortunately, you can still use the user callback to create ImGui UIs. You can specify your callback function as above, and it will be executed each frame, even when running Polyscope from your own main loop.</p>"},{"location":"basics/interactive_UIs_and_animation/#nested-show","title":"Nested show","text":"<p>When creating custom UIs, you may find you want to call <code>show()</code> to open the interactive window, within a frame which is already executing the main loop.</p> <p>For example, you might create a button which calls a user-specified function. Within that function, if you hit a bug, you could register some extra data to understand the problem, call <code>show()</code> to investigate, then exit the window and continue running the outer program loop.</p> <p>This is a supported workflow! It should be possible to arbitrarily recurse into the show function, interacting with the scene even as an outer loop is executing.</p> <p>By default the user callback will not be executed within any of these nested calls to show, only the outermost one (configurable with an option below). Be careful not write an recursion of calling <code>show()</code>!</p>"},{"location":"basics/interactive_UIs_and_animation/#options","title":"Options","text":"<code>set_open_imgui_window_for_user_callback(b)</code> <p>If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like <code>polyscope.imgui.Button(\"do stuff\")</code>. </p> <p>If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any).</p> <p>Default: <code>True</code>.</p> <code>set_invoke_user_callback_for_nested_show(b)</code> <p>Suppose you call <code>polyscope.show()</code>, and within your callback, another instance of <code>polyscope.show()</code> is called\u2014this is a nested show.</p> <p>Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option.</p> <p>If true, your callback will be executed as normal for every main loop iteration, even in nested show windows.</p> <p>If false, your callback will only be executed for initial, outermost calls to <code>polyscope.show()</code>.</p> <p>Default: <code>False</code>.</p> <code>set_give_focus_on_show(b)</code> <p>If true, the Polyscope window will request focus from the window manager whenever <code>show()</code> is called. If false, the focus state will be left unchanged.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/interactive_UIs_and_animation/#updating-animated-data","title":"Updating Animated Data","text":"<p>Once you have code executing per-frame, you can issue Polyscope commands on each invocation to update the data.</p> <p>The simplest approach is to just re-call structure-registration or quantity-adder functions with the updated data. Adding new structures/quantities with the same name will replace any existing ones, they will even inherit any options which have been set. This should be fast enough for small-medium sized data at interactive rates.</p> <p>Additionally, some structures have special more-efficient functions which update the structure in-place, if you are not changing the number of elements (e.g. <code>SurfaceMesh.update_vertex_positions()</code>). Currently, if you are changing the number of elements (number of points in a point cloud, or number of vertices or connectivity of a mesh), you have no choice but to register a whole new structure.</p> <p>Example: A typical basic setup for playing time-series data</p> <pre><code>import polyscope as ps\nimport polyscope.imgui as psim\nimport numpy as np\n\n# a list of your data for each frame\nn_timestep = 50\nn_pts = 1000\nper_frame_points = np.random.rand(n_timestep, n_pts, 3) # random sample data\n\n# UI state\ncurr_frame = 0\nauto_playing = True\n\ndef myCallback(): # gets executed per-frame\n\n  # Python scope resolution quirks\n  # may need `nonlocal` rather than `global`` if your callback is \n  # defined inside another function\n  global curr_frame, auto_playing\n\n  update_frame_data = False\n  _, auto_playing = psim.Checkbox(\"Autoplay\", auto_playing)\n\n  # Advance the frame\n  if auto_playing:\n    update_frame_data = True\n    curr_frame = (curr_frame + 1) % n_timestep\n\n  # Slider to manually scrub through frames  \n  slider_updated, curr_frame = psim.SliderInt(\"Curr Frame\", curr_frame, 0, n_timestep-1)\n  update_frame_data = update_frame_data or slider_updated\n\n  # Update the scene content if-needed\n  if update_frame_data:\n    ps.register_point_cloud(\"frame points\", per_frame_points[curr_frame,:,:])\n\nps.init()\n\n# set the scene scale manually so it doesn't jump around \n# as the data changes\nps.set_automatically_compute_scene_extents(False)\nps.set_length_scale(1)\nps.set_bounding_box((-1., -1., -1.), (1., 1., 1.))\n\nps.set_user_callback(myCallback) # specify the per-frame function\n\n# give control to the main loop, blocks until window is exited\nps.show()\n</code></pre>"},{"location":"basics/interactive_UIs_and_animation/#custom-uis-with-imgui","title":"Custom UIs with ImGui","text":"<p>Polyscope integrates with the Dear ImGui library, a widely-used framework for creating prototype/demo UIs and widgets. It implements a huge variety of GUI elements including buttons, sliders, text boxes, color pickers, trees, tables, etc.</p> <p>The Polyscope python package includes bindings to a significant subset of ImGui in the <code>polyscope.imgui</code> submodule. </p> <p>These bindings are not yet exhaustively documented, but they follow the naming conventions of ImGui as closely as possible for simplicity. Documentation of ImGui functions and parameters lives here, and  you can find the list of bound functions, types, and enums here. Common usage should be covered by the example below.</p>"},{"location":"basics/interactive_UIs_and_animation/#2d-plots-with-implot","title":"2D Plots with ImPlot","text":"<p>Polyscope also provides ImPlot for creating little inline 2D plots like line plots, scatter plots, and histograms in the UI panes. As with ImGui, please see ImPlot\u2019s pages for documentation. </p> <p>Bindings are defined in the <code>polyscope.implot</code> submodule, and again attempt to follow the original ImPlot naming exactly. Many but not all functions are bound, please file an issue for any missed functionality.</p>"},{"location":"basics/interactive_UIs_and_animation/#sample-custom-ui","title":"Sample Custom UI","text":"<p>Example: Create the following UI in a Python callback</p> <p></p> <pre><code>import polyscope as ps\nimport polyscope.imgui as psim\nimport polyscope.implot as psimplot\nimport numpy as np\n\n# A bunch of parameters which we will manipulate via the UI defined below.\n# There is nothing special about these variables, you could manipulate any other \n# kind of Python values the same way, such as entries in a dict, or class members.\nis_true1 = False\nis_true2 = True\nui_int = 7\nui_float1 = -3.2\nui_float2 = 0.8\nui_color3 = (1., 0.5, 0.5)\nui_color4 = (0.3, 0.5, 0.5, 0.8)\nui_angle_rad = 0.2\nui_text = \"some input text\"\nui_options = [\"option A\", \"option B\", \"option C\"]\nui_options_selected = ui_options[1]\n\ndef my_function():\n    # ... do something important here ...\n    print(\"executing function\")\n\n# Define our callback function, which Polyscope will repeatedly execute while running the UI.\n# We can write any code we want here, but in particular it is an opportunity to create ImGui \n# interface elements and define a custom UI.\ndef callback():\n\n    # If we want to use local variables &amp; assign to them in the UI code below, \n    # we need to mark them as nonlocal. This is because of how Python scoping \n    # rules work, not anything particular about Polyscope or ImGui.\n    # Of course, you can also use any other kind of python variable as a controllable \n    # value in the UI, such as a value from a dictionary, or a class member. Just be \n    # sure to assign the result of the ImGui call to the value, as in the examples below.\n    # \n    # If these variables are defined at the top level of a Python script file (i.e., not\n    # inside any method), you will need to use the `global` keyword instead of `nonlocal`.\n    nonlocal is_true1, is_true2, ui_int, ui_float1, ui_float2, ui_color3, ui_color4, ui_text, ui_options_selected, ui_angle_rad\n\n\n    # == Settings\n\n    # Use settings like this to change the UI appearance.\n    # Note that it is a push/pop pair, with the matching pop() below.\n    psim.PushItemWidth(150)\n\n\n    # == Show text in the UI\n\n    psim.TextUnformatted(\"Some sample text\")\n    psim.TextUnformatted(\"An important value: {}\".format(42))\n    psim.Separator()\n\n\n    # == Buttons\n\n    if(psim.Button(\"A button\")):\n        # This code is executed when the button is pressed\n        print(\"Hello\")\n\n    # By default, each element goes on a new line. Use this \n    # to put the next element on the _same_ line.\n    psim.SameLine() \n\n    if(psim.Button(\"Another button\")):\n        # This code is executed when the button is pressed\n        my_function()\n\n\n    # == Set parameters\n\n    # These commands allow the user to adjust the value of variables.\n    # It is important that we assign the return result to the variable to\n    # update it. \n    # For most elements, the return is actually a tuple `(changed, newval)`, \n    # where `changed` indicates whether the setting was modified on this \n    # frame, and `newval` gives the new value of the variable (or the same \n    # old value if unchanged).\n    #\n    # For numeric inputs, ctrl-click on the box to type in a value.\n\n    # Checkbox\n    changed, is_true1 = psim.Checkbox(\"flag1\", is_true1) \n    if(changed): # optionally, use this conditional to take action on the new value\n        pass \n    psim.SameLine() \n    changed, is_true2 = psim.Checkbox(\"flag2\", is_true2) \n\n    # Input ints\n    changed, ui_int = psim.InputInt(\"ui_int\", ui_int, step=1, step_fast=10) \n\n    # Input floats using two different styles of widget\n    changed, ui_float1 = psim.InputFloat(\"ui_float1\", ui_float1) \n    psim.SameLine() \n    changed, ui_float2 = psim.SliderFloat(\"ui_float2\", ui_float2, v_min=-5, v_max=5)\n\n    # Input colors\n    changed, ui_color3 = psim.ColorEdit3(\"ui_color3\", ui_color3)\n    psim.SameLine() \n    changed, ui_color4 = psim.ColorEdit4(\"ui_color4\", ui_color4)\n\n    # Input text\n    changed, ui_text = psim.InputText(\"enter text\", ui_text)\n\n    # Combo box to choose from options\n    # There, the options are a list of strings in `ui_options`,\n    # and the currently selected element is stored in `ui_options_selected`.\n    psim.PushItemWidth(200)\n    changed = psim.BeginCombo(\"Pick one\", ui_options_selected)\n    if changed:\n        for val in ui_options:\n            _, selected = psim.Selectable(val, ui_options_selected==val)\n            if selected:\n                ui_options_selected = val\n        psim.EndCombo()\n    psim.PopItemWidth()\n\n\n    # Use tree headers to logically group options\n\n    # This a stateful option to set the tree node below to be open initially.\n    # The second argument is a flag, which works like a bitmask.\n    # Many ImGui elements accept flags to modify their behavior.\n    psim.SetNextItemOpen(True, psim.ImGuiCond_FirstUseEver)\n\n    # The body is executed only when the sub-menu is open. Note the push/pop pair!\n    if(psim.TreeNode(\"Collapsible sub-menu\")):\n\n        psim.TextUnformatted(\"Detailed information\")\n\n        if(psim.Button(\"sub-button\")):\n            print(\"hello\")\n\n        # There are many different UI elements offered by ImGui, many of which\n        # are bound in python by Polyscope. See ImGui's documentation in `imgui.h`,\n        # or the polyscope bindings in `polyscope/src/cpp/imgui.cpp`.\n        changed, ui_angle_rad = psim.SliderAngle(\"ui_float2\", ui_angle_rad, \n                v_degrees_min=-90, v_degrees_max=90)\n\n        psim.TreePop()\n\n    psim.PopItemWidth()\n\n\n    # Add a plot            \n    if psimplot.BeginPlot(\"test line plot\"):\n        psimplot.PlotLine(\"line plot\", np.random.rand(10))\n        psimplot.PlotInfLines(\"horizontal lines\", np.random.rand(3), psimplot.ImPlotInfLinesFlags_Horizontal)\n        psimplot.EndPlot()\n\n\nps.init() \nps.set_user_callback(callback)\nps.show()\n</code></pre>"},{"location":"basics/interactive_UIs_and_animation/#mouse-interactions","title":"Mouse Interactions","text":"<p>You can implement custom mouse behaviors on clicks and other actions within your per-frame callback function. ImGui exposes the state of the mouse and whether a click occurred via <code>psim.GetIO()</code>.</p> Temporarily disable default mouse camera movement <p>If you implement your own interactions like clicking-and-dragging objects onscreen, you\u2019ll find that the Polyscope view camera unintentionally moves in response to these motions. You can temporarily disable the camera motion like:</p> <pre><code>if doing_interaction and psim.IsMouseClicked(1): \n    ps.set_do_default_mouse_interaction(False)\n    # ... do your interaction\n\nif not doing_interaction:\n    # re-enable the default mouse motions after you're done\n    ps.set_do_default_mouse_interaction(True)\n</code></pre> <code>screen_coords_to_world_ray(screen_coords)</code> <p>Convert a click location to a ray in world-space.</p> <code>screen_coords_to_world_position(screen_coords)</code> <p>Convert a click location to a location in world-space, by reading from the scene\u2019s depth buffer.</p> <code>set_do_default_mouse_interaction(b)</code> <p>Use this function to (temporarily) disable Polyscope\u2019s default mouse clicking/panning/zooming response to mouse movements, so that they will not conflict with your own implemented operations</p> <p>If <code>True</code>, Polyscope will perform its usual responses to mouse operations, <code>False</code> will disable.</p>"},{"location":"basics/interactive_UIs_and_animation/#picking-selection-and-querying-the-scene","title":"Picking, Selection, and Querying the Scene","text":"<p>\u201cPicking\u201d refers to querying the content under the cursor in the rendered image.  Polyscope implements render buffer-based picking, to efficiently get the object and element under the cursor even on large complex scenes.</p> <code>pick(screen_coords=None, buffer_inds=None)</code> <p>Evaluate a \u201cpick\u201d query to get the contents of the rendered view at a specified location.  One of <code>screen_coords</code> or <code>buffer_inds</code> should be passed as the input location, but not both.  The return is a <code>PickResult</code> class, see below. </p> <p>Screen coordinates and buffer indices both refer to a location in the rendered 2d image. Screen coordinates are real-valued, whereas buffer indices are integer. On some platforms they may be identical, but on others with high-DPI screens, they may differ. In the common-case of getting mouse positions from ImGui, you want screen coords.</p> <p>Example: picking a faces from a mesh <pre><code># inside the user-callback, or other code which runs each frame\nmyMesh = # ...  your added mesh ... */\n\n# make only faces clickable in the mesh\nmyMesh.set_selection_mode('faces_only')\n\n# get the mouse location from ImGui\nio = psim.GetIO()\nif io.MouseClicked[0]: # if clicked\n  screen_coords = io.MousePos\n  pick_result = polyscope.pick(screen_coords=screen_coords)\n\n  # check out pick_result.is_hit, pick_result.structureName, pick_result.depth, etc\n\n  # get additional information if we clicked on a mesh\n  if(pick_result.isHit and pick_result.structure_name == \"myMesh\"):\n    print(pick_result.structure_data) # additional dictionary of element type, coords, etc.\n</code></pre></p> <p>A pick query returns a combined struct with info such as what structure was clicked on, and depth of the point in the scene.</p> <pre><code>class PickResult:\n    self.is_hit = ...               # did we hit anything?\n    self.structure_type_name = ...  # structure type which was hit, like \"Point Cloud\"\n    self.structure_name = ...       # name of structure which was hit, like \"my_points\"\n    self.quantity_name = ...        # name of quantity which was hit (most quantities cannot be picked, you pick the structure instead)\n    self.screen_coords = ...        # coordinates of the query location\n    self.buffer_inds = ...          # render buffer indices of the query location\n    self.position = ...             # 3d position which was hit, in world space\n    self.depth = ...                # depth to the hit, in world units\n    self.local_index = ...          # structure-specific index of the element which was hit\n    self.structure_data = ...       # a dictionary of additional fields for the clicked structure\n</code></pre> <p>Additionally, many structures will report additional information about the pick, in the <code>structure_data</code> field. For instance, a <code>SurfaceMesh</code> gives info on whether a vertex/face/edge/etc was clicked on, the index of that element, and barycentric coordinates of the click within a face.</p> <p>Polyscope also maintains a stateful selection, displayed in the UI to provide information about the content of the scene. It can be accessed via <code>get_selection()</code>, <code>reset_selection()</code>, <code>have_selection()</code>.</p>"},{"location":"basics/interactive_UIs_and_animation/#overriding-built-in-ui-behavior","title":"Overriding Built-In UI Behavior","text":"<p>If desired, you can circumvent Polyscope\u2019s standard ImGui style and UI panes, in ordered to build dramatically customized applications.</p> <p>The option <code>build_gui</code> can be used to entirely disable all of Polyscope\u2019s ImGui UI elements, allowing you to build your own UI. Polyscope will still initialize ImGui and invoke its drawing routines each frame.</p> <code>set_build_gui(b)</code> <p>This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope.</p> <p>If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs.</p> <p>Default: <code>True</code>.</p> <p>The functions <code>build_polyscope_gui()</code>, <code>build_structure_gui()</code>, <code>build_pick_gui()</code>, and <code>build_user_gui_and_invoke_callback()</code>  can be used to manually build pieces of the UI one at a time. If you are giving control to the UI via <code>show()</code>, you call the first 3 to reproduce the standard UI.</p>"},{"location":"basics/parameters/","title":"Parameters","text":"<p>Many structures and quantities in Polyscope have optional values which can be set to control their appearance or behavior, such as the radius of points in a point cloud or the color of a mesh. These values can generally be manually adjusted in the GUI, or set programmatically in code.</p> <p>This page documents special features in Polyscope which provide extra functionality while setting these parameters.</p>"},{"location":"basics/parameters/#persistent-values","title":"Persistent values","text":"<p>In Polyscope, if you manually set the color of points in a point cloud (for instance), then register a new point cloud with the same name overwriting the original, the new point cloud will inherit the old point cloud\u2019s color. This functionality, and other similar behavior, is implemented via persistent values.</p> <p>Persistent values are lightweight wrappers around a variable which on-construction look up the variable in a global cache, and if a cache entry exists take the cached value instead. Any time the variable is written to, its value is recorded in the global cache. Generally, the cache key includes the name of a structure (and quantity if applicable), so a cached variable will only be picked up when names match.</p> <p>Generally, the user should not manually interact with persistent values ever, all you need to know is that some variables may \u201cmagically\u201d remember their old values by pulling them from a cache. <pre><code>ps_cloud = ps.get_point_cloud(\"my cloud\")\nps_cloud.set_color((0.5, 0.5, 0.5))\n# the persistent value is recorded in the cache\n\n# ... later ...\n\nnew_cloud = ps.register_point_cloud(\"my cloud\", new_points);\n# new_cloud will automatically pick up the pointColor we set above, \n# since this point cloud has the same name\n</code></pre> Note that this persistence behavior applies even when variables are manually manipulated in the GUI.</p>"},{"location":"basics/parameters/#scaled-values","title":"Scaled values","text":"<p>Specifying appearance (such as the radius of points in a point cloud) in global length units can be inconvenient; its generally much easier to set values relatively, which respect to some reasonable length scale. Many Polyscope parameters take a <code>relative</code> option, which is usually <code>True</code> by default, to set lengths relatively.</p> <pre><code>ps_cloud = ps.get_point_cloud(\"my cloud\")\n\n# radius will be 0.05 * lengthScale when used\nps_cloud.set_radius(0.05); \nps_cloud.set_radius(0.05, relative=True); # same as previous (default is True)\n</code></pre> <p>However, sometimes you might want to actually use an absolute value for a parameter, for instance to get exactly the same appearance between runs of a program on different data. To support that, scaled values can optionally be set as absolute values, which will not be scaled before use.</p> <pre><code># radius will be 1.6 when used\nps_cloud.set_radius(1.6, relative=False)\n</code></pre> <p>Note that scaled values can be (and often are) used as persistent values, as described above; the two concepts are complementary. </p>"},{"location":"basics/program_options/","title":"Program Options","text":"<p>These are general settings which affect polyscope\u2019s behavior as a library. It is often convenient to set them just before calling <code>polyscope.init()</code>, but they may generally be set anywhere.</p> <pre><code>import polyscope as ps\n\n# a few options\nps.set_program_name(\"important app\")\nps.set_verbosity(0)\nps.set_use_prefs_file(False)\n\n# initialize\nps.init()\n</code></pre>"},{"location":"basics/program_options/#options","title":"Options","text":"<code>set_program_name(name)</code> <code>set_verbosity(v)</code> <code>set_print_prefix(p)</code> <code>set_errors_throw_exceptions(b)</code> <code>set_enable_render_error_checks(b)</code> <code>set_warn_for_invalid_values(b)</code> <code>set_SSAA_factor(n)</code> <code>set_max_fps(f)</code> <code>set_enable_vsync(b)</code> <code>set_use_prefs_file(b)</code> <code>set_always_redraw(b)</code> <code>set_ui_scale(scale)</code> <code>set_build_gui(b)</code> <code>set_open_imgui_window_for_user_callback(b)</code> <code>set_invoke_user_callback_for_nested_show(b)</code> <code>set_give_focus_on_show(b)</code>"},{"location":"basics/program_options/#program-name","title":"program name","text":"<p>A general name to use when referring to the program in window headings, etc. Default: <code>Polyscope</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_program_name(\"important app\")\n</code></pre></p>"},{"location":"basics/program_options/#verbosity","title":"verbosity","text":"<p>How much useful info should polyscope print to stdout? Default: <code>1</code>.</p> <ul> <li><code>0</code> print nothing</li> <li><code>1</code> print occasionally</li> <li><code>&gt;= 2</code> print a lot</li> </ul> <p>Example: <pre><code>import polyscope as ps\nps.set_verbosity(0)\n</code></pre></p>"},{"location":"basics/program_options/#print-prefix","title":"print prefix","text":"<p>A string used as a prefix for all messages printed to the terminal by polyscope.  Default: <code>[polyscope]</code>.</p> <p>Example: <pre><code>import polyscope as ps\nps.set_print_prefix(\"[MYAPP] \");\n# prints now look like \"[MYAPP] loaded openGL\"\n</code></pre></p>"},{"location":"basics/program_options/#errors-throw-execptions","title":"errors throw execptions","text":"<p>If true, errors in polyscope raise execptions. If false, a polyscope error is shown in the UI, but processing attempts to continue. Default: <code>False</code>.</p>"},{"location":"basics/program_options/#render-error-checks","title":"render error checks","text":"<p>If true, the rendering subsystem will eagerly check for and report errors. This comes at some small performance cost, but can help catch problems.</p> <p>Default: <code>True</code> when compiled in <code>Debug</code> mode, <code>False</code> in <code>Release</code> mode (</p>"},{"location":"basics/program_options/#warn-for-invalid-values","title":"warn for invalid values","text":"<p>If true, polyscope will give warnings when any added values are <code>inf</code> or <code>NaN</code>. Most (but not quite all) floating-point buffers of data such as vertex positions, scalar/color/vector quantities, etc are checked.</p> <p>Default: <code>True</code> </p>"},{"location":"basics/program_options/#ssaa-anti-aliasing-factor","title":"SSAA anti-aliasing factor","text":"<p>Enable super-sampling anti-aliasing for a prettier rendered scene. SSAA renders the scene at multiple samples for each pixel, then averages them to resolve final pixel values. </p> <p>Cost scales quadratically with the value of this parameter, so it will quickly become expensive. Reasonable values are in the range <code>1</code> to <code>4</code>. Using <code>2</code> is generally sufficient for anti-aliasing.</p> <p>Default: <code>1</code> (no anti-aliasing)</p>"},{"location":"basics/program_options/#max-fps","title":"max fps","text":"<p>The main loop will not run at more than <code>maxFPS</code> iterations per second. <code>-1</code> disables, running the loop as fast as possible. Default: <code>60</code>.</p> <p>This behavior may be affected by the <code>set_frame_tick_limit_fps_mode()</code> setting.</p>"},{"location":"basics/program_options/#enable-vsync","title":"enable vsync","text":"<p>VSync synchronizes the rendering process with your display\u2019s framerate, which may fix some visual artifacts. It also typically causes rendering to block to match the refresh rate of your monitor.</p> <p>Default: <code>False</code> on Windows and <code>True</code> on other platforms.</p> <p>This behavior may be affected by the <code>set_frame_tick_limit_fps_mode()</code> setting.</p>"},{"location":"basics/program_options/#use-prefs-file","title":"use prefs file","text":"<p>Polyscope can read and write to a preferences file to save state between invocations. For now, this is primarily used to restore the window position on the desktop. The preference file is a <code>json</code>-formatted plaintext file called <code>.polyscope.ini</code>.</p> <p>This option controls the use of the preferences file. If <code>False</code>, if will be neither written nor read. Default: <code>False</code>.</p> <p>Note</p> <p>Dec 2024 this setting was changed to disabled by default. It is a cause of rare-but-tricky bugs on some platforms, such as saving a window location from one monitor, then attempting to re-load the setting on a smaller monitor causing the window to be placed offscreen.</p>"},{"location":"basics/program_options/#always-redraw","title":"always redraw","text":"<p>Polyscope is designed to use lazy rendering: the scene is only re-drawn if it has changed since the last time it was drawn. This can dramatically reduce resource consumption, and keeps the immediate GUI responsive even on scenes which are irresponsibly large for the machine\u2019s graphics capabilities.</p> <p>If this option is <code>True</code>, the scene will be redrawn on every main loop iteration no matter what, circumventing the lazy drawing features. Default: <code>False</code>.</p>"},{"location":"basics/program_options/#ui-scale","title":"ui scale","text":"<p>A scale factor for all UI elements (text, buttons, panels). Can be useful for increase font sizes on high DPI screens. <code>2.0</code> means make everything twice as large.</p> <p>There is also a corresponding <code>get_ui_scale()</code>.</p> <p>This factor should also be incorporated into any user-defined widths in custom UIs, to ensure spacing remains correct as scaling is changed, like:</p> <pre><code>psim.PushItemWidth(100 * ps.get_ui_scale());\n</code></pre> <p>If <code>-1</code>, a sensible value will be guessed at initialization time. This value is saved and restored between settings if the preferences file is enabled.</p> <p>Default: <code>-1.</code></p>"},{"location":"basics/program_options/#build-gui","title":"build gui","text":"<p>This option can be used to disable all of Polyscope\u2019s ImGui UI elements, which may be useful for advanced applications which wish to build a fully-custom UI on top of Polyscope.</p> <p>If false, Polyscope will not create any ImGui UIs at all, but will still set up ImGui and invoke its render steps each frame. The allows advanced users to create their own UIs totally from scratch and circumvent the standard Polyscope UIs.</p> <p>Default: <code>True</code>.</p>"},{"location":"basics/program_options/#open-imgui-window-for-user-callback","title":"open imgui window for user callback","text":"<p>If true, an ImGui window will be created and docked to the side of the UI when the user callback function is invoked. This means you can immediately start making ui calls like <code>polyscope.imgui.Button(\"do stuff\")</code>. </p> <p>If false, no ImGui anything will be pushed on the stack when the callback is invoked, and the user is entirely responsible for making any ImGui calls (or not making any).</p> <p>Default: <code>True</code>.</p>"},{"location":"basics/program_options/#invoke-user-callback-for-nested-show","title":"invoke user callback for nested show","text":"<p>Suppose you call <code>polyscope.show()</code>, and within your callback, another instance of <code>polyscope.show()</code> is called\u2014this is a nested show.</p> <p>Depending on the situation, you might or might not want your user callback to continue being executed on each render loop iteration of this nested viewer; this setting exposes the option.</p> <p>If true, your callback will be executed as normal for every main loop iteration, even in nested show windows.</p> <p>If false, your callback will only be executed for initial, outermost calls to <code>polyscope.show()</code>.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/program_options/#give-focus-on-show","title":"give focus on show","text":"<p>If true, the Polyscope window will request focus from the window manager whenever <code>show()</code> is called. If false, the focus state will be left unchanged.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/scene_options/","title":"Scene Options","text":"<p>These are settings which affect the visual display of the scene.  It is often convenient to set them just before calling <code>polyscope.init()</code>, but they may generally be set anywhere.</p> <pre><code>import polyscope as ps\n\n# enable auto centering and scaling\nps.set_autocenter_structures(True)\nps.set_autoscale_structures(True)\n\n# initialize\nps.init()\n</code></pre> <code>set_autocenter_structures(b)</code> <code>set_autoscale_structures(b)</code>"},{"location":"basics/scene_options/#autocenter-structures","title":"autocenter structures","text":"<p>If true, all structures will have their transform set to center their bounding box immediately after being registered.</p> <p>This centers the content nicely in view, but obscures any important absolute world positions.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/scene_options/#autoscale-structures","title":"autoscale structures","text":"<p>If true, all structures will have their transform set to rescale their length to 1 immediately after being registered.</p> <p>This scales the content nicely in view, but obscures any important absolute world positions.</p> <p>Default: <code>False</code>.</p>"},{"location":"basics/scene_options/#extents","title":"Extents","text":"<p>By default, Polyscope computes a bounding box and length scale for the structures in the scene, and uses them to adjust the rendered view. For instance, the camera view is initially pointed at the center of the bounding box, and the length scale is used to set reasonable values for the radii of points, curves, and vectors.</p> <p>However, sometimes it important to fix these extents rather than automatically computing them from data. One such case is producing precisely consistent visualizations across many inputs which might have slightly different extents. Another is when outlier data makes the automatically-computed extents egregiously large. The settings below can be used to manually adjust these extents.</p> <p>These parameters can be adjust in the UI under <code>[View] --&gt; [Scene Extents]</code>.</p> <p>Example:  fix the length scale to the unit bounding box <pre><code>import polyscope as ps\n\nps.init()\nps.set_automatically_compute_scene_extents(False)\nps.set_length_scale(1.)\nlow = np.array((-1, -1., -1.)) \nhigh = np.array((1., 1., 1.))\nps.set_bounding_box(low, high)\n</code></pre></p> <code>get_length_scale()</code> <p>Get the current representative length scale for the scene. Returns a float.</p> <code>set_length_scale(s)</code> <p>Set a representative length scale for the scene. Takes a float.</p> <p>When Polyscope automatically computes this, most structures simply use the length of the diagonal of the bounding box.</p> <code>get_bounding_box()</code> <p>Get the current bounding box for the scene, in world coordinates. Returns a tuple of length-3 numpy vectors. The first and second elements of the tuple are the lower and upper corners of the bounding box, respectively.</p> <code>set_bounding_box(low, high)</code> <p>Set a bounding box for the scene, in world coordinates. Takes two length-3 numpy vectors, which are the lower and upper corners of the bounding box, respectively.</p> <code>set_automatically_compute_scene_extents(b)</code> <p>If true, the length scale and bounding box parameters will be automatically computed from the registered structures, and updated whenever a a structure is added or changed.</p> <p>If false, these parameters will be left unchanged.  If set to false before the first structure is registered, you are required to set the bounding box and length scale manually.</p> <p>Takes a boolean.  Default: <code>true</code>.</p>"},{"location":"basics/scene_options/#other-options","title":"Other Options","text":"<code>set_background_color(new_color)</code>"},{"location":"basics/scene_options/#background-color","title":"background color","text":"<p>Set the background color of the rendered scne.</p> <p>The input should be a 3-tuple RGB or a 4-tuple RGBA of floats, with values on on <code>[0,1]</code>.</p> <p>Default: <code>{1., 1., 1., 1.}</code>.</p>"},{"location":"common/color_quantity/","title":"Color quantity","text":""},{"location":"common/color_quantity/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"common/parameterization_quantity/","title":"Parameterization quantity","text":""},{"location":"common/parameterization_quantity/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>viz_style</code> option determines how parameterizations are visualized:</p> <ul> <li><code>checker</code>: a two-color checker pattern</li> <li><code>grid</code>: a two-color grid with thin lines</li> <li><code>local_check</code>: a checkerboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>local_rad</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul>"},{"location":"common/parameterization_quantity/#types","title":"Types","text":"<p>The <code>coords_type</code> options determines how parameter coordinates are interpreted for scaling:</p> <ul> <li><code>unit</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>world</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul>"},{"location":"common/parameterization_quantity/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>When adding a parameterization quantity, the following keyword options can be set. These are available for all kinds of parameterization quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>coords_type</code> string, one of <code>'unit'</code>, <code>'world'</code>  (see above)</li> <li><code>viz_style</code> string, one of <code>'checker'</code>, <code>'grid'</code>, <code>'local_check'</code>, <code>'local_rad'</code> (see above)</li> <li><code>grid_colors</code> 2-tuple of rgb colors, used to color the grid visualization</li> <li><code>checker_colors</code> 2-tuple of rgb colors, used to color the checkerboard visualization</li> <li><code>checker_size</code> float, the size of checkers/grid/stripes</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"common/scalar_quantity/","title":"Scalar quantity","text":""},{"location":"common/scalar_quantity/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"common/scalar_quantity/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"common/vector_quantity/","title":"Vector quantity","text":""},{"location":"common/vector_quantity/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> <li><code>material</code> string, shading material for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"features/2D_data/","title":"2D Data","text":"<p>Polyscope is primarily focused on 3D data, but can also be used for 2D visualization. This section descibes a few helpers which make it easier to do so.</p>"},{"location":"features/2D_data/#adding-2d-data","title":"Adding 2D data","text":"<p>Functions which accept 3D positions (or vectors) as input can alternately takes 2D positions, and append a 0 z-coordinate.  In Python (unlike the C++ api), we can use 2D data by simply passing it as the argument of a function which would otherwise take 3D data. For instance, <code>register_point_cloud(name, data)</code> normally expects <code>data</code> to be a <code>Nx3</code> array of 3D positions, but passing an <code>Nx2</code> array also works just fine.  Any other functions which don\u2019t take 3D positions can be used as normal, like <code>add_scalar_quantity()</code>.</p>"},{"location":"features/2D_data/#planar-camera-mode","title":"Planar camera mode","text":"<p>The Polyscope camera can be \u201clocked-in\u201d to a 2D view by setting the mode to <code>Planar</code>. In the UI, this option is in the main Polyscope window, set to <code>Turntable</code> by default. Setting the camera mode to <code>Planar</code> will also hide the ground plane.</p> <p></p> <p>To set this option programmatically, use: <pre><code>ps.set_navigation_style(\"planar\")\n</code></pre></p>"},{"location":"features/color_maps/","title":"Color Maps","text":""},{"location":"features/color_maps/#built-in-color-maps","title":"Built-in color maps","text":"<p>Different color maps are appropriate for different situations:</p> <ul> <li>sequential maps data in to a linear range (when it doesn\u2019t fall in to one of the more specific categories below).</li> <li>diverging maps data in to a linear range, where the center value is \u201cneutral\u201d and the endpoints of the range are opposite and symmetric. Examples include a rate of change, or a residual; in both cases <code>0</code> semantially means \u201cnothing\u201d, and the endpoints have opposite meaning.</li> <li>cyclic maps data defined on the circle, like an angle</li> <li>decorative maps should generally not be used to encode numerical data, but may be useful for other visualization purposes</li> </ul> <p>Polyscope supports the following built-in color maps:</p> Name Type String Key viridis sequential <code>viridis</code> blues sequential <code>blues</code> reds sequential <code>reds</code> coolwarm diverging <code>coolwarm</code> pink-green diverging <code>pink-green</code> phase cyclic <code>phase</code> spectral decorative <code>spectral</code> rainbow decorative <code>rainbow</code> jet decorative <code>jet</code> turbo decorative <code>turbo</code>"},{"location":"features/color_maps/#loading-custom-color-maps","title":"Loading custom color maps","text":"<p>Custom colormaps can be loaded at runtime from image files and used anywhere colormaps are used. Loading can be performed with the UI from <code>[Appearance] --&gt; [Color maps] --&gt; [Load color map]</code>, or programatically using the function below. The input should be a horizontally-oriented image file like the one below; the centermost row of pixels will be read to generate the color map. Most common image formats are accepted (anyting <code>stb_image</code> can read).</p> <p></p> <code>load_color_map(cmap_name, filename)</code> <ol> <li> <p>Viridis is by Nathaniel J. Smith, Stefan van der Walt, and Eric Firing. link \u21a9</p> </li> <li> <p>Phase is from the <code>cmocean</code> package. link \u21a9</p> </li> <li> <p>Turbo is by Anton Mikhailov and others at Google. link \u21a9</p> </li> <li> <p>The other color maps have unclear origins or are simple linear ramps, and are implemented in matplotlib.\u00a0\u21a9</p> </li> </ol>"},{"location":"features/color_maps/#load_color_map","title":"load_color_map","text":"<p>Load a new colormap from the image file <code>filename</code>, which will be assigned the name <code>cmap_name</code>.</p> <p>Example: <pre><code>import polyscope as ps\n\nps.load_color_map(\"fancy cmap\", \"my_cmap.png\")\n</code></pre></p>"},{"location":"features/ground_and_shadows/","title":"Ground and Shadows","text":"<p>The Polyscope scene view includes a ground plane which optionally supports reflection and soft-shadow effects. This section outlines the various modes and options available for the ground plane.</p> <p></p>"},{"location":"features/ground_and_shadows/#ground-plane-and-shadow-modes","title":"Ground plane and shadow modes","text":"<ul> <li><code>none</code> no ground plane, nor reflection/shadows are shown</li> <li><code>tile</code> a tiled ground plane </li> <li><code>tile_reflection</code> a tiled ground plane with a reflection of the scene (default)</li> <li><code>shadow_only</code> a transparent ground plane with a soft vertical shadow of the scene</li> </ul> <p>The ground plane and shadow settings can also be manually adjusted in the GUI under the <code>[Appearance] --&gt; [Ground Plane]</code> menu. The ground plane does not support all transparency modes: with simple transparency it is disabled, and pretty transparency there are no reflections or shadows.</p> <p>Example: adjust the ground plane &amp; shadow appearance</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# set the ground height to a fixed location manually\nps.set_ground_height(0.) # in world coordinates\n\n# set soft shadows on the ground\nps.set_ground_plane_mode(\"shadow_only\")  # set +Z as up direction\nps.set_shadow_darkness(0.1)              # lighter shadows\n\n\n# ... load your mesh, point cloud, etc ...\n\n# take screenshot from the current camera view, which will have transparent shadows\nps.screenshot(\"test_image.png\", True);\n\n# open the GUI\nps.show(3)\n</code></pre> <code>set_ground_plane_mode(mode_str)</code> <p>Set the mode used for the ground plane, as described above. Should be one of <code>none</code>, <code>tile</code>, <code>tile_reflection</code>, or <code>shadow_only</code>.</p> <p>Default: <code>tile_reflection</code>.</p> <p>Some more details: the ground plane is automatically faded away whenever the scene is viewed from underneath the ground, and also faded away in the distance far from the scene, as determined by the scene bounding box. Shadows are properly transparent, exporting a screenshot with transparency will set <code>alpha = shadow_darkness</code> values for shadowed areas, and set <code>alpha=0</code> for unshadowed parts of the ground plane.</p> <p>The <code>shadow_blur_iters</code> and <code>shadow_darkness</code> parameters below adjust the visual appearance of soft shadows for the ground plane mode <code>shadow_only</code>.</p> <code>set_shadow_blur_iters(i)</code> <p>The number of blur iterations used to blur soft shadows. Increase to make the shadows more fuzzy.</p> <p>Default: <code>2</code>. </p> <code>set_shadow_darkness(val)</code> <p>How dark the shadows are. <code>0</code> is totally transparent (white), and <code>1</code> is fully black. When taking screenshots with transparency, these will become alpha transparency values for the shadowed regions.</p> <p>Default: <code>.25</code>. </p>"},{"location":"features/ground_and_shadows/#ground-plane-positioning","title":"Ground plane positioning","text":"<p>The orientation of the ground plane is determined by the up direction for the scene, which can be set along any of the coordinate directions such as <code>+X</code>, <code>-Z</code>, etc.</p> <p>By default, the height of the ground plane is set automatically to the bottom of the bounding box for the scene content (and can optionally be relatively offset via <code>set_ground_plane_height_factor()</code>).</p> <p>Alternately, the height can be specified to a fixed location in world coordinates like: <pre><code>ps.set_ground_height(0.) # in world coordinates along the up axis\n</code></pre></p> <code>set_ground_plane_height(x)</code> <p>Set the location of the ground plane, in world coordinates.</p> <p>Calling this function also implicitly sets <code>set_ground_plane_height_mode('manual')</code></p> <p>Default: <code>0</code>. </p> <code>set_ground_plane_height_factor(x, is_relative=True)</code> <p>The offset of the ground plane from the bottom of the bounding box for the scene. Use postive/negative values to shift the ground plane up/down.</p> <p>Calling this function also implicitly sets <code>set_ground_plane_height_mode('automatic')</code></p> <p>This parameter is a scaled value. By default, values will be interpreted relative to the scene length scale, whereas calling <code>set_ground_plane_height_factor(0.1, is_relative=False)</code> will specify a value in absolute units.</p> <p>Default: <code>0</code>. </p> <code>set_ground_plane_height_mode(mode_str)</code> <p>Set which policy is used to determine the ground plane height.</p> <ul> <li><code>automatic</code> anchored to the bottom of the scene bounding box, optionally offset by <code>set_ground_plane_height_factor()</code></li> <li><code>manual</code> in absolute world coordinates, at the location <code>set_ground_height()</code></li> </ul> <p>Default: <code>automatic</code>.</p>"},{"location":"features/groups/","title":"Groups","text":"<p>To manage large numbers of structures, or manage structures which are related to each other, you can gather them in groups. A group is a collection of structures which can be enabled/disabled together and hidden from the UI if needed. A structure can be in 0, 1, or many groups. Groups can also hold other groups, allowing nested organization.</p>    Your browser does not support the video tag.  <p>Example: Basic usage of groups</p> <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# make a point cloud\npts = np.zeros((300,3))\npsCloud = ps.register_point_cloud(\"my cloud\", pts)\n\n# make a curve network\nnodes = np.zeros((4,3))\nedges = np.array([ [1, 3], [3, 0], [1, 0], [0, 2] ])\npsCurve = ps.register_curve_network(\"my network\", nodes, edges)\n\n# create a group for these two objects\ngroup = ps.create_group(\"my group\")\npsCurve.add_to_group(group) # you also say psCurve.add_to_group(\"my group\")\npsCloud.add_to_group(group)\n\n# toggle the enabled state for everything in the group\ngroup.set_enabled(False)\n\n# hide items in group from displaying in the UI\n# (useful if you are registering huge numbers of structures you don't always need to see)\ngroup.set_hide_descendants_from_structure_lists(True)\ngroup.set_show_child_details(False)\n\n# nest groups inside of other groups\nsuper_group = ps.create_group(\"py parent group\")\nsuper_group.add_child_group(group)\n\nps.show(3)\n</code></pre>"},{"location":"features/groups/#create-get-and-remove-groups","title":"Create, get, and remove groups","text":"<code>create_group(name)</code> <code>get_group(name)</code> <code>remove_group(group, error_if_absent=true)</code> <code>removeAllGroups()</code>"},{"location":"features/groups/#create-group","title":"create group","text":"<p>Create a new group and return it. Group name must be a unique string (no other group may have that name).</p> <p>Returns the new group object.</p>"},{"location":"features/groups/#get-group","title":"get group","text":"<p>Get an existing group by name. </p> <p>Returns the group object.</p>"},{"location":"features/groups/#remove-group","title":"remove group","text":"<p>Remove an existing group. </p> <p>The <code>group</code> argument can be either a group object or a group name string.</p>"},{"location":"features/groups/#remove-all-groups","title":"remove all groups","text":"<p>Removes all existing groups.</p>"},{"location":"features/groups/#group-membership","title":"Group membership","text":"<code>Structure.add_to_group(group)</code> <code>Group.add_child_structure(newChild)</code> <code>Group.remove_child_structure(child)</code> <code>Group.add_child_group(newChild)</code> <code>Group.remove_child_group(child)</code>"},{"location":"features/groups/#add-structure-to-group","title":"add structure to group","text":"<p>Add a structure as a member of a group.</p> <p>The <code>group</code> argument can be either a group object or a group name string.</p> <p>Note that this is a member function of a structure object, like <code>pointCloud.add_to_group(group)</code>.</p>"},{"location":"features/groups/#add-child-structure","title":"add child structure","text":"<p>Add a structure as a member of this group</p>"},{"location":"features/groups/#remove-child-structure","title":"remove child structure","text":"<p>Remove a structure as a member of this group</p>"},{"location":"features/groups/#add-child-group","title":"add child group","text":"<p>Add a group as a (nested) member of this group</p> <p>The <code>group</code> argument can be either a group object or a group name string.</p>"},{"location":"features/groups/#remove-child-group","title":"remove child group","text":"<p>Remove a group as a (nested) member of this group</p> <p>The <code>group</code> argument can be either a group object or a group name string.</p>"},{"location":"features/groups/#iterate-over-children-in-a-group","title":"Iterate over children in a group","text":"<code>Group.get_child_structure_names()</code> <code>Group.get_child_group_names()</code>"},{"location":"features/groups/#get-child-structure-names","title":"get child structure names","text":"<p>Get a list of the string names of all structures contained in the group.</p> <p>Only returns top-level children, does not recurse into sub-groups.</p> <p>You can get the underlying structures like <code>get_surface_mesh(structure_name)</code>, etc, and process as desired.</p>"},{"location":"features/groups/#get-child-group-names","title":"get child group names","text":"<p>Get a list of the group names of all nested groups contained in the group.</p> <p>Only returns top-level children, does not recurse into sub-groups.</p> <p>You can get the underlying groups like <code>get_group(group_name)</code>, etc, and process as desired.</p>"},{"location":"features/groups/#group-settings","title":"Group settings","text":"<code>Group.set_enabled(newVal)</code> <code>Group.set_show_child_details(newVal)</code> <code>Group.set_hide_descendants_from_structure_lists(newVal)</code>"},{"location":"features/groups/#set-enabled","title":"set enabled","text":"<p>Set all descendants of a group to be enabled or disabled (applies to direct members of a group, as well as recursively to all members-of-members for nested groups).</p> <p>The <code>newVal</code> argument is a bool.</p>"},{"location":"features/groups/#show-ui-details","title":"show UI details","text":"<p>If true, the Groups section of the ImGui UI panel will show each childs structure info as a submenu under the group. If false, only the group name and toggle checkbox will be shown.</p> <p>The <code>newVal</code> argument is a bool.</p> <p>(Default: true)</p>"},{"location":"features/groups/#hide-from-structure-list","title":"hide from structure list","text":"<p>If true, the structures which are members of this group (or descendants in any nested groups) will be hidden from the ImGui UI panel structure list.</p> <p>The <code>newVal</code> argument is a bool.</p> <p>(Default: false)</p>"},{"location":"features/headless_rendering/","title":"Headless Rendering","text":"<p>Polyscope supports headless rendering on linux machines which do not have displays, such as remote servers and clusters.</p> <p>Polyscope\u2019s default interactive backend uses GLFW to create an OpenGL context, which essentially requires that a physical display be attached for any rendering to be performed. This would prevent workflows like running compute jobs on remote clusters and logging images or saving videos rendered via Polyscope\u2014headless rendering offers a solution.</p> <p>What is headless rendering not?</p> <p>\u201cHeadless\u201d just means that Polyscope can run its rendering engine even when no display is present, rendering images to buffers or files. You can save them, store them, or even log them to viewers like Tensorboard.</p> <p>Headless rendering is not the same as running the UI in a browser tab or a cell of a Jupyter notebook.  There is currently no support for either of these uses (although local Jupyter notebooks work; the window will be opened outside of the notebook).</p> <p>Also, headless rendering is not necessary if you are remotely connecting to a machine which has a physical display attached; for instance, when remotely connecting to macOS or Windows machines with displays.</p> <p>Unix only</p> <p>Headless rendering is only supported on Unix/Linux, because EGL is only available there.</p>"},{"location":"features/headless_rendering/#using-headless-rendering","title":"Using headless rendering","text":"<p>Headless rendering requires compiling with and initializing a separate EGL backend.  </p> <p>Fortunately, the linux Polyscope wheels published on <code>pip</code> are already built with support for EGL.</p> <p>Your system must also have EGL available at runtime. It is likely packaged with graphics drivers, or can be installed from a package manager. Another alternative is to fall back on (much slower!) software rendering by installing <code>OSMesa</code> from your package manager.</p> For developers: compiling with EGL support <p>If you are manually compiling Polyscope\u2019s python bindings, you must ensure EGL support is enabled. The default CMake settings enable it only if you are on Linux and EGL headers seem to be present on your system.</p> <p>Set the CMake variable <code>POLYSCOPE_BACKEND_OPENGL3_EGL=ON</code> to force-enable building with EGL support. </p> <pre><code>cmake .. -DPOLYSCOPE_BACKEND_OPENGL3_EGL=ON\n</code></pre> <p>At runtime, you must tell Polyscope to initialize with the EGL engine. The simplest way to do this is to specify it explicitly when you call <code>init()</code>. Alternately, the default automatic initialization scheme will select the EGL headless backend if no others are available, but only if you enable the headless backends option first.</p> <p>Example: headless usage <pre><code>import polyscope as ps\n\n# explicit initialization\nps.init(\"openGL3_egl\")\n# OR\nps.set_allow_headless_backends(True)  # enable headless backends\nps.init() # automatic initialization will use the EGL backend\n          # if it is available and there is no display\n\n# ... add structures and quantities to polyscope as usual ...\n\n# save screenshots, render movies, etc\nps.screenshot()                     # saves to file\nviz_img = ps.screenshot_to_buffer() # returns an image array\n</code></pre></p> <p>Once you have initialized the backend and added your data as usual, you can preform rendering operations such as saving rendered screenshots to disk or to buffer.</p> <p>Unless you really know what you are doing, you probably do not want to call <code>show()</code> \u2013 by default this would initiate a render loop which spins endlessly with no effect. However it is still permitted to do so, e.g. if you set a user callback which has side effects.</p> <p>ImGui not rendered</p> <p>In headless mode, the ImGui UI is not actually drawn to the screen. You can still issue ImGui calls in your code if you would like, but they will never have any effect.</p>"},{"location":"features/headless_rendering/#options","title":"Options","text":"<code>is_headless()</code> <code>set_allow_headless_backends(b)</code> <code>set_egl_device_index(i)</code>"},{"location":"features/headless_rendering/#is_headless","title":"is_headless()","text":"<p>Returns <code>True</code> if polyscope is currently running in headless mode. May only be called after initialization.</p>"},{"location":"features/headless_rendering/#set_allow_headless_backends","title":"set_allow_headless_backends","text":"<p>If <code>True</code> default automatic initialization is allowed to initialize with a headless backend, if that is the only option.</p> <p>Default: <code>False</code></p> <p>This is set to <code>false</code> by default, because sometimes misconfigured or low-capability machines will have no display, and automatically creating headless backends on such machines would confuse new users.</p>"},{"location":"features/headless_rendering/#set_egl_device_index","title":"set_egl_device_index()","text":"<p>Pass an index to manually specify which EGL device to use for headless EGL rendering. If set to <code>-1</code> (default), Polyscope will try all devices, with some heuristics to attempt to use hardware renderers before software renderers.</p> <p>Default: <code>-1</code></p> <p>If you are trying to figure out which device index to use, set Polyscope\u2019s verbosity to a large value (<code>&gt; 5</code>). At high verbosity, Polyscope will print the list of found EGL devices and their indices when attempting initialization.</p>"},{"location":"features/implicit_helpers/","title":"Implicit Helpers","text":"<p>Implicit functions take an xyz position as input, and return a value. Polyscope contains several helper features to directly visualize implicit functions by taking a callable as input and automatically invoking it as needed. This can be a much easier way to interface with volumetric and inherently implicit data. In particular, Polyscope contains a built-in renderer to render images of levelsets of implicit functions.</p> <p>Batch Evaluation</p> <p>In principle, an implicit function takes a single xyz position as input, and returns a single value. However, Polyscope might need to invoke the callback function millions of times, which can introduce excessive performance overhead, especially if the underlying function is being evaluated on a GPU, or due to cross-language binding overhead. For this reason, we use batch evaluation, to perform many evaluations with each invocation and amortize the overhead.</p> <p>Implict helpers expect you to pass a callback function which takes as input an <code>(N,3)</code> numpy array of query positions, and returns an <code>(N,)</code> array of evaluated values (or returns <code>(N,3)</code> array of colors for color functions). <code>N</code> is the number of queries, which will be determined as-needed internally by Polyscope.</p>"},{"location":"features/implicit_helpers/#directly-rendering-implicit-isosurfaces","title":"Directly Rendering Implicit Isosurfaces","text":"<p>Polyscope can directly render images of an isosurface of an implicit function in space, from the current viewport or from a defined camera view. The resulting renders are added as Render Images, which support material shading, colormapping, transparency, and depth-compositing with other content in the scene.</p> <p></p> <p>Not a Fast Renderer</p> <p>There is a long history of highly efficient real-time implicit shaders and ray marchers in computer graphics. Polyscope\u2019s built-in implicit ray marching renderer is not fast, and it never will be! It should be viewed as a debugging tool, not a real-time renderer. Its design fundamentally prioritizes ease-of-use over speed; for instance even if your function is defined on the GPU, Polyscope will perform many expensive CPU round-trips to render it, doing multiple evaluations of the given implicit function.</p> <p>If you want real-time implicit rendering, you will need to perform that rendering outside of Polyscope. However, the resulting renders can still be added to Polyscope as a Render Image to take advantage of Polyscope\u2019s functionality. You can even use direct GPU interop (beta feature!) to do so with minimal realtime overhead.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# define some implicit functions\ndef sphere_sdf(pts): # takes [N,3] query pos array, returns [N,] SDF values\n    res = np.linalg.norm(pts, axis=-1) - 1.\n    return res\ndef color_func(pts): # takes [N,3] query pos array, returns [N,3] color values\n    A = np.ones_like(pts) * 0.3\n    A[:,0] = np.cos(3*pts[:,0])**2\n    return A\n\n# render from the current view\nps.render_implicit_surface(\"sphere sdf\", sphere_sdf, \n                           mode='sphere_march', enabled=True)\nps.render_implicit_surface_color(\"sphere sdf\", sphere_sdf, color_func, \n                                 mode='sphere_march', enabled=True)\n\nps.show()\n</code></pre></p>"},{"location":"features/implicit_helpers/#implicit-render-options","title":"Implicit Render Options","text":"<p>The most important option to set the <code>mode</code> for the renderer. There are two choices:</p> <ul> <li><code>mode='sphere_march'</code> should be used if your implicit function is a Signed Distance Function (SDF). That is, its magnitude gives the distance to the surface, or at least a conservative bound on the distance. This allows the renderer to take large steps based on the SDF value.</li> <li><code>mdoe='fixed_step</code> must be used if your implicit function is not necessarily an SDF. This forces to renderer to take many small steps, which is inefficient but always works for sufficiently small step size.</li> </ul> <p>The following options can be set as additional keywords arguments to any render function</p> <ul> <li><code>camera_view</code> a <code>CameraView</code> structure (or the string name of one). If given, the render will be performed from the viewpoint of that camera, and the resulting render image will be added to the camera</li> <li><code>camera_parameters</code> a <code>CameraParameters</code> object defining the view to render from. If is not passed, then the current viewport will be used, unless the <code>camera_view</code> arg is set, in which case that camera will be used instead</li> <li><code>dim</code> 2-tuple of ints giving the dimension to render at (if rendering from the current view, this may be omitted, and the viewport resolution will be used)</li> <li><code>subsample_factor</code> int, if <code>dim</code> is being set automatically, downscale it by this factor (e.g. <code>subsample_factor=2</code> means use <code>dimX/2</code> and <code>dimY/2</code>)</li> <li><code>miss_dist</code> float, an absolute value for how far a ray must go to be considered a miss</li> <li><code>miss_dist_relative</code> float, a relative value for how far a ray must go to be considered a miss (default: 20.)</li> <li><code>hit_dist</code> float, an absolute value for how close a ray must go to be considered a hit</li> <li><code>hit_dist_relative</code> float, a relative value for how close a ray must go to be considered a hit (default: 1e-4)</li> <li><code>step_factor</code> float, a small tolerance factor applied to step sizes (default: 0.99)</li> <li><code>normal_sample_eps</code> float, a relative numerical parameter for finite differences normals (default: 1e-3)</li> <li><code>step_size</code> float, the absolute step size to used for <code>fixed_step</code> marching</li> <li><code>step_size_relative</code> float, the relative step size to used for <code>fixed_step</code> marching (default: 1e-2)</li> <li><code>n_max_steps</code> int, the maximum number of steps to take (default: 1024)</li> </ul> <p>For options which have an absolute and relative version, you may specify either but not both. Relative values are defined with respect to the scene length scale.</p>"},{"location":"features/implicit_helpers/#render-depth-images","title":"Render Depth Images","text":"<p>Render a depth Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting.</p> <code>render_implicit_surface(name, func, mode, color=None, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-scalar-images","title":"Render Scalar Images","text":"<p>Render a scalar Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting. An additional implicit function defines a scalar value which will be shaded with colormapping on the isosurface.</p> <code>render_implicit_surface_scalar(name, func, func_scalar, mode, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>func_scalar</code> another batch callable defining a scalar function which will be evaluated on the isosurface and displayed with color mapping</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-color-images","title":"Render Color Images","text":"<p>Render a color Render Image of the 0 isosurface of a function. The resulting surface will be shaded with materials and lighting. An additional implicit function defines a color value which will be shaded with colormapping on the isosurface.</p> <code>render_implicit_surface_color(name, func, func_color, mode, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>func_color</code> another batch callable defining a color function which will be evaluated on the isosurface and displayed with color mapping</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#render-raw-color-images","title":"Render Raw Color Images","text":"<p>Render a raw color Render Image of the 0 isosurface of a function. An additional implicit function defines a color value which will be used on the isosurface. The difference between color and raw color images is that plain <code>Color</code> rendered images apply lighting and material shading to the colors (like a <code>SurfaceMesh</code> would), whereas <code>RawColor</code> images really just directly display the given color as the pixel values.</p> <code>render_implicit_surface_raw_color(name, func, func_color, mode, **kwargs)</code> <ul> <li><code>func</code> a batch callable defining the function whose 0-levelset we will render</li> <li><code>func_color</code> another batch callable defining a color function which will be evaluated on the isosurface</li> <li><code>mode</code> is the render mode, one of <code>'sphere_march', 'fixed_step'</code></li> <li>see the bulleted listing above for other arguments common to all render functions</li> </ul> <p>The 0 isolevel is always used. To render a different isolevel, add a constant offset shift to your function before passing it in.</p> <p>See the \u201cBatch Evaluation\u201d popout at the top for a description of the expected signatures for function arguments.</p>"},{"location":"features/implicit_helpers/#implicit-volumes","title":"Implicit Volumes","text":"<p>In addition rendering isosurfaces, Polyscope can automatically register the implicit function as a volumetric grid of values. See the volume grid scalar quantity for details.</p>"},{"location":"features/materials/","title":"Materials","text":"<p>Polyscope uses matcaps to render the appearance of objects in the scene, as opposed to more traditional configurations of lights and shading models, etc. A matcap is a small image of a material, which is sampled by the renderer to query the materials\u2019 appearance from a some angle. Scene information like lighting is implicitly baked in to the matcap image.</p> <p>Most objects in Polyscope (surface meshes, point clouds, vectors, etc) expose a <code>material='matname'</code> option to choose a material for the object\u2019s appearance. Additionally, materials can generally be set in the UI from <code>[Options] --&gt; [Material]</code>.</p>"},{"location":"features/materials/#blended-materials","title":"Blended materials","text":"<p>In Polyscope, we often want to adjust set custom colors for rendered objects. This can be a constant color for the object (to distinguish structures in a scene), or a varying color across a surface (when color-mapping scalar quantities).  Traditionally, matcaps don\u2019t really support setting an albedo color like this, but we achieve the effect in Polyscope by blending between basis matcaps.</p> How it works <p>Instead of just using a single material image, we take four images of the material, representing basis red, green, blue, and black components.</p> <p> </p> <p>At runtime, to generate a color from a triple of <code>rgb</code> values each in the range <code>[0,1]</code>, we sample the images like:</p> <pre><code>outputColor = r * basis_r + g * basis_g + b * basis_b + (1. - r - g - b) * basis_k\n</code></pre> <p>Intuitively, this strategy presumes the underlying material has a light response which is a linear function of the color, plus another component which is independent of the color.  Crucially, Polyscope uses a linear lighting workflow and performs this blending on linear matcaps before tone-mapping, which is necessary for the results to look reasonable across the full color space.</p> <p>Materials which which support this blending are denoted by <code>(rgb)</code> in the options menu.  Ordinary static matcaps consisting of a single image can still be used as materials, but will ignore any color maps or other options.</p>"},{"location":"features/materials/#preserving-colors-with-the-flat-material","title":"Preserving colors with the flat material","text":"<p>Generally, Polyscope applies material shading and tone-mapping to render 3D content. However, this means that data such as colors and tonemapped scalars will be a somewhat different color on-screen compared to what is in the data.</p> <p>The <code>flat</code> material is special: it not only applies flat coloring with no shading effects, but furthermore cancels-out tonemapping and other effects to ensure that the color you see onscreen is exactly the same as the data specified.</p> <p>Use the <code>flat</code> material any time you need exact color reproduction.</p>"},{"location":"features/materials/#built-in-materials","title":"Built-in materials","text":"<p>Polyscope supports the following built-in materials:</p> Name String Key Blendable Image clay <code>clay</code> yes wax <code>wax</code> yes candy <code>candy</code> yes flat <code>flat</code> yes mud1 <code>mud</code> no ceramic1 <code>ceramic</code> no jade1 <code>jade</code> no normal1 <code>normal</code> no"},{"location":"features/materials/#loading-custom-materials","title":"Loading custom materials","text":"<p>Custom matcaps can be loaded at runtime from image files and used anywhere materials are used. Loading can be performed with the UI from <code>[Appearance] --&gt; [Materials] --&gt; [Load material]</code>, or programatically using the function below. For blendable matcaps, if the single filename <code>mat.hdr</code> is given, Polyscope will try to load <code>mat_r.hdr</code>, <code>mat_g.hdr</code>, etc.</p> <p>Ideally, matcap images should be linear <code>.hdr</code> images for best results, but any image will work. If other image formats are given, the input is assumed to be non-linear and will be inverse-tonemapped with <code>intensity=1</code> and <code>gamma=2.2</code> before use.  Most common image formats are accepted (anything <code>stb_image</code> can read).</p> <code>load_static_material(mat_name, filename)</code> <code>load_blendable_material(mat_name, filenames=None, filename_base=None, filename_ext=None)</code> <ol> <li> <p>The matcaps are from the Blender matcap repository, available under a CC0/public domain license. Thanks to the Blender community for contributing them!\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"features/materials/#load_static_material","title":"load_static_material","text":"<p>Load a new static (non-blendable) material from a single image file <code>filename</code>. The new material will be called <code>mat_nam</code>.</p> <p>Example: <pre><code>import polyscope as ps\n\nps.load_static_material(\"fancy mat\", \"my_image.png\")\n</code></pre></p>"},{"location":"features/materials/#load_blendable_material","title":"load_blendable_material","text":"<p>Load a new blendable material, which will be called <code>matName</code>.</p> <p>There are two different ways to specify which files to load the material images from:</p> <ul> <li>Specify <code>filenames</code>, a tuple of four string filenames corresponding to red, green, blue, and black basis materials</li> <li>Specify <code>filename_base</code>, and <code>filename_ext</code>, to generate the four filenames as <code>filename_base + \"_r\" + filename_ext</code>, etc.</li> </ul> <p>Example: <pre><code>import polyscope as ps\n\nps.load_blendable_material(\"fancy blendable mat\", filenames = (\n                            \"my_image_r.png\",\n                            \"my_image_g.png\",\n                            \"my_image_b.png\",\n                            \"my_image_k.png\"\n                          ))\n\n# OR\n\nps.load_blendable_material(\"fancy blendable mat\", filename_base=\"my_image\", filename_ext=\".png\")\n</code></pre></p>"},{"location":"features/messages/","title":"Messages","text":""},{"location":"features/messages/#using-messages","title":"Using messages","text":"<p>We\u2019ve all been there: a crucial error message gets printed to the terminal, but lost in a tempest of text\u2014noticing that error message could have saved two hours of debugging.  Polyscope contains a simple system for showing message dialogs in the UI which are sure to be noticed but stay out of the way.</p> <p>There are a few levels of messages available:</p> <ul> <li>error A very bad error; immediately shows and blocks the UI for user response.</li> <li>warning A medium priorty warning, shown the next time UI main loop executes. Warnings of the same type can be batched together, so these messages can be issued in a dense loop without drowning the program.</li> <li>info A low-priority message, which is just printed to <code>stdout</code>.</li> </ul> <p>Messages can be dismissed by clicking the button in dialog box, or pressing <code>[space]</code>.</p> <p></p> <p>Example: <pre><code>import polyscope as ps\nps.init()\n\n# Generate a single warning.\n# Has no effect on the GUI until polyscope gets control flow\n# back, which happens here in the show() call below.\nps.warning(\"Something went slightly wrong\")\n\n# Generate a lot of warnings. Becase all of these warnings \n# have the same base message (the first string), they will \n# be batched together and only shown as one dialog. The detail \n# message for the first such warning will also be shown.\nfor i in range(5000):\n  ps.warning(\"Some problems come in groups\", \"some details: \" + str(i))\n\n# The previous warnings would be displayed here\nps.show()\n\n# Generating an error.\n# The UI will block and show this error immediately. After \n# the error is dismissed, the call will return.\nps.error(\"Resistance is futile.\");\n\n# Disable the in-window popups, just print to stdout\nps.set_display_message_popups(False)\n</code></pre></p>"},{"location":"features/messages/#messages","title":"Messages","text":"<code>info(message)</code> <code>warning(message, detail=\"\")</code> <code>error(message)</code>"},{"location":"features/messages/#info","title":"info","text":"<p>Simply logs a message to <code>stdout</code>.</p>"},{"location":"features/messages/#warning","title":"warning","text":"<p>Create a warning message, to be displayed the next time the UI gets flow control. </p> <p>When issuing a one-off warning, the <code>detail</code> field need not be used.  However, if issuing warnings in a loop, warnings with the same base <code>message</code> are batched together, so the UI doesn\u2019t get completely overwhelmed (see example above).</p>"},{"location":"features/messages/#error","title":"error","text":"<p>Generate an error, which is immediately shown in the GUI. After the error dialog is dismissed in the GUI, this function returns.</p>"},{"location":"features/messages/#options","title":"Options","text":"<code>set_display_message_popups(b)</code>"},{"location":"features/messages/#display-message-popups","title":"display message popups","text":"<p>If <code>True</code>, warning and error popup dialogs are shown in the UI and printed to stdout. If <code>False</code>, they are only printed to stdout (assuming <code>verbosity &gt; 0</code>).</p> <p>Default: <code>True</code></p>"},{"location":"features/screenshots/","title":"Screenshots","text":"<p>Polyscope includes simple functionality for saving screenshots from the current camera view to disk. The ImGUI interface windows will be automatically hidden when taking a screenshot.</p> <p>Screenshots can be taken manually by pressing the <code>[screenshot]</code> button in the options GUI window, or programmatically using the functions below. Clicking the GUI button generates a numbered screenshot file in the current directory; the arrow to the side of the button can be used to adjust file format and transparency settings for these screenshots.</p> <p>It is not necessary to call <code>show()</code> before taking screenshots. You can set up you scene and programmatically configure the camera view, then call <code>screenshot()</code> to save a rendered image to disk, all without any user interaction.</p> <p>Example: Register a mesh, position the camera, and take a screenshot <pre><code>import polyscope as ps\n\n# Initialize\nps.init()\n\n# Register a mesh\nverts = # ... your data ...\nfaces = # ... your data ...\nps_mesh = ps.register_surface_mesh(\"my mesh\", verts, faces)\n\n# Position the camera\nps.look_at((0., 0., 5.), (1., 1., 1.))\n\n# Adjust some screenshot default settings if you'd like\nps.set_screenshot_extension(\".jpg\");\n\n# Take a screenshot\n# It will be written to your current directory as screenshot_000000.jpg, etc\nps.screenshot()\n\n# Get the screenshot image as a numpy array\nimg = ps.screenshot_to_buffer()\n</code></pre></p> <p>include_UI may not match</p> <p>The screenshot <code>include_UI=True</code> setting is imperfect, the UI will be visible, but may be in a different state compared to what you see in your own window. This is a known bug, and we hope to fix it in future version.</p> <code>screenshot(filename=None, transparent_bg=True, include_UI=False)</code> <p>Saves a screenshot to the path given as <code>filename</code>, with format inferred from the file extension. </p> <p>The extension should be one of <code>.png</code>, or <code>.jpg</code>.</p> <p>If no name is is given, screenshots are saved to the current directory, with file named like <code>screenshot_000000.png</code> numbered automatically in increasing order. The numbering is reset to <code>0</code> for each run of the program; existing files will be silently overwritten.</p> <p>If <code>transparent_bg</code> is <code>true</code>, the background will be rendered as transparent, and set as transparency alpha in the saved image if the file format supports it.</p> <p>If <code>include_UI</code> is true, the screenshot with be captured with the ImGui UI (panels, buttons, etc) visible (default: <code>False</code>).</p> <code>set_screenshot_extension(ext)</code> <code>screenshot_to_buffer(transparent_bg=True, vertical_flip=True, include_UI=False)</code>"},{"location":"features/screenshots/#screenshot-extension","title":"screenshot extension","text":"<p>Set the extension used when taking automatically-numbered screenshots, either with <code>screenshot()</code> or by clicking the GUI button.</p> <p>The extension should be <code>.png</code>, or <code>.jpg</code>.</p>"},{"location":"features/screenshots/#screenshot-to-buffer","title":"screenshot to buffer","text":"<p>Take a screenshot of the current view and return it as a numpy array of (h,w,4).</p> <p>See <code>screenshot()</code> for the meaning of most arguments.</p> <p>The openGL buffer layout is vertically-flipped from the usual image convention in Python. The if <code>vertical_flip=True</code>, the buffer is flipped vertically before returning to match the usual convention.</p>"},{"location":"features/slice_planes/","title":"Slice Planes","text":"<p>Geometric data often has complex internal structures. Slice planes can be added to the scene to cull away parts of an object and inspect its interior. These planes can be manipulated either programmatically or manually in the GUI.</p>    Your browser does not support the video tag.  <p>Example: sweep a slice plane through the scene to produce the animation above</p> <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# Read &amp; register the mesh\nvertices = # your vertices\nfaces = # your faces\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# Add a slice plane\nps_plane = ps.add_scene_slice_plane()\nps_plane.set_draw_plane(True) # render the semi-transparent gridded plane\nps_plane.set_draw_widget(True)\n\n# Animate the plane sliding along the scene\nfor t in np.linspace(0., 2*np.pi, 120):\n    pos = np.cos(t) * .8 + .2\n    ps_plane.set_pose((0., 0., pos), (0., 0., -1.))\n\n    # Take a screenshot at each frame\n    ps.screenshot(transparent_bg=False)\n</code></pre> <p>Slice planes can also be manipulated in the GUI under <code>[View] --&gt; [Slice Planes]</code>, where you can add and remove slice planes and control whether they are active and widgets are visible. When a plane is active in the scene, you can drag the 3D widget to adjust its pose. Additionally, for each structure, <code>[Options] --&gt; [Slice Planes]</code> allows you to toggle whether the slice plane effects that structure.</p>"},{"location":"features/slice_planes/#creating-and-modifying-slice-planes","title":"Creating and modifying slice planes","text":"<code>SlicePlane add_scene_slice_plane()</code> <code>remove_last_scene_slice_plane()</code> <code>SlicePlane.get_name()</code> <code>SlicePlane.set_pose(plane_position, plane_normal)</code> <code>SlicePlane.set_active(val)</code> <code>SlicePlane.get_active()</code> <p>Test whether the slice plane is active.</p> <code>SlicePlane.set_draw_plane(val)</code> <code>SlicePlane.get_draw_plane()</code> <p>Test whether the slice plane is drawing its plane.</p> <code>SlicePlane.set_draw_widget(val)</code> <code>SlicePlane.get_draw_widget()</code> <p>Test whether the slice plane is drawing its widget.</p>"},{"location":"features/slice_planes/#add-slice-plane","title":"add slice plane","text":"<p>Add a new slice plane to the scene and return it. An arbitrary number of slices planes may be added.</p>"},{"location":"features/slice_planes/#remove-slice-plane","title":"remove slice plane","text":"<p>Remove the most recently created slice plane.</p>"},{"location":"features/slice_planes/#name","title":"name","text":"<p>Get the unique name of the slice plane.</p>"},{"location":"features/slice_planes/#set-pose","title":"set pose","text":"<p>Set the position and orientation of the slice plane.</p> <ul> <li><code>plane_position</code> is any 3D position which the plane touches (the center of the plane)</li> <li><code>plane_normal</code> is a vector giving the normal direction of the plane, objects in this negative side of the plane will be culled</li> </ul> <p>These input 3D vectors can be tuples, length-3 numpy arrays, or really anything that can be indexed for three components.</p>"},{"location":"features/slice_planes/#active","title":"active","text":"<p>Set the slice plane to be active or not. If inactive, the slice plane will not have any effect on any structures in the scene, nor will it be shown in the GUI view.</p>"},{"location":"features/slice_planes/#draw-plane","title":"draw plane","text":"<p>Set the slice plane to draw its plane (as a colored, semi-transparent grid). If <code>False</code> the slice plane will still slice objects, but the plane itself will not be rendered.</p>"},{"location":"features/slice_planes/#draw-widget","title":"draw widget","text":"<p>Set the slice plane to draw its control widget (a grey and colored cube with handles for translations and rotations). If <code>False</code> the slice plane will still slice objects, but the widget will not be rendered.</p> <p>Note that regardless of this setting, the widget will not be visible in any screenshots by default, because it is treated as part of the GUI interface, like the ImGUI widow panes.</p>"},{"location":"features/slice_planes/#per-structure-ignore-slice-planes","title":"Per-structure ignore slice planes","text":"<p>By default, every slice plane affects all content in the scene. However, we can also make a particular structure ignore a given slice plane, so that it only slices through some of the objects in the scene. This can be set in the GUI for each structure under <code>[Options] --&gt; [Slice Planes]</code>, or programatically with the function below.</p> <pre><code>ps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps_plane = ps.add_scene_slice_plane()\nps_mesh.set_ignore_slice_plane(ps_plane, True)\n</code></pre> <code>Structure.set_ignore_slice_plane(plane, val)</code> <code>Structure.get_ignore_slice_plane(plane)</code> <p>Test if a slice plane is currently being ignored by the structure.</p> <p><code>plane</code> can be passed as a plane object or as a string giving the name of a plane.</p>"},{"location":"features/slice_planes/#ignore-plane","title":"ignore plane","text":"<p>Set a slice plane to be ignored by the structure. If <code>val</code> is <code>True</code> the slice plane will be ignored, and if <code>False</code> it will be respected.</p> <p><code>plane</code> can be passed as a plane object or as a string giving the name of a plane.</p>"},{"location":"features/slice_planes/#cull-whole-elements","title":"Cull whole elements","text":"<p>For some structures, slice planes can be set to discretely cull away whole elements, rather than slicing directly through the middle of an element.  This option can be set in the GUI for each structure under <code>[Options] --&gt; [Slice Planes]</code>, or programatically with the function below.</p> <p></p> <pre><code>ps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps_plane = ps.add_scene_slice_plane()\nps_mesh.set_cull_whole_elements(False)\n</code></pre> <code>Structure.set_cull_whole_elements(val)</code> <code>Structure.get_cull_whole_elements()</code> <p>Test whether the cull whole elements setting is applied.</p>"},{"location":"features/slice_planes/#set-cull-whole-elements","title":"set cull whole elements","text":"<p>If <code>True</code>, slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements.</p> <p>Note that not all structures may support culling whole elements. If not supported, this setting will do nothing.</p>"},{"location":"features/slice_planes/#inspecting-volume-meshes","title":"Inspecting volume meshes","text":"<p>Slice planes can also inspect volume meshes, rendering a surface where the structure is cut by the plane. Not only does this help to visualize the interior of the shape, but scalar and color quantities can be drawn along the plane to better inspect values on the interior of the mesh.</p> <p>This can also be set in the UI under <code>[View] --&gt; [Slice Planes] --&gt; [Inspect]</code>. This option will only be available when there is at least one volume mesh in the scene.</p> <p>If the volume mesh has a vertex scalar or vertex color quantity enabled, it will be automatically drawn on the inspecting slice plane.</p> <code>SlicePlane.set_volume_mesh_to_inspect(meshNameStr)</code> <p>Give the name of a volume mesh to inspect. Pass the empty string <code>\"\"</code> to clear the inspection.</p> <code>SlicePlane.get_volume_mesh_to_inspect()</code> <p>Get the volume mesh being inspected. Returns a string.</p>"},{"location":"features/transparency/","title":"Transparency","text":"<p>The Polyscope rendering framework supports transparency to visualize complicated data with nested internal structures.</p> <p></p> <p>Example: register a surface mesh and render it with transparency</p> <pre><code>import polyscope as ps\n\nps.init()\n\n# Add a mesh with transparency\n# ... load verts and faces ...\nps_mesh = ps.register_surface_mesh(\"mesh\", verts, faces, \n                                    transparency=0.7)\n\n# As soon as any structure has transparency set, the transparency mode\n# is automatically changed to 'pretty' (depth peeling). It can be further\n# changed like:\nps.set_transparency_mode('simple')\n\n# take screenshot from the current camera view, \n# which will have transparency according to the structure\nps.screenshot(\"test_image.png\", True);\n\n# open the GUI\nps.show(3)\n</code></pre>"},{"location":"features/transparency/#transparency-modes","title":"Transparency modes","text":"<p>In computer graphics, rendering scenes with transparent content is surprisingly difficult and often computationally expensive. Polyscope supports three different modes for transparent rendering:</p> <ul> <li><code>'none'</code> is the default, which does not use any transparency and ignores any related settings.</li> <li><code>'simple'</code> uses an approximation which takes a weighted average of objects in view. The benefit is that this method is efficient, only slightly more expensive than normal rendering. However, it ignores the relative depth of different objects, and thus can yield noticeable and confusing artifacts on complex scenes. Generally, this method should only be used when rendering performance is a concern (i.e., if the view is otherwise too laggy to use).</li> <li><code>'pretty'</code> implements expensive-but-accurate \u201ctrue\u201d transparency, which properly accounts for objects at different depths. This mode is implemented using depth peeling, which internally renders the scene many times to generate each frame. Because many internal render passes are needed, this mode may be dramatically more expensive than normal rendering, leading to a laggy interface. The parameter configured with <code>set_transparency_render_passes()</code> controls the number passes performed (default: <code>8</code>); smaller values will reduce the performance hit, whereas larger values may be necessary to resolve complex scenes.</li> </ul> <p>The modes are set via <code>set_transparency_mode</code>. Initially, the transparency mode is set to <code>'none'</code>. However, if the transparency of any object is modified while the mode is <code>'none'</code>, the mode will be automatically updated to <code>'pretty'</code> so that the effect is visible.</p> <p>Any ground plane reflections are disabled when using transparency.</p> <p>The transparency mode can also be changed in the GUI in the <code>[Appearance] --&gt; [Transparency]</code> menu.</p> <code>set_transparency_mode(mode_str)</code> <p>Set the mode used for transparent rendering. One of <code>'none'</code>, <code>'simple'</code>, or <code>'pretty'</code> (see above for explanation).</p> <p>Default: <code>'none'</code>. Automatically updated when a transparency value is set for some structure.</p> <code>set_transparency_render_passes(n)</code> <p>The number of passes used for <code>'pretty'</code> mode. Lower values will reduce the performance impact, but larger values may be necessary to resolve transparency in complex scenes.</p> <p>Default: <code>8</code>. </p>"},{"location":"features/transparency/#setting-structure-transparency","title":"Setting structure transparency","text":"<p>Transparency is controlled via a real-valued parameter from <code>0</code> to <code>1</code>, commonly called \u201calpha\u201d. Setting transparency to <code>1</code> means completely opaque (the default), whereas <code>0</code> means completely transparent.  This parameter is specified on a per-structure basis via <code>Structure.set_transparency(val)</code>, or by using a <code>transparency</code> keyword argument when registering the structure.  Transparency for each structure can also be modified in the GUI by selecting <code>[Options] --&gt; [Transparency]</code> for the structure.</p> <code>Structure.set_transparency(val)</code> <p>Set the transparency for a structure, <code>1</code> means completely opaque (the default), whereas <code>0</code> means completely transparent.</p> <p>Example: <pre><code>ps_mesh = polyscope.register_surface_mesh(\"mesh\", verts, faces)\nps_mesh.set_transparency(0.5)\n</code></pre></p>"},{"location":"installing/","title":"Installing","text":"<p>Polyscope supports Python 3.5-3.9 with prebuilt binaries on all major operating systems. At runtime, your environment must support OpenGL &gt;= <code>3.3 core</code>, and have the ability to open windows in a display. This includes nearly all modern desktop/laptop computers, but not all headless servers and virtual machines.</p>"},{"location":"installing/#installing-from-pypi-with-pip","title":"Installing from PyPi with pip","text":"<p><pre><code>python -m pip install polyscope\n# or maybe\npython3 -m pip install polyscope\n</code></pre> Using <code>python -m pip install</code> rather than just <code>pip install</code> helps when your system has multiple version of Python installed, ensuring the correct <code>pip</code> is used. Just be sure <code>python</code> refers to the install of Python you intend to use.</p> <p>Ideally, this install will resolve to a precompiled wheel for your platform\u2014see troubleshooting if not. Otherwise, the setup script will compile the Polyscope C++ library from source, which may take a few minutes, and requires a suitable C++ toolchain (see building from source).</p>"},{"location":"installing/#troubleshooting","title":"Troubleshooting","text":"<p>On common platforms, <code>pip</code> should always be able to install from a binary <code>.whl</code> file. If it fails to select a binary wheel, it will try to compile from source, leading to long install times or compilation errors if your toolchain is not configured.</p> <p>Here are some common fixes: </p> <ul> <li>Ensure you\u2019re targeting the latest Polyscope <code>python -m pip install polyscope --upgrade</code></li> <li>Very old versions of <code>pip</code> may not be able to use the precompiled wheels. Upgrade <code>pip</code> with <code>python -m pip install pip --upgrade</code>.</li> <li>Precompiled wheels are available on pip for Python 3.5-3.9 (aka most common versions), check yours with <code>python --version</code>, and update your Python install if needed.</li> </ul>"},{"location":"installing/#source-installs-with-pypi","title":"Source installs with PyPI","text":"<p>Despite our best efforts, the precompiled binaries still may not work on some platforms. You can intentionally instruct <code>pip</code> to build the library from source using: <pre><code>python -m pip install polyscope --no-binary polyscope\n</code></pre> This may take a few minutes, and requires a suitable C++ toolchain (see building from source).</p>"},{"location":"installing/#installing-from-conda","title":"Installing from Conda","text":"<pre><code>conda install -c conda-forge polyscope\n</code></pre>"},{"location":"installing/#installing-manually","title":"Installing manually","text":"<p>To manually download the sources:</p> <pre><code>git clone --recursive https://github.com/nmwsharp/polyscope-py.git\ncd polyscope-py\n</code></pre> <p>Polyscope can then by installed with pip as <pre><code>python -m pip install .\n</code></pre></p> <p>Or manually installed with the setup script using <pre><code>python setup.py install\n</code></pre></p>"},{"location":"installing/#building-from-source","title":"Building from source","text":"<p>If a pre-compiled wheel is not available, the setup scripts (either run automatically via <code>pip</code> or manually with <code>setup.py</code>) will need to compile the underlying C++ library. Your system must have a suitable C++ compiler available to build Polyscope, as well as build tools like CMake installed. The Polyscope C++ repository has a few more details about compiling. Polyscope is a 3D graphics program, so it may be difficult to build on servers without graphics support, or extremely old machines. In particular, OpenGL &gt;= <code>3.3 core</code> is a strict requirement.</p>"},{"location":"installing/#development-builds","title":"Development builds","text":"<p>To compile Polyscope locally without <code>setup.py</code> (e.g., if you are developing the library) use</p> <pre><code>git clone --recursive https://github.com/nmwsharp/polyscope-py.git\ncd polyscope-py\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j4\n</code></pre> <p>this will generate a file something like <code>polyscope_bindings.cpython-36m-x86_64-linux-gnu.so</code> (the particular name depends on your platform), which contains the low-level bindings to C++ Polyscope. This is a pybind11 build; it can be further customized using any pybind11 CMake options, for instance to choose which version of Python is used.</p> <p>The actual Polyscope python library lives in <code>src/polyscope</code>, which is a wrapper around these low-level bindings. You are now ready to <code>import polyscope</code>, so long as both the compiled bindings and <code>src/polyscope</code> can be found on your <code>PYTHONPATH</code>.</p>"},{"location":"structures/structure_management/","title":"Structure Management","text":"<p>A structure is a geometric object visualized in Polyscope, like a mesh or a point cloud. The first step in seeing your data in Polyscope is to register one or more structures to add them to the visualization. Then, quantities can be added to these structures, like scalar functions, colors, or vector fields.</p> <p>Each structure should be given a name which is unique among structures of that type. You can then use this name as a handle to perform operations on the structure; For instance, you can register a mesh with: <pre><code>ps.register_surface_mesh(\"my mesh\", vertices, faces)\n</code></pre> Then, in a distant part of your code, add a scalar function to it with: <pre><code>ps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"some values\", values)\n</code></pre> This avoids the need to pass a reference to the structure you created around your entire codebase. Alternately, one can directly use the handle returned by <code>register_surface_mesh()</code>, instead of keying on a name string.</p>"},{"location":"structures/structure_management/#registering-structures","title":"Registering structures","text":"<p>Each structure offers a <code>register___(name, ...)</code> function (like <code>register_point_cloud()</code>) which accepts the name of the structure and the data necessary to construct it. These functions will return a structure object which may be used to add quantities to the structure. See the relevant sections for documentation on each of these register functions.</p>"},{"location":"structures/structure_management/#accessing-structures","title":"Accessing structures","text":"<p>Polyscope offers two patterns for calling methods on a registered structure: you can either use the handle returned after structure creation, or refer to the structure by name.</p> <p><pre><code>import polyscope as ps\n\n# register a structure\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# access with the handle\nps_mesh.add_scalar_quantity(\"some values\", values)\n\n# access by name\nps.get_surface_mesh(\"my mesh\").add_scalar_quantity(\"some values\", values)\n</code></pre> The former is concise and programmatic, while the latter avoids the need to keep track of a variable.</p> <p>As before, each structure offers a <code>get___(name)</code> method, like <code>get_surface_mesh(name)</code> which can be used to get a handle to the structure of that type by name.</p>"},{"location":"structures/structure_management/#removing-structures","title":"Removing structures","text":"<p>If no longer needed, structures can be removed by name or by handle. Removing a structure frees memory for the underlying objects, invalidating all references to the structure and its quantities.</p> <pre><code>import polyscope as ps\n\n# register a structure and some data\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps_mesh.add_scalar_quantity(\"some values\", values)\n\n# look at it\nps.show()\n# (user exits ui)\n\n\n# remove the structure\n# (these two forms are equivalent, choose one) \nps_mesh.remove()\nps.remove_surface_mesh(\"my_mesh\")\n\n\n# actually, just remove everything\nps.remove_all_structures()\n</code></pre> <code>remove_all_structures()</code> <p>Remove all structures from the scene.</p>"},{"location":"structures/structure_management/#quantities","title":"Quantities","text":"<p>Quantities, like scalar functions, color fields, vector fields, and more, can be associated with structures. See the available options for each kind of structure.</p> <p>Quantities can be removed from a structure by name.</p> <code>Structure.remove_quantity(name, error_if_absent=False)</code> <p>Remove a quantity from the structure by name.</p> <code>Structure.remove_all_quantities()</code> <p>Remove all quantities which have been added to the structure.</p>"},{"location":"structures/structure_management/#structure-options","title":"Structure options","text":"<p>These basic options are shared by all structures.  Structure options are managed as persistent values, and thus will persist if a new structure is registered with the same name.</p>"},{"location":"structures/structure_management/#enabled","title":"Enabled","text":"<p>If a structure is disabled, it will be hidden from view, along with any quantities associated with that structure.</p> <code>Structure.is_enabled()</code> <p>Is the structure enabled? Returns a boolean.</p> <code>Structure.set_enabled(newVal=True)</code> <p>Set the structure to be enabled or disabled. Takes a boolean.</p> <p>Can also be set when registering, like <code>register_point_cloud(..., enabled=True)</code>.</p>"},{"location":"structures/structure_management/#transparency","title":"Transparency","text":"<p>Set the transparency parameter for the structure. <code>1</code> is fully opaque (the default), and <code>0</code> is fully transparent. When the first structure has transparency applied, transparent rendering will be automatically enabled.</p> <p>Transparency can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Transparency]</code> menu.</p> <code>Structure.get_transparency()</code> <p>Get the transparency parameter for the structure. Returns a float</p> <code>Structure.set_transparency(alpha)</code> <p>Set the transparency for the structure. Takes a float.</p> <p>Can also be set when registering, like <code>register_point_cloud(..., transparency=0.5)</code>.</p>"},{"location":"structures/structure_management/#transforms","title":"Transforms","text":"<p>Each structure has an associated spatial transform applied to it for display in the scene. The transform encodes a translation, rotation, and scaling represented as a 4x4 homogeneous matrix. Initially this transformation is just the identity transform (it does nothing), but it can be adjusted to position the structures in your scene.</p> <p>The transform can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Transform]</code> menu.</p> <code>Structure.get_transform()</code> <p>Get the current transformation matrix. Returns a 4x4 numpy matrix.</p> <code>Structure.set_transform(transform)</code> <p>Set a particular transform matrix. Takes a 4x4 numpy array.</p> <code>Structure.get_position()</code> <p>Get the translation component of the transformation matrix, the position to which the structure\u2019s origin is translated. Returns a length-3 numpy vector.</p> <code>Structure.set_position(vec)</code> <p>Set the transformation matrix such that structure is transformed to the position <code>vec</code>. Takes a length-3 numpy vector.</p> <code>Structure.translate(vec)</code> <p>Translate the transformation matrix by offset <code>vec</code>. Takes a length-3 numpy vector.</p> <code>Structure.center_bounding_box()</code> <p>Set the transformation such that the structure\u2019s bounding box is centered at the world origin.</p> <code>Structure.rescale_to_unit()</code> <p>Set the transformation scaling such that the structure has length scale 1. This makes all structures roughly the same size.</p> <code>Structure.reset_transform()</code> <p>Reset the structure\u2019s transform to be the identity transform (i.e. to do nothing).</p> <code>void Structure.set_transform_gizmo_enabled(b)</code> <p>Enable/disable the interactive onscreen widget which lets the user adjust an object\u2019s transform. Takes a boolean as input.</p> <code>Structure.get_transform_gizmo_enabled()</code> <p>Get the enabled state of the interactive onscreen widget which lets the user adjust an object\u2019s transform.  Returns a boolean.</p>"},{"location":"structures/structure_management/#slice-planes","title":"Slice planes","text":"<p>Options relating to slice planes which may be present in the scene.</p> <p>Slice plane options can be controlled in the UI via the structure\u2019s <code>[Options] --&gt; [Slice Planes]</code> menu.</p> <code>Structure.set_cull_whole_elements(newVal)</code> <p>If <code>true</code>, slice planes will affect this structure by culling whole elements (tets, triangles, points, etc), rather than slicing through the middle of the elements. Takes a boolean.</p> <p>Note that not all structures may support culling whole elements. If not supported, this setting will do nothing.</p> <p>Default: false.</p> <code>Structure.get_cull_whole_elements()</code> <p>Get whether the cull whole elements setting is applied. Returns a boolean.</p> <code>Structure.set_ignore_slice_plane(name, newValue)</code> <p>Set a slice plane to be ignored by the structure. If <code>newValue</code> is <code>true</code> the slice plane will be ignored, and if <code>false</code> it will be respected. Takes a string and a boolean.</p> <code>Structure.get_ignore_slice_plane(name)</code> <p>Get if a slice plane is currently being ignored by the structure. Takes a string, returns a boolean.</p>"},{"location":"structures/camera_view/basics/","title":"Camera Views","text":"<p>Use camera view structures to represent pinhole cameras in a 3D scene. Given camera locations, orientations, and field of view (intrinsics + extrinsics), Polyscope will draw a camera frame on the scene. Images quantities can be associated with the cameras and displayed on the camera frame. You can even align the interactive viewport with a selected camera.</p>    Your browser does not support the video tag.  <p>Add an Image Quantity!</p> <p>Camera views structures on their own are not so interesting; they are simplify displayed as a wireframe camera widget in the viewport.</p> <p>Try adding an Image Quantitiy to the camera view. When image quantities are added to camera view structures, they gain the additional ability to be displayed in the camera\u2019s frame.</p> <p>Example:</p> <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# Create a camera view from parameters\nintrinsics = ps.CameraIntrinsics(fov_vertical_deg=60, aspect=2)\nextrinsics = ps.CameraExtrinsics(root=(2., 2., 2.), look_dir=(-1., -1.,-1.), up_dir=(0.,1.,0.))\nparams = ps.CameraParameters(intrinsics, extrinsics)\ncam = ps.register_camera_view(\"cam\", params)\n\n# Set some options for the camera view\n# these can also be set as keyword args in register_camera_view()\ncam.set_widget_focal_length(0.75)          # size of displayed widget (relative value)\ncam.set_widget_thickness(0.25)             # thickness of widget lines\ncam.set_widget_color((0.25, 0.25, 0.25))   # color of widget lines\n\n\n# Add an image to be displayed in the camera frame\nw = 600\nh = 300\ncam.add_scalar_image_quantity(\"scalar_img\", np.zeros((h, w)),\n                              enabled=True, show_in_camera_billboard=True)\n\nps.show(3)\n</code></pre>"},{"location":"structures/camera_view/basics/#registering-a-camera-view","title":"Registering a Camera View","text":"<p>Camera views are created from Camera Parameters.</p> <p>Note that we do not specify an image resolution for the camera view. It can hold images of any resolution, as long as the aspect ratio is right.</p> <code>register_camera_view(name, params, **kwargs)</code> <p>Add a new camera view structure to Polyscope.</p> <ul> <li><code>params</code> is a Camera Parameters.</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>widget_focal_length</code> float, size of displayed widget (relative value)</li> <li><code>widget_thickness</code> float, thickness of widget lines</li> <li><code>widget_color</code> float 3-tuple, color of widget lines</li> </ul> <p>As with all structures, there is also <code>get_camera_view(\"name\")</code>, <code>has_camera_view(\"name\")</code>, and <code>remove_camera_view(\"name\")</code>.</p>"},{"location":"structures/camera_view/basics/#updating-a-camera-view","title":"Updating a Camera View","text":"<p>You can update the parameters associated with a camera view to move it within the scene after creation.</p> <code>CameraView.update_camera_parameters(new_params)</code> <p>Update camera parameters.</p> <ul> <li><code>params</code> is a Camera Parameters.</li> </ul>"},{"location":"structures/camera_view/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? focal length size of rendered widget <code>get_widget_focal_length()</code> <code>set_widget_focal_length(newVal, relative=true)</code> yes thickness rendered widget line thickness <code>get_widget_thickness()</code> <code>set_widget_thickness(newVal)</code> yes color widget color <code>get_widget_color()</code> <code>set_widget_color(newVal)</code> yes"},{"location":"structures/curve_network/basics/","title":"Curve Networks","text":"<p>Curve networks are collections of nodes sitting in space, connected by edges. In addition to displaying the nodes and edges of the network itself, Polyscope can show any number of scalar, vector, or color quantities associated with the nodes or edges of the network.</p> <p>Try clicking on a node or edge to see the data associated with that point!</p> <p></p>"},{"location":"structures/curve_network/basics/#registering-a-curve-network","title":"Registering a curve network","text":"<p>Curve network structures can be registered with Polyscope by passing the node position and edge indices. </p> <p>Example: a network of random curves  <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# generate some random nodes and edges between them\nnodes = np.random.rand(100, 3)\nedges = np.random.randint(0, 100, size=(250,2))\n\n# visualize!\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\nps.show()\n</code></pre></p> <p>Convenience adders for common cases</p> <p>Rather than passing a vector of edge indices, there are also built-in helpers for common cases of connectivity, like a single continuous sequential line or loop, or a collection of line segments. To use them, pass the string <code>line</code>, <code>loop</code>, or <code>segments</code> in places of edge indices, like <code>register_curve_network(\"name\", nodes, edges='segments')</code>.</p> <ul> <li><code>edges='line'</code> The nodes will be connected together sequentially, forming a single curve</li> <li><code>edges='loop'</code> The nodes will be connected together sequentially, including the last to the first, to form a closed loop</li> <li><code>edges='segments'</code> The <code>2N</code> nodes will be connected to form a set of <code>N</code> line segments, interleaved as in <code>[start_0 end_0 start_1 end_1 ...]</code></li> </ul> <code>register_curve_network(name, nodes, edges, enabled=None, radius=None, color=None, material=None)</code> <p>Add a new curve network structure to Polyscope.</p> <ul> <li><code>name</code> string, a name for the structure</li> <li><code>nodes</code>, an <code>Nx3</code> numpy float array of node locations (or <code>Nx2</code> for 2D)</li> <li><code>edges</code>, an <code>Ex2</code> numpy integer array of edge connections, as 0-based indices in to the nodes array, OR the string <code>line</code>/<code>loop</code>/\u2019segments\u2019,  to generate node connectivity as a line or loop, respectively.</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>radius</code> float, a size for the nodes and edges relative to the scene length scale (use <code>set_radius(val, relative=False)</code> for absolute units)</li> <li><code>color</code> float 3-tuple, default color values for the network as rgb in [0,1]</li> <li><code>material</code> string, name of material to use for network </li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>2D node positions are also supported, see 2D data.</p>"},{"location":"structures/curve_network/basics/#updating-a-curve-network","title":"Updating a curve network","text":"<p>The locations of the nodes in a curve network can be updated with the member function <code>update_node_positions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or number of nodes/edges is not supported, you will need to register a new curve network (perhaps with the same name to overwrite).</p> <code>CurveNetwork.update_node_positions(newPos)</code> <p>Update the node positions in a curve network structure. <code>newPos</code> must be valid input as to initially construct the nodes of the network, with the same number of nodes as the network curently has.</p>"},{"location":"structures/curve_network/basics/#adjusting-the-node-and-edge-radius","title":"Adjusting the node and edge radius","text":"<p>Set the radius of the nodes and edges in the curve network with <code>CurveNetwork.set_radius(newRad)</code>, or in the constructor. By default, the radius is a relative value which gets scaled by the content in the scene, so for example a default of <code>0.02</code> will always be a reasonable size no matter what the scale of the content in your scene is. Or, set <code>relative=False</code> to set an absolute radius in world units.</p> <code>CurveNetwork.set_radius(newVal, relative=True)</code> <p>Update the radius for the nodes and edges in the curve network.</p> <p>By default the radius is interpreted as a relative value, setting <code>relative=False</code> will treat is as an absolute length in world units.</p> <p>To set a variable radius which is different for each node and/or edge in the curve network, see the variable radius page.</p>"},{"location":"structures/curve_network/basics/#options","title":"Options","text":"<p>Options control the appearance of the curve network. These options can also be passed as keyword arguments to the initial <code>register_curve_network()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? radius size of rendered nodes/edges <code>get_radius()</code> <code>set_radius(newVal, relative=True)</code> yes color default color for the network <code>get_color()</code> <code>set_color(newVal)</code> yes material material for structure <code>get_material()</code> <code>set_material(newVal)</code> yes <p>Example: set options which affect the appearance of the curve network <pre><code>network = polyscope.register_curve_network(\"my net\", nodes, edges)\n\nnetwork.set_enabled(False) # disable\nnetwork.set_enabled() # default is true\n\nnetwork.set_radius(0.02) # radius is relative to a scene length scale by default\nnetwork.set_radius(1.7, relative=False) # radius in absolute world units\n\nnetwork.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\nnetwork.set_material(\"candy\")\nnetwork.set_transparency(0.5)\n\n# alternately:\nps.register_curve_network(\"my net 2\", nodes, edges, enabled=False, \n                           material='candy', radius=0.02, color=(1., 0., 0.),\n                           transparency=0.5)\n</code></pre></p>"},{"location":"structures/curve_network/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the nodes or edges of a curve network.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a curve network \nN_node = 100\nN_edge = 250\nnodes = np.random.rand(N_node, 3)\nedges = np.random.randint(0, N_node, size=(N_edge,2))\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\n\n# visualize some random colors per-node\nvals_node = np.random.rand(N_node, 3)\nps_net.add_color_quantity(\"rand vals\", vals_node, enabled=True)\n\n# visualize some random colors per-edge\nvals_edge = np.random.rand(N_edge, 3)\nps_net.add_color_quantity(\"rand vals2\", vals_edge, defined_on='edges')\n\n\n# view the network with all of these quantities\nps.show() \n</code></pre></p> <code>CurveNetwork.add_color_quantity(name, values, defined_on='nodes', enabled=None)</code> <p>Add a scalar quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at nodes/edges</li> <li><code>defined_on</code> string, one of <code>\"nodes\"</code> or <code>\"edges\"</code>, is this data a color per-node or a value per-edge?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/curve_network/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/curve_network/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar valued data at the nodes or edges of a curve network.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a curve network \nN_node = 100\nN_edge = 250\nnodes = np.random.rand(N_node, 3)\nedges = np.random.randint(0, N_node, size=(N_edge,2))\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\n\n# visualize some random data per-node\nvals_node = np.random.rand(N_node)\nps_net.add_scalar_quantity(\"rand vals\", vals_node, enabled=True)\n\n# visualize some random data per-edge\nvals_edge = np.random.rand(N_edge)\nps_net.add_scalar_quantity(\"rand vals2\", vals_edge, defined_on='edges')\n\n# as always, we can customize the initial appearance\nps_net.add_scalar_quantity(\"rand vals2 opt\", vals_edge, defined_on='edges', \n                           enabled=True, vminmax=(-3., 3.), cmap='reds')\n\n\n# view the network with all of these quantities\nps.show() \n</code></pre></p> <code>CurveNetwork.add_scalar_quantity(name, values, defined_on='nodes', enabled=None, datatype=\"standard\", vminmax=None, cmap=None)</code> <p>Add a scalar quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at nodes/edges</li> <li><code>defined_on</code> string, one of <code>\"nodes\"</code> or <code>\"edges\"</code>, is this data a value per-node or a value per-edge?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/curve_network/scalar_quantities/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/curve_network/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/curve_network/variable_radius/","title":"Variable Radius","text":"<p>By default, all nodes/edges in the curve network have the same radius. However, any node or edge scalar quantity can be additionally interpreted as the radius of the nodes or edges of the curve network. This can also be set manually in the GUI via the curve network <code>[Options]</code> \u2013&gt; <code>[Variable Node/Edge Radius]</code>.</p> <p></p> <p>Any negative values in the scalar quantity will be clamped to <code>0</code>. By default, values will be rescaled such that the largest corresponds to the size from the radius option (thus, using any constant scalar quantity will make the radii identical to the default value with no radius set). This automatic scaling can be disabled by setting <code>autoscale=false</code> below.</p> <p>Reproducing radius in world units</p> <p>Remember that curve networks always have a per-structure <code>radius</code> parameter which sets a radius for all of the nodes and edges in the curve network (and can be adjusted via a slider in the GUI, or via <code>set_radius()</code>). This per-structure parameter makes things a little more complicated when also setting length via a scalar quantity as described here.</p> <p>By default, the structure radius parameter is still respected. The variable radius from the quantity first scaled such that the largest value is <code>1.</code>, and then is multiplied by the structure parameter to get the actual radius used for the elements.</p> <p>This usually gives a reasonable visualization, but makes it difficult to set a precise radius in world units.  To properly reproduce a radius in world-coordinate units, you can circumvent autoscaling like <code>CurveNetwork.set_node_radius_quantity(\"q_name\", false)</code>. This will prevent the auto-scaling of the radii, and also ignore the structure\u2019s radius parameter.</p> <p>Node radius vs. edge radius</p> <p>If you set only a node radius, it will be used to set the radius of each node, and edges will be drawn as frustums with each end sized according to the incident node.</p> <p>If you set only an edge radius, it will be used to set the radius of each edge, and nodes will be drawn with a radius which is the average of the radii of incident edges.</p> <p>If you set both a node and an edge radius, then each will be used for the respective elements.</p> <p>In the edge-only case and the node-and-edge case, the edges may not perfectly line up the the nodes they are adjacent to, the only way to fix it is to manually set a proper node radius, or use node radius only.</p> <p>To set values as the curve network radius, first add them as a scalar quantity, then assign the scalar quantity as the radius using the functions below.</p> <code>CurveNetwork.set_node_radius_quantity(name, autoscale=True)</code> <p>Set the node radius from a quantity by string name. The quantity must be a node scalar quantity add to this curve network.</p> <p>When using a radius which is a physical length in world coordinates, set <code>autoscale</code> to <code>False</code> to skip rescaling and ignore the structure\u2019s radius parameter.</p> <code>CurveNetwork.clear_node_radius_quantity()</code> <p>Clear the node radius quantity and return to using the constant radius.</p> <code>CurveNetwork.set_edge_radius_quantity(name, autoscale=True)</code> <p>Set the edge radius from a quantity by string name. The quantity must be an edge scalar quantity add to this curve network.</p> <p>When using a radius which is a physical length in world coordinates, set <code>autoscale</code> to <code>False</code> to skip rescaling and ignore the structure\u2019s radius parameter.</p> <code>CurveNetwork.clear_edge_radius_quantity()</code> <p>Clear the edge radius quantity and return to using the constant radius.</p>"},{"location":"structures/curve_network/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the nodes or edges of a curve network.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a curve network \nN_node = 100\nN_edge = 250\nnodes = np.random.rand(N_node, 3)\nedges = np.random.randint(0, N_node, size=(N_edge,2))\nps_net = ps.register_curve_network(\"my network\", nodes, edges)\n\n# visualize some random vectors per-node\nvecs_node = np.random.rand(N_node, 3)\nps_net.add_vector_quantity(\"rand vecs\", vecs_node, enabled=True)\n\n# visualize some random vectors per-edge\nvecs_edge = np.random.rand(N_edge, 3)\nps_net.add_vector_quantity(\"rand vecs edge\", vecs_edge, defined_on='edges')\n\n# set radius/length/color of the vectors\nps_net.add_vector_quantity(\"rand vecs opt\", vecs_node, radius=0.001, length=0.005, color=(0.2, 0.5, 0.5))\n\n# ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space\nps_net.add_vector_quantity(\"vecs ambient\", vecs_node, vectortype='ambient')\n\n# view the network with all of these quantities\nps.show() \n</code></pre></p> <code>CurveNetwork.add_vector_quantity(name, values, defined_on='nodes', enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at nodes/edges (or <code>Nx2</code> for 2D data)</li> <li><code>defined_on</code> string, one of <code>nodes</code> or <code>edges</code>, is this data a vector per-node or a vector per-edge?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/curve_network/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> <li><code>material</code> string, shading material for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/basics/","title":"Basics","text":"<p>Most quantities in Polyscope are associated with a particular structure, such as a <code>PointCloudScalarQuantity</code> on a <code>PointCloud</code>. In contrast, Floating Quantities are generic quantities which can be added to any and all kinds of structures. You can also add them to the root level of the scene, not associated with any structure. </p> <p>One example of a floating quantity is an Images Quantity. You might want to visualize a single image, not specific to any structure, by adding it to the scene at the root level. Or, you might have an image associated with a particular mesh, in which case you could add the image quantity to that <code>SurfaceMesh</code> structure.</p> <p>TL;DR What are floating quantities?</p> <p>Floating quantities are quantities that are general and not specific to any kind of structure.</p> <p>You have two options for how to add them:</p> <ul> <li>Add them as standalone quantities in the scene at the root level, like <code>polyscope.add_image_quantity(...)</code>.</li> <li>Add them to any structure of any type, like <code>pointCloud.add_image_quantity(...)</code>. This can be useful to associate the quantity with a structure.</li> </ul> <p>The sub-menus to the left give the various floating quantities available.</p>"},{"location":"structures/floating_quantities/images/","title":"Images","text":"<p>Images are rectangular grids of pixel values.</p> <p>Sample: An image quantity of a majestic cat, shown here in the ImGui window display mode.</p> <p></p> <p>Floating Quantities</p> <p>Images are floating quantities, which means they can be added to the scene at the root level, or added to any kind of structure.</p> <p>See the floating quantity introduction for more info.</p> <p>Example:</p> <pre><code>import polyscope as ps\nps.init()\n\n# Your image data, must be populated somehow\nw = 1024\nh = 768\n\n# == Add images at the root level of the scene\n# try out a few of the options while we're at it\n\nps.add_color_image_quantity(\"color_img\", np.zeros((h, w, 3)), enabled=True, \n                            show_fullscreen=True, show_in_camera_billboard=False, transparency=0.5)\n\nps.add_color_alpha_image_quantity(\"color_alpha_img\", np.zeros((h, w, 4)), enabled=True, \n                                  show_in_imgui_window=True, show_in_camera_billboard=False,\n                                  is_premultiplied=True, image_origin='lower_left')\n\nps.add_scalar_image_quantity(\"scalar_img\", np.zeros((h, w)), enabled=True, \n                             datatype='symmetric', vminmax=(-3.,.3), cmap='reds')\n\n\n# == Add images associated with a structure\n# Here, a camera view, you could also use a point cloud, or a mesh, etc\ncam = ps.get_camera_view(\"my view\"); # some structure you previously registered\n\ncam.add_color_image_quantity(\"color_img\", np.zeros((h, w, 3)), enabled=True,\n                             show_in_camera_billboard=True)\n                             # when adding an image to a camera view, we can display it\n                             # in the camera billboard\n\nps.show()\n</code></pre> <p>Images vs. Render Images</p> <p>If your image happens to represent a rendering of the scene from the user\u2019s viewport (for example, from custom renderer code), check out the Render Image quantity, which offers additional functionality for view-rendered images such as depth-compositing them into the scene to layer and blend with other content.</p> <p>Camera Views</p> <p>Image quantities get special functionality when added to <code>CameraView</code> structures: they can additionally be displayed in the camera frame, aligned with the view of the scene.</p>"},{"location":"structures/floating_quantities/images/#image-origin","title":"Image Origin","text":"<p>When registering an image quantity, you can also specify whether the image should be interpreted such that the first row is the \u201ctop\u201d row of the image (<code>'upper_left'</code>), or the first row is the \u201cbottom\u201d row of the image (<code>'lower_left'</code>). This is a confusing issue, as there are many overlapping conventions of coordinate systems and buffer layouts for images.</p> <p>Most of the time, <code>'upper_left'</code> (the default) is the right choice.</p>"},{"location":"structures/floating_quantities/images/#scalar-image-quantity","title":"Scalar Image Quantity","text":"<p>These can be called at the root level, like <code>ps.add_scalar_image_quantity()</code>, or on a structure, like <code>cam_view.add_scalar_image_quantity()</code>.</p> <code>add_scalar_image_quantity(name, values, **kwargs)</code> <p>Add an image of scalar values</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>HxW</code> numpy array, with scalar values</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/images/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/floating_quantities/images/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/images/#color-image-quantity","title":"Color Image Quantity","text":"<p>These can be called at the root level, like <code>ps.add_color_image_quantity()</code>, or on a structure, like <code>cam_view.add_color_image_quantity()</code>.</p> <code>add_color_image_quantity(name, values_rgb, **kwargs)</code> <p>Add an image of rgb color values</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values_rgb</code> an <code>HxWx3</code> numpy array, with color values</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <code>add_color_alpha_image_quantity(name, values_rgba, **kwargs)</code> <p>Add an image of rgb color values</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values_rgba</code> an <code>HxWx4</code> numpy array, with color values</li> </ul> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>By default, alpha values are interpreted to be non-premultiplied. Use the keyword argument <code>is_premultiplied=True</code> to directly pass premultiplied alpha images.</p>"},{"location":"structures/floating_quantities/images/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/images/#image-options","title":"Image Options","text":"<p>These options are common to all images</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>transparency</code> float, an opacity to apply to the image</li> <li><code>image_origin</code> string, either <code>upper_left</code> (default) or <code>lower_left</code> to give the row layout convention</li> <li><code>show_fullscreen</code> boolean, if enabled the image will be shown fullscreen in the Polyscope window</li> <li><code>show_in_imgui_window</code> boolean, if enabled the image will be shown in an ImGui window</li> <li><code>show_in_camera_billboard</code> boolean, if this image was added to a camera view structure, show it in the camera frame</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/render_images/","title":"Render Images","text":"<p>Render images are special images which are renderings of scene through the Polyscope viewport. These are useful when using Polyscope to visualize renders from your own custom renderers, such as ray tracers, SDF-field implicit tracers, or neural field renderers.</p> <p>Render images always show the image in fullscreen viewport. Additional, depth and transparency allow the image to be composited with other scene content, so that you can still see your usual Polyscope meshes and point clouds in the scene along with the outputs of your renderer.</p> <p>Sample: A colored box and scalar torus, displayed as render images from a user\u2019s custom implicit surface renderer.</p> <p></p> <p>Floating Quantities</p> <p>Render images are floating quantities, which means they can be added to the scene at the root level, or added to any kind of structure.</p> <p>It is most common to add render image quantities at the root level. However, it might still be useful to add render images to structures, to associate the rendering with a particular structure, e.g. as a separate rendering of each point cloud in the scene.</p> <p>See the floating quantity introduction for more info.</p>"},{"location":"structures/floating_quantities/render_images/#image-origin","title":"Image Origin","text":"<p>When registering an image quantity, you can also specify whether the image should be interpreted such that the first row is the \u201ctop\u201d row of the image (<code>'upper_left'</code>), or the first row is the \u201cbottom\u201d row of the image (<code>'lower_left'</code>). This is a confusing issue, as there are many overlapping conventions of coordinate systems and buffer layouts for images.</p> <p>Most of the time, <code>'upper_left'</code> (the default) is the right choice.</p>"},{"location":"structures/floating_quantities/render_images/#depth-render-image-quantity","title":"Depth Render Image Quantity","text":"<p>A depth render image quantity takes a depth value per-pixel, and (optionally) a world-space normal per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nw = 1024\nh = 768\ndepths = np.zeros((h, w))\nnormals = np.ones((h, w, 3))\n\nps.add_depth_render_image_quantity(\"render_img\", depths, normals, \n                                   enabled=True, image_origin='upper_left', \n                                   color=(0., 1., 0.), material='wax', transparency=0.7,\n                                   allow_fullscreen_compositing=True)\n\npolyscope::show(3);\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <code>add_depth_render_image_quantity(name, depths, normals, **kwargs)</code> <p>Add a depth render image.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>HxW</code> numpy array, with scalar depth values</li> <li><code>normals</code> an <code>HxWx3</code> numpy array, with world-space normals values, or <code>None</code> to automatically compute normals</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#color-render-image-quantity","title":"Color Render Image Quantity","text":"<p>A color render image quantity takes a depth value per-pixel, (optionally) a world-space normal per-pixel, and a color value per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials, colored according to the given color.</p> <p>Color vs. Raw Color Render Images</p> <p>A color render image applies materials shading and lighting to the image, just like Polyscope usually does for meshes and other objects. A raw color render image does not do any additional shading, and simply displays the given colors directly onto the screen.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nw = 1024\nh = 768\ndepths = np.zeros((h, w))\nnormals = np.ones((h, w, 3))\ncolors = np.ones((h, w, 3))\n\nps.add_color_render_image_quantity(\"render_img\", depths, normals, colors, \n                                   enabled=True, image_origin='upper_left', \n                                   material='wax', transparency=0.7, )\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <code>add_color_render_image_quantity(name, depths, normals, colors, **kwargs)</code> <p>Add a depth render image, annotated with additional color values per-pixel.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>HxW</code> numpy array, with scalar depth values</li> <li><code>normals</code> an <code>HxWx3</code> numpy array, with world-space normals values, or <code>None</code> to automatically compute normals</li> <li><code>colors</code> an <code>HxWx3</code> numpy array, with colors</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/render_images/#scalar-render-image-quantity","title":"Scalar Render Image Quantity","text":"<p>A scalar render image quantity takes a depth value per-pixel, (optionally) a world-space normal per-pixel, and a scalar value per-pixel. The depth image will be rendered with surface shading using Polyscope\u2019s materials, with the scalar value shaded and colormapped as a scalar quantity.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nw = 1024\nh = 768\ndepths = np.zeros((h, w))\nnormals = np.ones((h, w, 3))\nscalars = np.ones((h, w))\n\nps.add_scalar_render_image_quantity(\"render_img3\", depths, normals, scalars, \n                                     enabled=True, image_origin='upper_left', \n                                     vminmax=(-3.,.3), cmap='reds')\n</code></pre></p> <p>If normals are not given, they will be computed internally via screen-space derivatives.</p> <code>ps.add_scalar_render_image_quantity(name, depths, normals, scalars, **kwargs)</code> <p>Add a depth render image, annotated with additional scalar values per-pixel.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>HxW</code> numpy array, with scalar depth values</li> <li><code>normals</code> an <code>HxWx3</code> numpy array, with world-space normals values, or <code>None</code> to automatically compute normals</li> <li><code>scalars</code> an <code>HxW</code> numpy array, with scalar values</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/floating_quantities/render_images/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/floating_quantities/render_images/#raw-color-render-image-quantity","title":"Raw Color Render Image Quantity","text":"<p>A raw color render image quantity takes a depth value per-pixel and a color value per-pixel. The colors will be directly displayed onscreen, with depth compositing into the scene.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nw = 1024\nh = 768\ndepths = np.zeros((h, w))\ncolors = np.ones((h, w, 3))\n\nps.add_raw_color_render_image_quantity(\"render_img3\", depths, colors, \n                                       enabled=True, allow_fullscreen_compositing=True)\n</code></pre></p> <p>Color vs. Raw Color Render Images</p> <p>A color render image applies materials shading and lighting to the image, just like Polyscope usually does for meshes and other objects. A raw color render image does not do any additional shading, and simply displays the given colors directly onto the screen.</p> <code>add_raw_color_render_image_quantity(name, depths, colors, **kwargs)</code> <p>Add a raw color render image described by pixel color and depth.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>HxW</code> numpy array, with scalar depth values</li> <li><code>colors</code> an <code>HxWx3</code> numpy array, with colors</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/floating_quantities/render_images/#raw-color-alpha-render-image-quantity","title":"Raw Color Alpha Render Image Quantity","text":"<p>Just like the above <code>ColorRenderImageQuantity</code>, but with an additional alpha channel which gets alpha-composited onto the scene.</p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\nw = 1024\nh = 768\ndepths = np.zeros((h, w))\ncolor_alphas = np.ones((h, w, 4))\n\nps.add_raw_color_alpha_render_image_quantity(\"render_img3\", depths, color_alphas, \n                                             enabled=True, image_origin='upper_left', \n                                             is_premultiplied=True)\n</code></pre></p> <code>add_raw_color_alpha_render_image_quantity(name, depths, color_alphas, **kwargs)</code> <p>Add a raw color render image described by RGBA pixel color and depth.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>depths</code> an <code>HxW</code> numpy array, with scalar depth values</li> <li><code>colors_alphas</code> an <code>HxWx4</code> numpy array, with colors</li> </ul> <p>Depth values should be radial ray distance from the camera origin, not perpendicular distance from the image plane.</p> <p>RGB values are interpreted in the range <code>[0,1]</code>.</p> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p> <p>By default, alpha values are interpreted to be non-premultiplied. Use <code>is_premultiplied=True</code> to directly pass premultiplied alpha images.</p>"},{"location":"structures/floating_quantities/render_images/#render-image-options","title":"Render Image Options","text":"<p>These options are common to all render images</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled </li> <li><code>transparency</code> float, an opacity to apply to the image</li> <li><code>image_origin</code> string, either <code>upper_left</code> (default) or <code>lower_left</code> to give the row layout convention</li> <li><code>material</code> string, material name for the surface rendering</li> <li><code>allow_fullscreen_compositing</code>, boolean, if <code>False</code> only one render image is displayed at a time (default), if <code>True</code>, multiple can be displayed and will layer on top of each other, although the render order is arbitrary</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>Raw color render images ignore material-related settings.</p>"},{"location":"structures/point_cloud/basics/","title":"Point Clouds","text":"<p>Point clouds are one of the core structures in Polyscope. In addition to simply displaying the points, Polyscope can show any number of scalar, vector, or color quantities associated with the points.</p> <p>As always, try clicking on a point to see the data associated with that point.</p> <p></p>"},{"location":"structures/point_cloud/basics/#registering-a-point-cloud","title":"Registering a point cloud","text":"<p>Example: a point cloud of random points <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# generate some points\npoints = np.random.rand(100, 3)\n\n# visualize!\nps_cloud = ps.register_point_cloud(\"my points\", points)\nps.show()\n\n# with some options\nps_cloud_opt = ps.register_point_cloud(\"my points\", points, \n                                       radius=0.02, point_render_mode='quad')\nps.show()\n</code></pre></p> <code>register_point_cloud(name, points, enabled=None, radius=None, point_render_mode=None, color=None, material=None)</code> <p>Add a new point cloud structure to Polyscope.</p> <ul> <li><code>name</code> is the name for the structure, as a string</li> <li><code>points</code> is an <code>N x 3</code> numpy array of point locations</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>radius</code> float, a size for the points relative to the scene length scale (use <code>set_radius(val, relative=False)</code> for absolute units)</li> <li><code>color</code> float 3-tuple, default color values for the points as rgb in [0,1]</li> <li><code>material</code> string, name of material to use for cloud</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>2D point clouds are also supported, see 2D data.</p> <p>As with all structures, there is also <code>get_point_cloud(\"name\")</code>, <code>has_point_cloud(\"name\")</code>, and <code>remove_point_cloud(\"name\")</code>.</p>"},{"location":"structures/point_cloud/basics/#updating-a-point-cloud","title":"Updating a point cloud","text":"<p>The locations of the points in a point cloud can be updated with the member function <code>update_point_positions(newPositions)</code>. All quantities will be preserved. Changing the number of points in the cloud is not supported, you will need to register a new cloud (perhaps with the same name to overwrite this one).</p> <p>Example: update positions (continued from above) <pre><code>new_pos = np.random.rand(100, 3)\nps_cloud.update_point_positions(new_pos)\nps.show()\n</code></pre></p> <code>PointCloud.update_point_positions(newPos)</code> <p>Update the point positions in a point cloud structure. <code>newPos</code> must be valid input as to initially construct a point cloud, with the same number of points.</p>"},{"location":"structures/point_cloud/basics/#adjusting-the-point-radius","title":"Adjusting the point radius","text":"<p>Set the radius of the points with <code>PointCloud.set_radius(newRad)</code>, or in the constructor. By default, the radius is a relative value which gets scaled by the content in the scene, so for example a default of <code>0.02</code> will always be a reasonable size no matter what the scale of the content in your scene is. Or, set <code>relative=False</code> to set an absolute radius in world units.</p> <code>PointCloud.set_radius(newVal, relative=True)</code> <p>Update the radius for points in the point cloud.</p> <p>By default the radius is interpreted as a relative value, setting <code>relative=False</code> will treat is as an absolute length in world units.</p> <p>To set a variable radius which is different for each point in the point cloud, see the variable radius page.</p>"},{"location":"structures/point_cloud/basics/#point-render-mode","title":"Point render mode","text":"<p>By default, Polyscope renders point clouds with a sphere for each point. However, for large point clouds (for instance, &gt; 500,000 points, or on low-end hardware), this sphere rendering may become prohibitively expensive and lead to a laggy interface. As an alternative, points can be rendered as a small quad per-point, which is more efficient (for instance, it renders in real-time with 20,000,000+ points on my mid-range GPU).</p> <p></p> <p>The point render mode setting specifies which style is used:</p> <ul> <li><code>sphere</code> a small sphere is drawn for each point (default)</li> <li><code>quad</code> a small quad is drawn for each point</li> </ul> <code>PointCloud.set_point_render_mode(newVal)</code> <p>Set the the rendering method used to draw each point. Pass the string name of the style to use. One of <code>'sphere'</code> (default) or <code>'quad'</code>.</p> <p>As usual, this can also be set as a keyword argument when the point cloud is registered, like <code>register_point_cloud('my points', data, point_render_mode='quad')</code>.</p> <p>There is also a corresponding <code>get_point_render_mode()</code>.</p>"},{"location":"structures/point_cloud/basics/#options","title":"Options","text":"<p>Options control the appearance of the cloud. These options can also be passed as keyword arguments to the initial <code>register_point_cloud()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? point radius size of rendered points <code>get_radius()</code> <code>set_radius(newVal, relative=True)</code> yes point color default color for points <code>get_color()</code> <code>set_color(newVal)</code> yes point render mode how to draw points <code>get_point_render_mode()</code> <code>set_point_render_mode(newVal)</code> yes material material for point <code>get_material()</code> <code>set_material(newVal)</code> yes <p>Example: set options which affect the appearance of the point cloud <pre><code>cloud = polyscope.register_point_cloud(\"my points\", points)\n\ncloud.set_enabled(False) # disable\ncloud.set_enabled() # default is true\n\ncloud.set_radius(0.02) # radius is relative to a scene length scale by default\ncloud.set_radius(1.7, relative=False) # radius in absolute world units\n\ncloud.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\ncloud.set_material(\"candy\")\ncloud.set_transparency(0.5)\n\n# alternately:\nps.register_point_cloud(\"my points 2\", points, enabled=False, material='candy',\n                        radius=0.02, color=(1., 0., 0.)\n                        transparency=0.5)\n</code></pre></p>"},{"location":"structures/point_cloud/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the points of a point cloud.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a point cloud\nN = 100\npoints = np.random.rand(N, 3)\nps_cloud = ps.register_point_cloud(\"my points\", points, enabled=True)\n\n# generate some random color per-point\nvals = np.random.rand(N,3)\n\n# basic color visualization\nps_cloud.add_color_quantity(\"rand colors\", vals)\n\nps.show() \n</code></pre></p> <code>PointCloud.add_color_quantity(name, values, enabled=None)</code> <p>Add a color quantity to the point cloud.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at points</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/point_cloud/parameterization_quantities/","title":"Parameterization Quantities","text":"<p>A parameterization is a set of 2D coordinates associated with a surface, often referred to as \u201cUV coordinates\u201d. </p> <p>Typically parameterizations are used on meshes (which is also supported in Polyscope!) but at times it may be useful to visualize a parameterization at the points of a point cloud.</p>"},{"location":"structures/point_cloud/parameterization_quantities/#adding","title":"Adding","text":"<code>PointCloud.add_parameterization_quantity(name, values, coords_type='unit', enabled=None, viz_style=None, grid_colors=None, checker_colors=None, checker_size=None, cmap=None)</code> <p>Add a parameterization quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx2</code> numpy array, coordinates at vertices/corners</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/parameterization_quantities/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>viz_style</code> option determines how parameterizations are visualized:</p> <ul> <li><code>checker</code>: a two-color checker pattern</li> <li><code>grid</code>: a two-color grid with thin lines</li> <li><code>local_check</code>: a checkerboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>local_rad</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul>"},{"location":"structures/point_cloud/parameterization_quantities/#types","title":"Types","text":"<p>The <code>coords_type</code> options determines how parameter coordinates are interpreted for scaling:</p> <ul> <li><code>unit</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>world</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul>"},{"location":"structures/point_cloud/parameterization_quantities/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>When adding a parameterization quantity, the following keyword options can be set. These are available for all kinds of parameterization quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>coords_type</code> string, one of <code>'unit'</code>, <code>'world'</code>  (see above)</li> <li><code>viz_style</code> string, one of <code>'checker'</code>, <code>'grid'</code>, <code>'local_check'</code>, <code>'local_rad'</code> (see above)</li> <li><code>grid_colors</code> 2-tuple of rgb colors, used to color the grid visualization</li> <li><code>checker_colors</code> 2-tuple of rgb colors, used to color the checkerboard visualization</li> <li><code>checker_size</code> float, the size of checkers/grid/stripes</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/point_cloud/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the points of a point cloud.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a point cloud\nN = 100\npoints = np.random.rand(N, 3)\nps_cloud = ps.register_point_cloud(\"my points\", points)\n\n# generate some random data per-point\nvals = np.random.rand(N)\n\n# basic visualization\nps_cloud.add_scalar_quantity(\"rand vals\", vals)\n\n# manually specify a range for colormapping\nps_cloud.add_scalar_quantity(\"rand vals with range\", vals, vminmax=(-5., 5.), enabled=True)\n\n# use a different colormap\nps_cloud.add_scalar_quantity(\"rand vals with range\", vals, cmap='blues')\n\n# use the 'datatype' to specify default visualization semantics\nvals_gaussian = np.random.normal(size=N)\nps_cloud.add_scalar_quantity(\"gaussian vals symmetric\", vals_gaussian, datatype='symmetric')\n\n# view the point cloud with all of these quantities\nps.show() \n</code></pre></p> <code>PointCloud.add_scalar_quantity(name, values, enabled=None, datatype=\"standard\", vminmax=None, cmap=None)</code> <p>Add a scalar quantity to the point cloud.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at points</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/scalar_quantities/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/point_cloud/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/point_cloud/variable_radius/","title":"Variable Radius","text":"<p>By default, all points in the cloud have the same radius. However, any point cloud scalar quantity can be additionally interpreted as the radius of the points. This can also be set manually in the GUI via the point cloud <code>[Options] --&gt; [Variable Radius]</code>.</p> <p></p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\n# ... setup, register a point cloud, etc ...\n\n# Get a reference to your point cloud\nps_cloud = ps.get_point_cloud(\"your point cloud name\")\n\n# Add a random scalar quantity\nN = ps_cloud.n_points()\nvals = np.random.rand(N)\nps_cloud.add_scalar_quantity(\"test_vals\", vals)\n\n# Set the quantity as the point size\nps_cloud.set_point_radius_quantity(\"test_vals\")\nps.show()\n\n# Clear it out, go back to default constant size\nps_cloud.clear_point_radius_quantity()\nps.show()\n\n# Set the quantity as the size using actual world-coordinate units,\n# rather than auto-scaling the size\nps_cloud.set_point_radius_quantity(\"test_vals\", autoscale=False)\nps.show()\n</code></pre></p> <p>Any negative values in the scalar quantity will be clamped to <code>0</code>. By default, values will be rescaled such that the largest corresponds to the size from the point radius option (thus, using any constant scalar quantity will make the radii identical to the default value with no radius set). This automatic scaling can be disabled by setting <code>autoscale=False</code> below.</p> <p>Reproducing radius in world units</p> <p>Remember that point clouds always have a per-structure <code>radius</code> parameter which sets a radius for all of the points in the point cloud (and can be adjusted via a slider in the GUI, or via <code>radius=0.1</code>/<code>set_radius()</code>). This per-structure parameter makes things a little more complicated when also setting length via a scalar quantity as described here.</p> <p>By default, the structure radius parameter is still respected. The variable radius from the quantity first scaled such that the largest value is <code>1.</code>, and then is multiplied by the structure parameter to get the actual radius used for the points.</p> <p>This usually gives a reasonable visualization, but makes it difficult to set a precise radius in world units.  To properly reproduce a radius in world-coordinate units, you can circumvent autoscaling like <code>cloud.set_point_radius_quantity(q, autoscale=False)</code>. This will prevent the auto-scaling of the radii, and also ignore the structure\u2019s point radius parameter.</p> <code>PointCloud.set_point_radius_quantity(quantity_name, autoscale=True)</code> <p>Set the point radius from a quantity by name. The quantity must be a point cloud scalar quantity added to this cloud.</p> <p>When using a radius which is a physical length in world coordinates, set <code>autoscale</code> to <code>False</code> to skip rescaling and ignore the structure\u2019s point radius parameter.</p> <code>PointCloud.clear_point_radius_quantity()</code> <p>Clear the point radius quantity and return to using the constant radius.</p>"},{"location":"structures/point_cloud/variable_transparency/","title":"Variable Transparency","text":"<p>You can set the transparency individually for each point in a point cloud by specifing an existing scalar quantity to serve as the transparency. This can also be set manually in the GUI via the point cloud <code>[Options] --&gt; [Variable Transparency]</code> setting.</p> <p>See the transparency section for more transparency-related options.</p> <p></p> <p>Example: <pre><code>import polyscope as ps\nimport numpy as np\n\n# ... setup, register a point cloud, etc ...\n\n# Get a reference to your point cloud\nps_cloud = ps.get_point_cloud(\"your point cloud name\")\n\n# Add a random scalar quantity\nN = ps_cloud.n_points()\nvals = np.random.rand(N)\nps_cloud.add_scalar_quantity(\"test_vals\", vals)\n\n# Set the quantity as the point transparency\nps_cloud.set_transparency_quantity(\"test_vals\")\nps.show()\n\n# Clear it out, go back to default constant size\nps_cloud.clear_transparency_quantity()\nps.show()\n</code></pre></p> <p>All values will be clamped into the <code>[0,1]</code> range. The transparency is multiplicative with any other transparency effects, such as setting the structure\u2019s global transparency value.</p> <code>PointCloud.set_transparency_quantity(quantity_name)</code> <code>PointCloud.clear_transparency_quantity()</code>"},{"location":"structures/point_cloud/variable_transparency/#set-transparency-quantity","title":"set transparency quantity","text":"<p>Set the transparency quantity by name. The quantity must be a point cloud scalar quantity added to this cloud.</p> <p>All values will be clamped into the <code>[0,1]</code> range.</p> <p>If transparency is not already enabled, updates the transparency mode to be <code>Pretty</code>.</p>"},{"location":"structures/point_cloud/variable_transparency/#clear-transparency-quantity","title":"clear transparency quantity","text":"<p>Clear the transparency quantity.</p>"},{"location":"structures/point_cloud/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the points of a point cloud.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a point cloud\nN = 100\npoints = np.random.rand(N, 3)\nps_cloud = ps.register_point_cloud(\"my points\", points)\n\n# generate some random vectors per-point\nvecs = np.random.rand(N, 3)\n\n# basic visualization\nps_cloud.add_vector_quantity(\"rand vecs\", vecs, enabled=True)\n\n# set radius/length/color of the vectors\nps_cloud.add_vector_quantity(\"rand vecs\", vecs, radius=0.001, length=0.005, color=(0.2, 0.5, 0.5))\n\n# ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space\nps_cloud.add_vector_quantity(\"vecs ambient\", vecs, vectortype='ambient')\n\n# view the point cloud with all of these quantities\nps.show() \n</code></pre></p> <code>PointCloud.add_vector_quantity(name, values, enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the point cloud.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at points (or <code>Nx2</code> for 2D data)</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/point_cloud/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> <li><code>material</code> string, shading material for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/basics/","title":"Surface Meshes","text":"<p>Surface meshes are one of the core structures in Polyscope. In addition to simply displaying the mesh, Polyscope can show any number of scalar, vector,color, and other kinds of quantities associated with the vertices/faces/etc of the mesh.</p> <p>Polyscope does not impose any requirements on the meshes visualized. They may be polygonal or nonmanifold, and all faces need not have the same degree.  As always, try clicking on the vertices or faces of a mesh see the data associated with that mesh element.</p> <p></p>"},{"location":"structures/surface_mesh/basics/#registering-a-surface-mesh","title":"Registering a surface mesh","text":"<p>Example: registering a mesh <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nvertices = np.random.rand(100, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, 100, size=(250,3)) # (F,3) array of indices \n                                                # for triangular faces\n\n# visualize!\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\nps.show()\n</code></pre></p> <p>Surface meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each face.</p> <code>register_surface_mesh(name, vertices, faces, enabled=None, color=None, edge_color=None, smooth_shade=None, edge_width=None, material=None)</code> <p>Add a new surface mesh structure to Polyscope.</p> <ul> <li><code>name</code> string, a name for the structure</li> <li><code>vertices</code>, an <code>Nx3</code> numpy float array of vertex locations (or <code>Nx2</code> for 2D)</li> <li><code>faces</code>, an <code>FxD</code> numpy integer array of faces, as 0-based indices in to the vertices array, OR a plain python list-of-lists of indices (or really, anything twice-iterable which yields integers). The latter option enables meshes where not all faces have the same degree.</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>color</code> float 3-tuple, default color values for the mesh as rgb in [0,1]</li> <li><code>edge_color</code> float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set <code>edge_width</code> too)</li> <li><code>edge_width</code> float, width of edges in rendered mesh; default sets <code>0</code> to disable edges, <code>1</code> is a reasonable value to enable</li> <li><code>smooth_shade</code> boolean, if <code>True</code> use smooth shading (default: <code>False</code> for flat shading)</li> <li><code>material</code> string, name of material to use for the mesh</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>2D vertex positions are also supported, see 2D data.</p> <p>Element ordering</p> <p>Polyscope quantities are ordered arrays of data, but not everyone can agree on the ordering of elements in a mesh. See indexing conventions.</p> <p>The default ordering is probably the same as yours for data on vertices, faces, and corners. However, data on edges and halfedges is much more likely to require setting an ordering.</p>"},{"location":"structures/surface_mesh/basics/#updating-a-mesh","title":"Updating a mesh","text":"<p>The locations of the vertices in a mesh can be updated with the member function <code>update_vertex_positions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite).</p> <code>SurfaceMesh.update_vertex_positions(newPos)</code> <p>Update the vertex positions in a surface mesh structure. <code>newPos</code> must be valid input as to initially construct the vertex positions, with the same number of vertices.</p>"},{"location":"structures/surface_mesh/basics/#picking-and-selection","title":"Picking and Selection","text":"<p>\u201cPicking\u201d refers to selecting and inspecting elements by clicking on the object in the scene.  See the section on picking for more info.</p> <p>Additional information about a pick which hits a mesh can be retrieved from the <code>PickResult.structure_data</code> dictionary field.</p> <p>We can also set which mesh elements are selectable (for instance, to make only vertices be returned from pick queries). This option can be set programmatically as <code>SurfaceMesh.set_selection_mode(newMode)</code>, or from the UI. The available selection modes are:</p> <ul> <li> <p><code>\"auto\"</code>: Vertices and faces can always be selected. Edges, corners, halfedges can only be selected once they are in-use by some quantity. You can manually call <code>SurfaceMesh.mark_edges_as_used()</code>, to act as if edges are in use and make them pickable, etc. The same goes for <code>SurfaceMesh.mark_corners_as_used()</code> and <code>SurfaceMesh.mark_halfedges_as_used()</code>. If you mark edges or halfedges as used, you much also set their element ordering as described in the indexing conventions.</p> </li> <li> <p><code>\"vertices_only\"</code>: Only vertices can be selected</p> </li> <li> <p><code>\"faces_only\"</code>: Only faces can be selected</p> </li> </ul>"},{"location":"structures/surface_mesh/basics/#back-face-policies","title":"Back face policies","text":"<p>The faces of a mesh are implicitly given an outward orientation by the order in which the vertices are listed. The standard convention, which Polyscope respects, is that a counter-clockwise ordering of vertices defines the \u201coutward\u201d direction. Faces which are viewed from behind are referred to as back faces; they can arise when a surface is viewed from the inside, or if a mesh is not properly oriented. Polyscope offers several options for how back faces are displayed.</p> <p></p> <ul> <li><code>identical</code> all faces are always rendered identically, whether viewed from the front or back</li> <li><code>different</code> back faces are shaded slightly darker, so they can be distinguished (this is the default)</li> <li><code>custom</code> back faces are shaded with a configurable color</li> <li><code>cull</code> back faces are culled, and not rendered at all</li> </ul> <p>The choice of these policies can be set as an option for each surface mesh structure, either in the GUI via <code>[Options] -&gt; [Back Face Policy]</code> or programmatically with the function below or when a mesh is registered.</p> <code>SurfaceMesh.set_back_face_policy(val)</code> <p>Set the policy for rendering oppositely-oriented back faces.</p> <ul> <li><code>newPolicy</code> is string giving the new policy, one of <code>identical</code>, <code>different</code>, <code>custom</code>, or <code>cull</code> as described above</li> </ul> <p>You can also set <code>back_face_policy='cull'</code> when registering a mesh.</p> <p>There is also a corresponding <code>SurfaceMesh.get_back_face_policy()</code>.</p> <code>SurfaceMesh.set_back_face_color(val)</code> <p>Set the color to be used for custom back face coloring as a 3-tuple of floats on [0,1]. Has no effect unless the back face policy is <code>custom</code>.</p> <p>There is also a corresponding <code>get_back_face_color()</code>.</p>"},{"location":"structures/surface_mesh/basics/#options","title":"Options","text":"<p>Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial <code>register_surface_mesh()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? surface color the color of the mesh <code>get_color()</code> <code>set_color(val)</code> yes edge color the color of the edges of the mesh <code>get_edge_color()</code> <code>set_edge_color(val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>get_edge_width()</code> <code>set_edge_width(val)</code> yes shade smooth use smooth shading along faces or simple flat faces <code>get_smoooth_shade()</code> <code>set_smooth_shade(isSmooth)</code> yes material material for structure <code>get_material()</code> <code>set_material(newVal)</code> yes back face policy what back face policy to use <code>get_back_face_policy()</code> <code>set_back_face_policy(val)</code> yes back face color back face color for the <code>custom</code> policy <code>get_back_face_color()</code> <code>set_back_face_color(val)</code> yes selection mode what elements can be selected <code>get_selection_mode()</code> <code>set_selection_mode(val)</code> yes <p>Example: set options which affect the appearance of the mesh <pre><code>import numpy as np\nimport polyscope as ps\n\nvertices = np.random.rand(100, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, 100, size=(250,3)) # (F,3) array of indices \n                                                # for triangular faces\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\nps_mesh.set_enabled(False) # disable\nps_mesh.set_enabled() # default is true\n\nps_mesh.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\nps_mesh.set_edge_color((0.8, 0.8, 0.8)) \nps_mesh.set_edge_width(1.0)\nps_mesh.set_smooth_shade(True)\nps_mesh.set_material(\"candy\")\nps_mesh.set_transparency(0.5)\n\n# alternately:\nps.register_surface_mesh(\"my mesh2\", vertices, faces, enabled=False, \n                         color=(1., 0., 0.), edge_color=((0.8, 0.8, 0.8)),\n                         edge_width=1.0, smooth_shade=True,\n                         material='candy', transparency=0.5)\n</code></pre></p>"},{"location":"structures/surface_mesh/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the elements of a surface mesh.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# visualize some random data per-vertex\ncolors_vert = np.random.rand(N_vert, 3)\nps_mesh.add_color_quantity(\"rand colors\", colors_vert, enabled=True)\n\n# visualize some random data per-face\ncolors_face = np.random.rand(N_face, 3)\nps_mesh.add_color_quantity(\"rand colors2\", colors_face, defined_on='faces')\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p>"},{"location":"structures/surface_mesh/color_quantities/#add-colors-to-elements","title":"Add Colors to Elements","text":"<code>SurfaceMesh.add_color_quantity(name, values, defined_on='vertices', enabled=None, param_name=None, image_origin=\"upper_left\")</code> <p>Add a color quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at vertices/faces</li> <li><code>defined_on</code> string, one of <code>'vertices','faces','texture'</code>, is this data a color per vertex, per face, or texture image?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p> <p>The <code>param_name</code> and <code>image_origin</code> arguments are used only if <code>defined_on='texture'</code>. See below for details.</p>"},{"location":"structures/surface_mesh/color_quantities/#color-texture-maps","title":"Color Texture Maps","text":"<p>Texture images define data by storing it an image grid, and using coordinates defined on the face-corners or vertices of a mesh to sample values from the image for each point on the surface.</p> <p>To visualize color data defined in texture maps, first add a Parameterization Quantity (aka UV map) defining the coordinates. Then, add a buffer of image data to be sampled from.</p> <p>Example <pre><code>import numpy as np\nimport polyscope as ps\n\nps.init()\n\n# add a mesh\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3)\nfaces = np.random.randint(0, N_vert, size=(N_face,3))\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# add a parameterization (aka UV map)\nparam_vals = np.random.rand(ps_mesh.n_vertices(), 2)\nps_mesh.add_parameterization_quantity(\"test_param\", param_vals, \n                                      defined_on='vertices', enabled=True)\n\n# add the texture quantity\ndims = (200,300,3)\ncolor_vals = np.random.rand(*dims) # dummy placeholder image data\nps_mesh.add_color_quantity(\"test_vals\", color_vals, \n                           defined_on='texture', param_name=\"test_param\", filter_mode='nearest', enabled=True)\n\nps.show()\n</code></pre></p> <p>Texture image data is added via <code>add_color_quantity()</code>, with <code>defined_on='texture'</code> and <code>param_name=...</code> specifying the name of the parameterization UV map with coordinates on <code>[0,1]</code> which will be used to sample from the image.</p> <p>The texture image data, dimension, and origin conventions are the same as those used to define images. See there for details.</p> <p>The filter mode can be set as an additional argument to adjust how values are sampled from the texture. <code>filter_mode='linear'</code> (default) will smoothly linearly interpolate values, while <code>filter_mode='nearest'</code> will use nearest-neighbor sampling, which can be useful for sharp edges and crisp boundaries.</p>"},{"location":"structures/surface_mesh/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/distance_quantities/","title":"Distance quantities","text":"<p>Visualize distance-valued data at the elements of a surface mesh.</p> <p>Distance quantities are basically scalars, but are visualized with alternating stripes to show distance contours.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\ndists = # your distances, a length N_vert array\n\n# visualize the distance\nps_mesh.add_distance_quantity(\"distances\", dists, enabled=True, stripe_size=0.01)\n\n# use defaults for signed distances\nps_mesh.add_distance_quantity(\"signed distances\", dists, signed=True)\n\n# view the mesh with these quantities\nps.show() \n</code></pre></p> <code>SurfaceMesh.add_distance_quantity(name, values, defined_on='vertices', enabled=None, signed=False, vminmax=None, stripe_size=None, stripe_size_relative=True, cmap=None)</code> <p>Add a distance quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, distance scalars </li> <li><code>defined_on</code> for now, only <code>'vertices'</code> is supported</li> <li><code>signed</code> boolean, if true the data is assumed to represent signed distances, and symmetric ranges/colormaps are used by default</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>vminmax</code> a 2-tuple of floats, specifying the min and max range to colormap in to</li> <li><code>stripe_size</code> float, the width of stripes in the visualization</li> <li><code>stripe_size_relative</code> boolean, if true <code>stripe_size</code> is interpreted relative to the scene length scale, otherwise absolute</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/indexing_convention/","title":"Indexing Convention","text":""},{"location":"structures/surface_mesh/indexing_convention/#default-ordering","title":"Default ordering","text":"<p>Polyscope abstracts over data types by accepting generic ordered containers of data to visualize (see input adaptors). Unfortunately, not everyone can agree on how to order the elements of their meshes\u2014which edge is the i\u2019th edge in a mesh?</p> <p>For vertices and faces, Polyscope only supports one order: the order of the elements used when you registered the mesh. However, for edges, halfedges, and corners it is more complicated. For these data, you should generally explicitly tell Polyscope what ordering/indexing you will be using for the data.</p> <p>The way it works is that Polyscope defines a default ordering of mesh elements. If you happen to use the same ordering, everything will \u201cjust work\u201d, and you can simply call the relevant functions as you see in the tutorials and examples. However, if you happen to a different convention for ordering some mesh element, visualizations of data on that element will not work correctly out of the box\u2014your data arrays will be associated with the wrong mesh elements.</p> <p>This section describes the remedy: you can give the mesh a \u201cpermutation\u201d, which will be used to translate from the indexing conventions of your data to the indexing conventions of Polyscope. In general, this permutation <code>p</code> should be an array of integers, such that if <code>i</code> is the i^\\textrm{th} element in the default ordering, <code>p[i]</code> gives the index under your convention. Your data arrays will then be indexed as <code>data[p[i]]</code> when passed as arguments to surface mesh visualization functions. In fact, your indexing convention need not even have the same number of elements as the Polyscope convention, so long as <code>data[p[i]]</code> is always a valid access; if the size of your index space is different, a size can also be passed in (in this case we abuse terminology: it is not technically a permutation).</p> <p>The sections below define the default ordering of mesh elements, and show how to set an alternate permutation for each if the default ordering does not match your ordering.</p>"},{"location":"structures/surface_mesh/indexing_convention/#vertices-and-faces","title":"Vertices and Faces","text":"<p>For vertices and faces, Polyscope only supports one order: the order of the elements used when you registered the mesh. This order is always used automatically.</p>"},{"location":"structures/surface_mesh/indexing_convention/#edges","title":"Edges","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The edge ordering is defined from this list by the first time an edge appears in any face. More formally, the ordering is equivalent to the following C++ code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\nsize_t vertex_B = face[ (i+1) % faceDegree ];\n\n// emit edge (vertex_A, vertex_B), if neither it nor the \n// equivalent edge (vertex_B, vertex_A) has been emitted already\n}\n}\n</code></pre> The default ordering of edges is the order in which they would be emitted by this loop.</p> <p>For edge-valued data, a permutation must be set. This is a sanity check to catch errors; for edges, it is highly unlikely that users happen to be storing their data in the same order.</p> <code>SurfaceMesh.set_edge_permutation(perm, expected_size=None)</code> <p>Set a non-standard ordering for edge-valued data on a mesh.</p> <p>The argument <code>perm</code> should be an array of integers.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>perm</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#halfedges","title":"Halfedges","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The halfedge ordering is defined from this list by first ordering by the faces, then ordering by the halfedges within each face.  More formally, the ordering is equivalent to the following C++ code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\nsize_t vertex_B = face[ (i+1) % faceDegree ];\n\n// emit halfedge (vertex_A, vertex_B)\n}\n}\n</code></pre> The default ordering of halfedges is the order in which they would be emitted by this loop.</p> <p>Arrays of halfedge-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below.</p> <code>SurfaceMesh.set_halfedge_permutation(perm, expected_size=None)</code> <p>Set a non-standard ordering for halfedge-valued data on a mesh.</p> <p>The argument <code>perm</code> should be an array of integers.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>perm</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#corners","title":"Corners","text":"<p>The second argument when registering a surface mesh with Polyscope is a list of face indices.  The corner ordering is defined from this list by first ordering by the faces, then ordering by the corners within each face.  More formally, the ordering is equivalent to the following C++ code:</p> <p><pre><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; faceIndices;\nfor(std::vector&lt;size_t&gt; face : faceIndices) {\n\nsize_t faceDegree = face.size();\n\nfor(size_t i = 0; i &lt; faceDegree; i++) {\n\nsize_t vertex_A = face[ i ];\n\n// emit corner in this face incident on vertex_A\n}\n}\n</code></pre> The default ordering of corners is the order in which they would be emitted by this loop.</p> <p>Arrays of corner-valued data passed for visualization will be interpreted in that order, unless an alternate permutation is set as below.</p> <code>SurfaceMesh.set_corner_permutation(perm, expected_size=None)</code> <p>Set a non-standard ordering for corner-valued data on a mesh.</p> <p>The argument <code>perm</code> should be an array of integers.</p> <p>If the size of your index space is different from size of the default index space, the optional second argument must give this new size. If not given, the size will be inferred from the largest entry in <code>perm</code>.</p> <p>Must be set before any quantites are added.</p>"},{"location":"structures/surface_mesh/indexing_convention/#all-at-once","title":"All at once","text":"<p>As a convenience, you can alternately use a single function which passes all permutations needed at the same time. This might ease writing a single helper function which defines any necessary permutations for the mesh convention in your codebase.</p> <code>SurfaceMesh.set_all_permutations(edge_perm=None, edge_perm_size=None, corner_perm=None, corner_perm_size=None, halfedge_perm=None, halfedge_perm_size=None)</code> <p>Any non-<code>None</code> keyword arguments will simply be forwarded to the appropriate <code>set_XXX_permutation()</code> variant as above.</p>"},{"location":"structures/surface_mesh/misc_quantities/","title":"Misc quantities","text":""},{"location":"structures/surface_mesh/misc_quantities/#surface-graph-quantity","title":"Surface Graph Quantity","text":"<p>The surface graph quantity is a collection of nodes and straight-line edges between them. Each node is given as a position in 3D space\u2014this quantity does not really have any relationship to the underlying surface, execpt that it is managed as a surface quantity.</p> <p>Nodes will be drawn as spheres, and the connecting edges drawn as cylinders. This quantity can be useful for visualizing paths on the surface, or wireframes.</p> <p>Example: drawing mesh\u2019s dual with geometry-central.</p> <p></p> <pre><code>#include \"polyscope/surface_mesh.h\"\n\n// geometry-central things\ngeom-&gt;requireFaceIndices();\n\nstd::vector&lt;Vector3&gt; positions;\nstd::vector&lt;std::array&lt;size_t, 2&gt;&gt; edgeInds;\n\n// Build the node positions\nfor (Face f : mesh-&gt;faces()) {\n\n// Compute center for face\nVector3 c = Vector3::zero();\nfor (Vertex v : f.adjacentVertices()) {\nc += geom-&gt;inputVertexPositions[v];\n}\nc /= f.degree();\n\npositions.push_back(c);\n}\n\n// Build the edge indices\nfor (Edge e : mesh-&gt;edges()) {\n\n// Connect the nodes from the two faces adjacent to each edge\nsize_t fa = geom-&gt;faceIndices[e.halfedge().face()];\nsize_t fb = geom-&gt;faceIndices[e.halfedge().twin().face()];\n\nedgeInds.push_back({fa, fb});\n}\n\npolyscope::getSurfaceMesh(\"my mesh\")-&gt;\naddSurfaceGraphQuantity(\"dual graph\", positions, edgeInds);\n</code></pre> <code>SurfaceMesh::addSurfaceGraphQuantity(std::string name, const P&amp; nodes, const E&amp; edges)</code> <p>Add a new surface graph quantity to the structure.</p> <ul> <li><code>nodes</code> is the list of 3D positions for the graph nodes. The type should be adaptable to a list of <code>float</code>-valued 3-vectors.</li> <li><code>edges</code> is the list of edges for the graph, where each entry is two 0-based indices in to the <code>nodes</code> array. The type should be adaptable to a list of <code>size_t</code>-valued 2-vectors (aka pairs of indices).</li> </ul> <p>The resulting class has <code>color</code> and <code>radius</code> fields which can be set to adjust the appearance of the resulting graph.</p>"},{"location":"structures/surface_mesh/misc_quantities/#options","title":"Options","text":"Parameter Meaning Getter Setter Persistent? enabled is the quantity enabled? <code>bool isEnabled()</code> <code>setEnabled(bool newVal)</code> yes radius the radius the graph is drawn with <code>double getRadius()</code> <code>setRadius(double val, bool isRelative=true)</code> yes color the color to draw the graph with <code>glm::vec3 getVectorColor()</code> <code>setVectorColor(glm::vec3 val)</code> yes <p>(all setters return <code>this</code> to support chaining. setEnabled() returns generic quantity, so chain it last)</p>"},{"location":"structures/surface_mesh/parameterization_quantities/","title":"Parameterization Quantities","text":"<p>A parameterization is a set of 2D coordinates associated with a mesh, often referred to as \u201cUV coordinates\u201d. This sections details several functions for visualizing such parameterizations.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# parameterization per vertex\nparam_vert = np.random.rand(N_vert,2)\nps_mesh.add_parameterization_quantity(\"rand param\", param_vert, enabled=True)\n\n# parameterization per corner\nparam_corner = np.random.rand(ps_mesh.n_corners(),2)\nps_mesh.add_parameterization_quantity(\"rand param corner\", param_corner, defined_on='corners')\n\n# use options to customize visualization\nps_mesh.add_parameterization_quantity(\"rand param corner2\", param_corner, defined_on='corners',\n                                       coords_type='world', viz_style='local_rad')\n\n\n# with custom checker/grid color\ncA = (0.1, 0.2, 0.3)\ncB = (0.4, 0.5, 0.6)\nps_mesh.add_parameterization_quantity(\"rand param corner3\", param_corner, defined_on='corners',\n                                       coords_type='unit', viz_style='grid', grid_colors=(cA, cB))\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p> <code>SurfaceMesh.add_parameterization_quantity(name, values, defined_on='vertices', coords_type='unit', enabled=None, viz_style=None, grid_colors=None, checker_colors=None, checker_size=None, cmap=None, island_labels=None, create_curve_network_from_seams=None)</code> <p>Add a parameterization quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx2</code> numpy array, coordinates at vertices/corners</li> <li><code>defined_on</code> one of <code>'vertices','corners'</code>, is this a coordinate per vertex or per corner?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/parameterization_quantities/#visualizing-islands-and-seams","title":"Visualizing islands and seams","text":"<p>For parameterizations on surface meshes, additional features are available to visualize UV island and seams. The term islands refers to connected components of faces in the 2D parameterization, and the term seams refers to the subset of edges separating adjacent faces which are not connected.</p> <p>UV islands can be colored per-island with the <code>viz_style=\"checker_islands\"</code> style. Each face should have a distinct integer indicating which island it is a part of, which the caller must compute and pass via the optional argument below (Polyscope does not compute it automatically). </p> <code>SurfaceMesh.add_parameterization_quantity(..., island_labels=island_labels)</code> <p>Additionally, the seams of a parameterization can be visualized as a curve network. These seams are computed automatically by Polyscope, the curve network is created by calling the function below, and is otherwise an ordinary curve network.</p> <code>SurfaceMesh.add_parameterization_quantity(..., create_curve_network_from_seams=\"seam_curves\")</code>"},{"location":"structures/surface_mesh/parameterization_quantities/#island_labels","title":"island_labels","text":"<p>Set an integer value per-face of the mesh, which can be used to color islands distinctly in the <code>\"checker_islands\"</code> style. Each face should have an integer indicating which island it is a part of, numbered however you like.</p> <p>Technically this can be any integer per-face, although it is generally useful for visualizing islands.</p> <ul> <li><code>island_labels</code> is the array of face labels, an <code>Fx1</code> numpy array of integers per-face</li> </ul> <p>This will have no effect unless you also set <code>viz_style=\"checker_islands\"</code>.</p>"},{"location":"structures/surface_mesh/parameterization_quantities/#createcurvenetworkfromseams","title":"createCurveNetworkFromSeams","text":"<p>Create a curve network from the seams of a UV map.</p> <ul> <li><code>create_curve_network_from_seams</code> is the string name of the the curve network quantity that will be created. Passing <code>\"\"</code> generates a default fname</li> </ul>"},{"location":"structures/surface_mesh/parameterization_quantities/#styles","title":"Styles","text":"<p>Several styles are available for how a parameterization is displayed. </p> <p>The <code>viz_style</code> option determines how parameterizations are visualized:</p> <ul> <li><code>checker</code>: a two-color checker pattern</li> <li><code>grid</code>: a two-color grid with thin lines</li> <li><code>local_check</code>: a checkerboard over a radial colormap, centered around <code>(0,0)</code></li> <li><code>local_rad</code>: distance stripes over a radial colormap, centered around <code>(0,0)</code></li> </ul>"},{"location":"structures/surface_mesh/parameterization_quantities/#types","title":"Types","text":"<p>The <code>coords_type</code> options determines how parameter coordinates are interpreted for scaling:</p> <ul> <li><code>unit</code>: UV coords are assumed to lie on the <code>[0,1]</code> interval</li> <li><code>world</code>: UV coords are assumed to be scaled like the world-space positions of the mesh</li> </ul>"},{"location":"structures/surface_mesh/parameterization_quantities/#parameterization-quantity-options","title":"Parameterization Quantity Options","text":"<p>When adding a parameterization quantity, the following keyword options can be set. These are available for all kinds of parameterization quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantity can be shown at a time; the most recent will be used)</li> <li><code>coords_type</code> string, one of <code>'unit'</code>, <code>'world'</code>  (see above)</li> <li><code>viz_style</code> string, one of <code>'checker'</code>, <code>'grid'</code>, <code>'local_check'</code>, <code>'local_rad'</code> (see above)</li> <li><code>grid_colors</code> 2-tuple of rgb colors, used to color the grid visualization</li> <li><code>checker_colors</code> 2-tuple of rgb colors, used to color the checkerboard visualization</li> <li><code>checker_size</code> float, the size of checkers/grid/stripes</li> <li><code>cmap</code> string, which colormap to use</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the elements of a surface mesh.</p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# visualize some random data per-vertex\nvals_vert = np.random.rand(N_vert)\nps_mesh.add_scalar_quantity(\"rand vals\", vals_vert, enabled=True)\n\n# visualize some random data per-face\nvals_face = np.random.rand(N_face)\nps_mesh.add_scalar_quantity(\"rand vals2\", vals_face, defined_on='faces')\n\n# visualize some random data per-edge (halfedges are also supported)\nvals_edge = np.random.rand(ps_mesh.n_edges())\nps_mesh.add_scalar_quantity(\"rand vals3\", vals_edge, defined_on='edges')\n\n# as always, we can customize the initial appearance\nps_mesh.add_scalar_quantity(\"rand vals3 opt\", vals_edge, defined_on='edges', \n                            enabled=True, vminmax=(-3., 3.), cmap='reds')\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p>"},{"location":"structures/surface_mesh/scalar_quantities/#add-scalars-to-elements","title":"Add Scalars to Elements","text":"<code>SurfaceMesh.add_scalar_quantity(name, values, defined_on='vertices', enabled=None, datatype=\"standard\", vminmax=None, cmap=None, param_name=None, image_origin=\"upper_left\")</code> <p>Add a scalar quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at vertices/faces/etc</li> <li><code>defined_on</code> one of <code>'vertices','faces','edges','halfedges','texture'</code>, is this data a value per vertex or a value per face, etc?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p> <p>The <code>param_name</code> and <code>image_origin</code> arguments are used only if <code>defined_on='texture'</code>. See below for details.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#scalar-texture-maps","title":"Scalar Texture Maps","text":"<p>Texture images define data by storing it an image grid, and using coordinates defined on the face-corners or vertices of a mesh to sample values from the image for each point on the surface.</p> <p>To visualize scalar data defined in texture maps, first add a Parameterization Quantity (aka UV map) defining the coordinates. Then, add a buffer of image data to be sampled from.</p> <p>The resulting scalar texture supports color mapping and all of the other usual scalar data features.</p> <p>Example <pre><code>import numpy as np\nimport polyscope as ps\n\nps.init()\n\n# add a mesh\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3)\nfaces = np.random.randint(0, N_vert, size=(N_face,3))\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# add a parameterization (aka UV map)\nparam_vals = np.random.rand(ps_mesh.n_vertices(), 2)\nps_mesh.add_parameterization_quantity(\"test_param\", param_vals, \n                                      defined_on='vertices', enabled=True)\n\n# add the texture quantity\ndims = (200,300)\nvals = np.random.rand(*dims) # dummy placeholder image data\nps_mesh.add_scalar_quantity(\"test_vals\", vals, \n                             defined_on='texture', param_name=\"test_param\", \n                             filter_mode='nearest',\n                             vminmax=(-5., 5.), enabled=True)\n\nps.show()\n</code></pre></p> <p>Texture image data is added via <code>add_scalar_quantity()</code>, with <code>defined_on='texture'</code> and <code>param_name=...</code> specifying the name of the parameterization UV map with coordinates on <code>[0,1]</code> which will be used to sample from the image.</p> <p>The texture image data, dimension, and origin conventions are the same as those used to define images. See there for details.</p> <p>The filter mode can be set as an additional argument to adjust how values are sampled from the texture. <code>filter_mode='linear'</code> (default) will smoothly linearly interpolate values, while <code>filter_mode='nearest'</code> will use nearest-neighbor sampling, which can be useful for sharp edges and crisp boundaries.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/surface_mesh/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/surface_mesh/texture_map_quantities/","title":"Texture Map Quantities","text":"<p>Scalar and color texture maps can be used to define on surface meshes. See the relevant sections in the scalar and color quantity sections.</p> <ul> <li>Scalar texture maps</li> <li>Color texture maps</li> </ul>"},{"location":"structures/surface_mesh/variable_transparency/","title":"Variable Transparency","text":"<p>You can set the transparency individually for each element in a surface mesh by specifing an existing scalar quantity to serve as the transparency. This can also be set manually in the GUI via the point cloud <code>[Options] --&gt; [Variable Transparency]</code> setting.</p> <p>Per-vertex, per-face, and per-corner scalar quantities are supported for use as transparency values.</p> <p>See the transparency section for more transparency-related options.</p> <p></p> <p>All values will be clamped into the <code>[0,1]</code> range. The transparency is multiplicative with any other transparency effects, such as setting the structure\u2019s global transparency value.</p> <code>SurfaceMesh.set_transparency_quantity(quantity_name)</code> <code>SurfaceMesh.clear_transparency_quantity()</code>"},{"location":"structures/surface_mesh/variable_transparency/#set-transparency-quantity","title":"set transparency quantity","text":"<p>Set the transparency quantity by name. The quantity must be a vertex, face, or corner scalar quantity added to this mesh.</p> <p>All values will be clamped into the <code>[0,1]</code> range.</p> <p>If transparency is not already enabled, updates the transparency mode to be <code>Pretty</code>.</p>"},{"location":"structures/surface_mesh/variable_transparency/#clear-transparency-quantity","title":"clear transparency quantity","text":"<p>Clear the transparency quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the elements of a surface mesh.</p> <p></p> <p>Example: <pre><code>import numpy as np\nimport polyscope as ps\nps.init()\n\n# register a surface mesh\nN_vert = 100\nN_face = 250\nvertices = np.random.rand(N_vert, 3) # (V,3) vertex position array\nfaces = np.random.randint(0, N_vert, size=(N_face,3)) # (F,3) array of indices \n                                                      # for triangular faces\n\nps_mesh = ps.register_surface_mesh(\"my mesh\", vertices, faces)\n\n# visualize some random vectors per vertex\nvecs_vert = np.random.rand(N_vert, 3)\nps_mesh.add_vector_quantity(\"rand vecs\", vecs_vert, enabled=True)\n\n# set radius/length/color of the vectors\nps_mesh.add_vector_quantity(\"rand vecs opt\", vecs_vert, radius=0.001, \n                            length=0.005, color=(0.2, 0.5, 0.5))\n\n# ambient vectors don't get auto-scaled, useful e.g. when representing offsets in 3D space\nps_mesh.add_vector_quantity(\"vecs ambient\", vecs_vert, vectortype='ambient')\n\n# view the mesh with all of these quantities\nps.show() \n</code></pre></p> <code>SurfaceMesh.add_vector_quantity(name, values, defined_on='vertices', enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at vertices/faces (or <code>Nx2</code> for 2D data)</li> <li><code>defined_on</code> string, one of <code>vertices</code> or <code>faces</code>, is this data a vector per-vertex or a vector per-face?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/#tangent-vectors","title":"Tangent vectors","text":"<p>Tangent vectors lie flat against the surface of a mesh. They are defined as 2D vector in a local 2D coordinate system at each vertex or face. We need to specify the vector itself as well as the basis vectors for the local coordinate systems.</p> <code>SurfaceMesh.add_tangent_vector_quantity(name, values, basisX, basisY, defined_on='vertices', n_sym=1, enabled=None, vectortype=\"standard\", length=None, radius=None, color=None, ribbon=None)</code> <p>Add a vector quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx2</code> numpy array, of tangent vectors at vertices/faces</li> <li><code>basisX</code> an <code>Nx3</code> numpy array, giving the X component of the local basis at each vertex/face</li> <li><code>basisY</code> an <code>Nx3</code> numpy array, giving the Y component of the local basis at each vertex/face</li> <li><code>defined_on</code> string, one of <code>vertices</code> or <code>faces</code>, is this data a vector per-vertex or a vector per-face?</li> <li><code>n_sym</code> is a symmetry order for visualizing line fields (n = 2) and cross fields (n = 4), etc. If it is set to a non-<code>1</code> value, n distinct vectors will be displayed at each element, by rotating the input vector 2*PI/nSym radians.</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/#one-forms","title":"One forms","text":"<p>One forms are tangent vector-like quantities represented as integrated scalars along edges. They commonly arise, for example, as a gradient which is difference of scalar values at vertices.</p> <code>SurfaceMesh.add_one_form_vector_quantity(name, values, orientations, enabled=None, length=None, radius=None, color=None, ribbon=None)</code> <p>Add a one-form vector quantity to the mesh.  Remember, before passing edge-valued data, set the indexing convention Polyscope.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>n_edges</code> numpy float array, integrated 1-form values at edges</li> <li><code>orientations</code> a length <code>n_edges</code> numpy boolean array. 1-forms are defined with respect to an orientation of edges, so you need to tell Polyscope which direction your edges point in. These booleans should be <code>true</code> if the edge points from the lower indexed adjacent vertex to the higher-indexed vertex, and false otherwise.</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/surface_mesh/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> <li><code>material</code> string, shading material for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_grid/basics/","title":"Volume Grids","text":"<p>Volume grid structures visualize data defined on an axis-aligned regularly-spaced 3D grid. </p> <p>As usual, first you register a volume grid, then add one or more quantities defined on that grid. Registering the grid itself just means specifying the locations of its extremal corners and the grid resolution. Then you can add data, such as scalar data as linearly-interpolated values per-node or as piecewise-constant values per-cell. Slice planes can also be used inspect the interior of the grid, isosurfaces can be extracted from scalar functions at nodes, and more. </p>    Your browser does not support the video tag.  <p>Example: registering a volume grid and adding a scalar quantity <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# define the resolution and bounds of the grid\ndims = (20, 20, 20)\nbound_low = (-3., -3., -3.)\nbound_high = (3., 3., 3.)\n\n# register the grid\nps_grid = ps.register_volume_grid(\"sample grid\", dims, bound_low, bound_high)\n\n# your dimX*dimY*dimZ buffer of data\nscalar_vals = np.zeros(dims[0], dims[1], dims[2]) \n\n# add a scalar function on the grid\nps_grid.add_scalar_quantity(\"node scalar1\", scalar_vals, \n                            defined_on='nodes', vminmax=(-5., 5.), enabled=True)\n\nps.show()\n</code></pre></p>"},{"location":"structures/volume_grid/basics/#registering-a-volume-grid","title":"Registering a volume grid","text":"<p>Specifying node vs. cells</p> <p>Volume grid dimensions and locations are always defined in terms of nodes (aka cell corners). The dimension is the number of nodes along each axis, and the location is defined by the extremal nodes.</p> <p>For dimensions, if you are instead thinking in terms of the number of cells (little cubical regions), add +1 to the number of cells along each dimension to get the equivalent number of nodes when registering the grid.</p> <p>For locations, the min/max bounds you specify when registering the grid are the locations up the minimum and maximum node (aka cell corner). If you are instead thinking in terms of cell center locations, shift them half-cell-width offset when registering the grid.</p> <code>register_volume_grid(name, node_dims, bound_low, bound_high, enabled=None, color=None, edge_color=None, edge_width=None, cube_size_factor=None, material=None, transparency=None)</code> <p>Add a new volume grid structure to Polyscope.</p> <ul> <li><code>name</code> the name of the structure</li> <li><code>node_dims</code> an integer 3-tuple giving the number of nodes in the grid along each dimension</li> <li><code>bound_low</code> a float 3-tuple giving the xyz coordinates for the minimal node corner of the grid</li> <li><code>bound_high</code> a float 3-tuple giving the xyz coordinates for the maximal node corner of the grid</li> </ul> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>color</code> float 3-tuple, color for the volume as rgb in [0,1]</li> <li><code>edge_color</code> float 3-tuple, color for grid edges as rgb in [0,1] (be sure to set <code>edge_width</code> too)</li> <li><code>edge_width</code> float, width of edges on the grid; default sets <code>0</code> to disable edges, <code>1</code> is a reasonable value to enable</li> <li><code>cube_size_factor</code> float, shrink factor from 0-1 to draw gaps between cells, 0 is no shrink (default)</li> <li><code>material</code> string, name of material to use for the grid</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_grid/basics/#slice-planes","title":"Slice planes","text":"<p>Slice planes are particularly useful for inspecting the internal structure of a volume grid, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.</p>"},{"location":"structures/volume_grid/basics/#picking","title":"Picking","text":"<p>\u201cPicking\u201d refers to selecting and inspecting elements by clicking on the object in the scene. Picking volume grid elements works a little differently from other structures. For most structures, each click selects an element of the structure. However for volume grids, clicking on the structure once initiates picking, then the UI continuously displays data for the location under your mouse cursor. You can always deselect the volume grid elements by clicking somewhere off the grid.</p> <p>By default, if you have only registered data defined on nodes, then only nodes can be picked (and vice-versa for cells). You can override this behavior by calling <code>volume_grid.mark_nodes_as_used()</code>, to act as if a node quantity had been added, and likewise for <code>volume_grid.mark_cells_as_used()</code>.</p>"},{"location":"structures/volume_grid/basics/#options","title":"Options","text":"<p>See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? color the color of the volume <code>get_color()</code> <code>set_color(val)</code> yes edge color the color of the grid edges <code>get_edge_color()</code> <code>set_edge_color(val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>double get_edge_width()</code> <code>set_edge_width(val)</code> yes cube size factor shrink factor from 0-1 to draw gaps between cells, 0 is no shrink (default) <code>get_cube_size_factor()</code> <code>set_cube_size_factor(val)</code> yes material what material to use <code>get_material()</code> <code>set_material(name)</code> yes <p>(All setters return <code>this</code> to support chaining. Structure options return a generic structure pointer, so chain them last.)</p>"},{"location":"structures/volume_grid/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar-valued data at the nodes or cells of a volume grid.</p> <p></p> <p>Example: registering a volume grid and adding a scalar quantity <pre><code>import polyscope as ps\nimport numpy as np\n\nps.init()\n\n# define the resolution and bounds of the grid\ndims = (20, 20, 20)\nbound_low = (-3., -3., -3.)\nbound_high = (3., 3., 3.)\n\n# register the grid\nps_grid = ps.register_volume_grid(\"sample grid\", dims, bound_low, bound_high)\n\n# your dimX*dimY*dimZ buffer of data\nscalar_vals = np.zeros(dims[0], dims[1], dims[2]) \n\n# add a scalar function on the grid\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes')\n\n# set some scalar options \nps_grid.add_scalar_quantity(\"node scalar2\", scalar_vals, defined_on='nodes', \n                            vminmax=(-5., 5.), cmap='blues', enabled=True)\n\nps.show()\n</code></pre></p>"},{"location":"structures/volume_grid/scalar_quantities/#add-scalars","title":"Add scalars","text":"<code>VolumeGrid.add_scalar_quantity(name, values, defined_on='nodes', datatype=\"standard\", **scalar_args)</code> <p>Add a scalar quantity defined at the nodes of the grid.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a numpy array of shape <code>(dimX, dimY, dimZ)</code> giving scalars at nodes/cells. </li> <li><code>defined_on</code> one of <code>'nodes', 'cells'</code>, is this data a value per node or a value per cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_grid/scalar_quantities/#add-implicit-scalars","title":"Add implicit scalars","text":"<p>Implicit helpers</p> <p>Implicit helpers offer an easier way to interface your data with Polyscope. You define a callback function which can be called at a batch of xyz coordinates to return a batch of values, and pass that function as input. Polyscope then automatically takes care of calling the function at the appropriate locations to sample the function onto the grid.</p> <p>See Implicit Helpers for more details about implicit helpers.</p> <code>VolumeGrid.add_scalar_quantity_from_callable(name, func, defined_on='nodes', datatype=\"standard\", **scalar_args)</code> <p>Add a scalar quantity defined at the nodes of the grid, sampling automatically via a callable function.</p> <ul> <li><code>func</code> is a function which performs a batch of evaluations of the implicit function. It should take a <code>(Q,3)</code> numpy array of world-space xyz locations at which to evaluate the function where <code>Q</code> is the number of queries, and return a <code>(Q,)</code> numpy array of results. </li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_grid/scalar_quantities/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/volume_grid/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_grid/scalar_quantities/#visualizing-isosurfaces","title":"Visualizing Isosurfaces","text":"<p>For a scalar values at nodes, we can additionally extract isosurfaces (aka levelsets) via the marching cubes algorithm, and visualize them as surface meshes.</p> <p></p> <p>Example: visualizing scalar isosurfaces <pre><code># continued after the grid as been set up as in the example above\n\n# draw the isosurfce, hiding the usual grid so it is visible\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes',\n                            enable_isosurface_viz=True, isosurface_level=0.5,\n                            isosurface_color=(0.2, 0.1, 0.8),\n                            enable_gridcube_viz=False)\nps.show()\n\n# draw the isosurface, using a slice plane to cut through it\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes',\n                            enable_isosurface_viz=True, isosurface_level=0.5,\n                            slice_planes_affect_isosurface=False)\nps.add_scene_slice_plane()\nps.show()\n\n\n# extract the isosurface as its own mesh structure\nscalarQ-&gt;registerIsosurfaceAsMesh(\"my isosurface mesh\");\nps_grid.add_scalar_quantity(\"node scalar\", scalar_vals, defined_on='nodes',\n                            enable_isosurface_viz=True, isosurface_level=0.5,\n                            register_isosurface_as_mesh_with_name='isosurface mesh')\n</code></pre></p> <p>The following optional arguments to the node scalar quantity adder affect the behavior of isosurfaces. </p> <p>Note</p> <p>By default, the grid obscures the isosurface so it cannot be seen. You probably want to either:</p> <ul> <li>use a slice plane, along with the <code>slice_planes_affect_isosurface=False</code> option, or</li> <li>use <code>enable_gridcube_viz=False</code> to disable the default grid visualization</li> </ul> <ul> <li><code>enable_gridcube_viz</code> boolean, is the usual grid cube visualization drawn</li> <li><code>enable_isosurface_viz</code> boolean, should the isosurface be extracted and drawn</li> <li><code>isosurface_level</code> float, which isolevel should be extracted</li> <li><code>isosurface_color</code> 3-tuple of floats, color of the isosurface mesh</li> <li><code>slice_planes_affect_isosurface</code> boolean, do slice planes affect the isosurface</li> <li><code>register_isosurface_as_mesh_with_name</code> string, if given, register the isosurface as a new mesh with this name. Passing <code>\"\"</code> generates a default name.</li> </ul>"},{"location":"structures/volume_mesh/basics/","title":"Volume Meshes","text":"<p>Volumetric meshes, such as tetrahedral (tet) and hexahedral (hex, cube-like) meshes, represent a region of 3D space. Polyscope can display tet and hex meshes, including those which have a mix of hex and tet elements. We\u2019ll use the term cell to refer generically to a tet or hex in a volume mesh. As always, Polyscope can also handle scalar, color, or vector quantities associated with the vertices or cells of the mesh, and you can click on the mesh elements to inspect values.</p>    Your browser does not support the video tag."},{"location":"structures/volume_mesh/basics/#registering-a-volume-mesh","title":"Registering a volume mesh","text":"<p>Example: registering a tetrahedral mesh</p> <pre><code>import polyscope as ps\nimport numpy as np\nimport igl\n\nverts, tets, _ = igl.read_mesh(\"my_mesh.mesh\")\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add a scalar function on vertices\ndata_vert = np.random.rand(n_vert)\nps_vol.add_scalar_quantity(\"my vertex val\", data_vert)\n\n# you can also access the structure by name\nps.get_volume_mesh(\"test volume mesh\").add_scalar_quantity(\"my vertex val\", data_vert)\n\n# Add a scalar function on cells (with some options set)\ndata_cell = np.random.rand(n_cell)\nps_vol.add_scalar_quantity(\"my cell val\", data_cell, defined_on='cells',\n                           vminmax=(-3., 3.), cmap='blues')\n\n# Show the GUI\nps.show() \n</code></pre> <p>Volume meshes are registered with Polyscope by passing the location of each vertex in the mesh, as well as the vertex indices for each cell. There are a few different argument variants to register meshes with tets, hexes, or a mix of the two. </p> <p></p> <code>register_volume_mesh(name, vertices, tets=None, hexes=None, mixed_cells=None, enabled=None, color=None, interior_color=None, edge_color=None, edge_width=None, material=None)</code> <p>Add a new volume mesh structure to Polyscope.</p> <ul> <li><code>name</code> string, a name for the structure</li> <li><code>vertices</code> an <code>Nx3</code> numpy float array of vertex locations </li> </ul> <p>The elements are specified by a combination of the following arguments:</p> <ul> <li><code>tets</code> a <code>Tx4</code> numpy integer array of tetrahedra, as 0-based indices in to the vertices array</li> <li><code>hexes</code> a <code>Hx8</code> numpy integer array of hexahedra, as 0-based indices in to the vertices array</li> <li><code>mixed_cells</code> a <code>Mx8</code> numpy integer array which may contain a mix of tetrahedra and hexahedra. For any rows which are tets and thus have just 4 indices, the remaining indices should be set to any negative value.</li> </ul> <p>You may pass in <code>tets</code>, <code>hexes</code>, or both to specify the connectivty. Alternately, <code>mixed_cells</code> may be used. However, it is not supported to specify both <code>tets</code>/<code>hexes</code> and <code>mixed_cells</code>.  For the purposes of element ordering, when <code>tets</code> and <code>hexes</code> are both passed, the cells are presumed to be ordered with all tetrahedral cells coming first, then hexahedral cells.</p> <p>Additional optional keyword arguments:</p> <ul> <li><code>enabled</code> boolean, is the structure enabled initially</li> <li><code>color</code> float 3-tuple, default color values for the outside of the mesh as rgb in [0,1]</li> <li><code>interior_color</code> float 3-tuple, default color values for the inside of the mesh as rgb in [0,1]</li> <li><code>edge_color</code> float 3-tuple, default color values for edges of the mesh as rgb in [0,1] (be sure to set <code>edge_width</code> too)</li> <li><code>edge_width</code> float, width of edges in rendered mesh; default sets <code>0</code> to disable edges, <code>1</code> is a reasonable value to enable</li> <li><code>material</code> string, name of material to use for the mesh</li> </ul> <p>if not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p> <p>No support for 2D</p> <p>Unlike other structures, 2D volume meshes are not supported; they don\u2019t make much sense (see 2D data).</p>"},{"location":"structures/volume_mesh/basics/#updating-a-mesh","title":"Updating a mesh","text":"<p>The locations of the vertices in a mesh can be updated with the member function <code>update_vertex_positions(newPositions)</code>. All quantities will be preserved. Changing the connectivity or element counts in a mesh is not supported, you will need to register a new mesh (perhaps with the same name to overwrite).</p> <code>VolumeMesh.update_vertex_positions(newPos)</code> <p>Update the vertex positions in a volume mesh structure. <code>newPos</code> must be valid input to initially construct the vertex positions, with the same number of vertices.</p>"},{"location":"structures/volume_mesh/basics/#slice-planes","title":"Slice planes","text":"<p>Slice planes are particularly useful for inspecting the internal structure of a volume mesh, as shown in the demo video at the top. Slice planes can be manipulated programmatically or manually in the GUI; see the slice plane documentation for more details.</p> <p>Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.</p>"},{"location":"structures/volume_mesh/basics/#options","title":"Options","text":"<p>Options control the appearance of the mesh. These options can also be passed as keyword arguments to the initial <code>register_volume_mesh()</code>, as noted above.  See structure management for options common to all structures such as enabling/disabling, transforms, and transparency.</p> Parameter Meaning Getter Setter Persistent? color the color of the outside of the volume <code>get_color()</code> <code>set_color(val)</code> yes interior color the color of the inside of the volume <code>get_interior_color()</code> <code>set_interior_color(val)</code> yes edge color the color of the edges of the mesh <code>get_edge_color()</code> <code>set_edge_color(val)</code> yes edge width how thick to draw mesh edges, use <code>0.</code> to disable and <code>1.</code> for reasonable edges <code>get_edge_width()</code> <code>set_edge_width(val)</code> yes material what material to use <code>get_material()</code> <code>set_material(name)</code> yes <p>Example: set options which affect the appearance of the mesh <pre><code>import numpy as np\nimport polyscope as ps\n\n# a simple inline mesh\nverts = np.array([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n    [1, 0, 1],\n    [1, 1, 1],\n    [0, 1, 1],\n    [1, 1, 1.5]\n])\ncells = np.array([\n  [0, 1, 2, 3, 4, 5, 6, 7],\n  [7, 5, 6, 8, -1, -1, -1, -1],\n])\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, mixed_cells=cells)\n\nps_vol.set_enabled(False) # disable\nps_vol.set_enabled() # default is true\n\nps_vol.set_color((0.3, 0.6, 0.8)) # rgb triple on [0,1]\nps_vol.set_interior_color((0.4, 0.7, 0.9))\nps_vol.set_edge_color((0.8, 0.8, 0.8)) \nps_vol.set_edge_width(1.0)\nps_vol.set_material(\"wax\")\nps_vol.set_transparency(0.5)\n\n# alternately:\nps.register_volume_mesh(\"test volume mesh 2\", verts, mixed_cells=cells, enabled=False, \n                         color=(1., 0., 0.), interior_color=(0., 1., 0.),\n                         edge_color=((0.8, 0.8, 0.8)), edge_width=1.0, \n                         material='candy', transparency=0.5)\n\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/color_quantities/","title":"Color Quantities","text":"<p>Visualize color rgb-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing a color value at cells (here, random values) <pre><code># ... initialization, create mesh ...\n\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add a color function on cells (with some options set)\ncolors = np.random.rand(n_cell, 3)\nps_vol.add_color_quantity(\"my color\", colors, defined_on='cells', enabled=True)\n\n# Show the GUI\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/color_quantities/#add-colors-to-elements","title":"Add colors to elements","text":"<code>VolumeMesh.add_color_quantity(name, values, defined_on='vertices', enabled=None)</code> <p>Add a scalar quantity to the network.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, with rgb [0,1] colors at vertices/cells</li> <li><code>defined_on</code> string, one of <code>\"vertices\"</code> or <code>\"cells\"</code>, is this data a color per vertex or a color per cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_mesh/color_quantities/#color-quantity-options","title":"Color Quantity Options","text":"<p>When adding a color quantity, the following keyword options can be set. These are available for all kinds of color quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_mesh/scalar_quantities/","title":"Scalar Quantities","text":"<p>Visualize scalar (real or integer)-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing a scalar on vertices (here, random values) <pre><code># ... initialization, create mesh ...\n\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add a scalar function on vertices\ndata_vert = np.random.rand(n_vert)\nps_vol.add_scalar_quantity(\"my vertex val\", data_vert)\n\n# Add a scalar function on cells (with some options set)\ndata_cell = np.random.rand(n_cell)\nps_vol.add_scalar_quantity(\"my cell val\", data_cell, defined_on='cells',\n                           vminmax=(-3., 3.), cmap='blues', enabled=True)\n\n// Show the GUI\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/scalar_quantities/#add-scalars-to-elements","title":"Add scalars to elements","text":"<code>VolumeMesh.add_scalar_quantity(self, name, values, defined_on='vertices', enabled=None, datatype=\"standard\", vminmax=None, cmap=None)</code> <p>Add a scalar quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> a length <code>N</code> numpy array, scalars at vertices/cells</li> <li><code>defined_on</code> one of <code>'vertices','cells'</code>, is this data a value per vertex or a value per cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_mesh/scalar_quantities/#inspecting-with-slice-planes","title":"Inspecting with slice planes","text":"<p>Slice planes have special functionality for volume mesh vertex values\u2014they can inspect quantities on volume meshes and render them on the interior of the volume. See the slice plane documentation for details.</p>"},{"location":"structures/volume_mesh/scalar_quantities/#categorical-scalars","title":"Categorical Scalars","text":"<p>Scalar quantities can also be used to visualize integer-valued labels such as categories, classes, segmentations, flags, etc.</p> <p>Add the labels as a scalar quantity where the values just happen to be integers (each integer represents a particular class or label), and set <code>datatype='categorical'</code>. This will change the visualization to a different set of defaults, adjust some shading rules, and use a distinct color from the colormap for each label.</p>"},{"location":"structures/volume_mesh/scalar_quantities/#scalar-quantity-options","title":"Scalar Quantity Options","text":"<p>When adding a scalar quantity, the following keyword options can be set. These are available for all kinds of scalar quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (note that generally only one quantitiy can be shown at a time; the most recent will be used)</li> <li><code>datatype</code>, one of <code>\"standard\"</code>, <code>\"symmetric\"</code>, <code>\"magnitude\"</code>, or <code>\"categorical\"</code>, affects default colormap and map range, and the categorical policies mentioned above</li> <li><code>vminmax</code>, a 2-tuple of floats, specifying the min and max range for colormap limits; the default is <code>None</code>, which computes the min and max of the data</li> <li><code>cmap</code>, which colormap to use</li> <li>isoline keywords (darker-shaded stripes showing isocontours of the scalar field):<ul> <li><code>isolines_enabled</code> are isolines enabled (default: <code>False</code>)</li> <li><code>isoline_style</code> one of <code>stripe</code>, <code>'contour</code> (default: <code>stripe</code>)</li> <li><code>isoline_period</code> how wide should the darkend stripes be, in data units (default: dynamically estimated)</li> <li><code>isoline_period_relative</code> if true, interpret the width value as relative to the world coordinate length scale (default: <code>False</code>)</li> <li><code>isoline_darkness</code> how much darker should the alternating stripes be (default: <code>0.7</code>)</li> <li><code>isoline_contour_thickness</code> how thick should the contour lines be (default: <code>0.3</code>)</li> </ul> </li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"},{"location":"structures/volume_mesh/vector_quantities/","title":"Vector Quantities","text":"<p>Visualize vector-valued data at the elements of a volume mesh.</p> <p></p> <p>Example: showing vectors on vertices (here random vectors) <pre><code># ... initialization, create mesh ...\n\nps_vol = ps.register_volume_mesh(\"test volume mesh\", verts, tets=tets)\n\nn_vert = verts.shape[0]\nn_cell = tets.shape[0]\n\n# Add vectors on vertices (with some options set)\nvecs = np.random.rand(n_vert, 3)\nps_vol.add_vector(\"my color\", vecs, enabled=True, vectortype='ambient')\n\n# Show the GUI\nps.show()\n</code></pre></p>"},{"location":"structures/volume_mesh/vector_quantities/#add-vectors-to-elements","title":"Add vectors to elements","text":"<code>VolumeMesh.add_vector_quantity(name, values, defined_on='vertices', enabled=None, vectortype=\"standard\", length=None, radius=None, color=None)</code> <p>Add a vector quantity to the mesh.</p> <ul> <li><code>name</code> string, a name for the quantity</li> <li><code>values</code> an <code>Nx3</code> numpy array, vectors at vertices/cells</li> <li><code>defined_on</code> string, one of <code>vertices</code> or <code>cells</code>, is this data a vector per-vertex or a vector per-cell?</li> </ul> <p>This function also accepts optional keyword arguments listed below, which customize the appearance and behavior of the quantity.</p>"},{"location":"structures/volume_mesh/vector_quantities/#vector-quantity-options","title":"Vector Quantity Options","text":"<p>When adding a vector quantity, the following keyword options can be set. These are available for all kinds of vector quantities on all structures.</p> <p>Keyword arguments:</p> <ul> <li><code>enabled</code> boolean, whether the quantity is initially enabled (Default: <code>false</code>)</li> <li><code>vectortype</code>, one of <code>\"standard\"</code> or <code>\"ambient\"</code>. Ambient vectors don\u2019t get auto-scaled, and thus are good for representing values in absolute 3D world coordinates. (Default: <code>\"standard\"</code>)</li> <li><code>length</code> float, a (relative) length for the vectors</li> <li><code>radius</code> float, a (relative) radius for the vectors</li> <li><code>color</code> 3-tuple, color for the vectors</li> <li><code>material</code> string, shading material for the vectors</li> </ul> <p>If not specified, these optional parameters will assume a reasonable default value, or a persistent value if previously set.</p>"}]}